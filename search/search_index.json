{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#omega-py-python-tools-for-omega-data","title":"OMEGA-Py : Python tools for OMEGA data","text":"<p>OMEGA-Py is a Python 3 module dedicated to the scientific use of data provided by the Observatoire pour la Min\u00e9ralogie, l'Eau, les Glaces et l'Activit\u00e9 (OMEGA) instrument onboard the ESA Mars Express (MEx) orbiter<sup>1</sup>. It has been developed as an alternative to the historical SOFT 10 IDL routines of the official OMEGA software provided by the instrument team<sup>2</sup>.</p> <p>The module notably includes a re-implementation of the most recent release of the IDL OMEGA software, but also contains several additional data reduction functions such as build-in atmospheric and thermal corrections (using previously published methods) and graphics tools including interactive visualization of the data or generation of composite OMEGA maps.</p>"},{"location":"#why-this-module","title":"Why this module?","text":"<p>The accessibility of data returned by space missions is a crucial point to ensure the development of open science. While the OMEGA dataset is public with yearly releases as of 2024, the legacy pipeline uses a proprietary software and several crucial data reduction algorithms are not public, thus severely hindering its use. Since the beginning of the science phase of the OMEGA instrument in 2004, the instrument team has provided 10 releases of the IDL software (<code>SOFT01</code> to <code>SOFT10</code>) to read the level 1B binary files that can be downloaded from the ESA PSA  and generate level 2A data with reflectance spectra.</p> <p>However, the presence of an IDL\u00a0solution only may raise some concerns:</p> <ul> <li>The cost of an IDL license, as it is a proprietary language, makes it not accessible to everyone.</li> <li>As the community (and especially the youngest generation) is moving to use mostly Python    instead of IDL, the requirement to use the IDL\u00a0language to access OMEGA data can limit its    accessibility.</li> </ul> <p>In addition, over the past years, the OMEGA dataset had a reputation in the community for being challenging and requiring a lot of investment to use. With OMEGA-Py we aim to tackle this reputation by providing a free all-in-one toolbox to load, correct, analyze, and visualize the OMEGA data, and thus make the unique OMEGA dataset rich of 20 years of observations easily accessible to the community and especially to the younger generation of scientists and students.</p>"},{"location":"#main-features","title":"Main features","text":"<ul> <li>Importation of raw PSA-format data.</li> <li>Data correction from instrumental effects.</li> <li>Thermal and atmospheric corrections.</li> <li>Visualization of the data with interactive tools.</li> </ul>"},{"location":"#futures-improvement","title":"Futures improvement","text":"<ul> <li>Compatibility with files downloaded from the PDS (lowercase letters) and not only PSA (uppercase letters)</li> <li>Automatic download of files from the PSA FTP</li> <li>Use of a custom atmospheric spectrum for the atmospheric correction</li> <li>Optimization of the customization of display functions</li> <li>Add slider to change the displayed wavelength for the reflectance for interactive plots</li> <li>Simplify the use of the thermal and atmospheric correction functions \u2192 only one with multiple arguments</li> <li>Add more filtering options in the <code>find_cube</code> function</li> </ul> <ol> <li> <p>J.-P. Bibring, A. Soufflot, M. Berth\u00e9, et al. (2004).  OMEGA : Observatoire pour la Min\u00e9ralogie, l'Eau, les Glaces et l'Activit\u00e9. ESA Publication Division, 1240, 37\u00a0\u21a9</p> </li> <li> <p>ftp://psa.esac.esa.int/pub/mirror/MARS-EXPRESS/OMEGA/MEX-M-OMEGA-2-EDR-FLIGHT-EXT7-V1.0/SOFTWARE/ \u21a9</p> </li> </ol>"},{"location":"basic_usage/","title":"Basic usage","text":"<pre><code># Package importation\nimport omegapy.omega_data as od\nimport omegapy.omega_plots as op\nimport omegapy.useful_functions as uf\n\n# OMEGA file importation (ORB0979_3)\nomega = od.OMEGAdata('0979_3')\n\n# Atmospheric correction\nomega_corr_atm = od.corr_atm(omega)\n\n# Simultaneous Atmospheric &amp; Thermal corrections (for the use of the L-channel)\n# &gt; Use the `npool` argument to control the number of simultaneous processes \n# &gt; used to compute the thermal correction \n# &gt; (e.g., npool=15 is usually a nice choice if your system can handle it)\n# &gt; Note: multiprocessing is currently not available for Windows\nomega_corr_therm_atm = od.corr_therm_atm(omega, npool=1)\n\n# Thermal correction only\nomega_corr_therm = od.corr_therm(omega, npool=1)\n\n# OMEGA mask to hide bad pixels / calibration lines\nmask = od.omega_mask(\n    omega_corr_therm_atm, \n    hide_128=True, \n    emer_lim=10, \n    inci_lim=70, \n    tempc_lim=-194, \n    limsat_c=500\n    )\n\n# Interactive display of the observation (@ \u03bb = 1.085 \u00b5m)\nop.show_omega_interactif_v2(\n    omega_corr_therm_atm, \n    lam=1.085, \n    cmap='Greys_r', \n    vmin=0, \n    vmax=0.5, \n    polar=True,\n    mask=mask\n    )\n\n# Search for the index of \u03bb = 1.085 \u00b5m in the wavelength array\ni_lam = uf.where_closer(1.085, omega.lam)\n</code></pre>"},{"location":"community/","title":"Community guidelines","text":""},{"location":"community/#contribute","title":"Contribute","text":"<p>We are welcoming contributions to improve OMEGA-Py.  Please fork the <code>omegapy</code> repository to make your  updates, then make a pull request to merge it with the main project branch.</p> <p>For each new update, please follow these guidelines:</p> <ul> <li>For any change to OMEGA-Py, update the documentation accordingly in docs.</li> <li>Keep the code style (the naming of functions/scripts, the headers, sections...) and comment     your updates.</li> <li>In the pull request, explains clearly what you changed/added and what it brings to the project.</li> </ul>"},{"location":"community/#report-issues","title":"Report issues","text":"<p>Please report any bugs or issues you encounter with OMEGA-Py by creating a New Issue on GitHub.</p> <p>To help us address the issue, please include at minimum:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.    (How do you use Python? With an IDE? In a Jupyter Notebook?)</li> <li>Expected vs obtained result.</li> <li>Detailed steps to reproduce the bugs.</li> <li>Include if applicable any output, error message or screenshot relevant to understand the issue.</li> <li>If requesting for a new feature, please describe it precisely and explain why it will be    useful.</li> </ul>"},{"location":"community/#support","title":"Support","text":"<p>If you need support using OMEGA-Py, you can either:</p> <ul> <li>Look carefully at the documentation     (first step = RTFM).</li> <li>Open an issue on GitHub.</li> <li>Contact us directly at aurelien@stcherbinine.net</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>You have to configure the default path of the folders containing the OMEGA binary and omegapy-made files using the environment variables <code>OMEGA_BIN_PATH</code> (for the binary .QUB and .NAV files) and <code>OMEGA_PY_PATH</code> (for the omegapy-made files).</p>"},{"location":"configuration/#linux","title":"Linux","text":"<p>To do so, add the following lines to your <code>~/.bashrc</code> (or <code>~/.zshrc</code>, depending on which shell you are using): <pre><code>export OMEGA_BIN_PATH=\"/path/to/binary/files/folder/\"\nexport OMEGA_PY_PATH=\"/path/to/omegapy-made/files/folder/\"\n</code></pre> Adapt the path to suit your own architecture.</p> <p>Tip: You can check that these variables are properly set up by typing the following command in a new terminal: <code>echo $OMEGA_BIN_PATH</code> and <code>echo $OMEGA_PY_PATH</code>. It should print the path you previously set.</p>"},{"location":"configuration/#macos","title":"MacOS","text":"<p>Similar to the Linux procedure, except that the <code>~/.bashrc</code> file may not be loaded automatically by default. In that case, use instead <code>~/.bash_profile</code>.</p> <p>Note for more recent MacOS versions: The default shell has been changed from bash to zsh in the more recent versions of MacOS. Thus, if you are using a zsh shell, edit the <code>~/.zshrc</code> file instead of <code>~/.bash_profile</code> or <code>~/.bashrc</code>.</p>"},{"location":"configuration/#windows-or-if-you-have-troubles-using-the-environment-variables","title":"Windows (or if you have troubles using the environment variables)","text":"<p>If you are using Windows, you cannot easily set these environment variables. Lucky you, there is a solution!</p> <p>Note that it also apply if you are using another OS but had troubles setting the environment variables as described above (i.e., you are seeing these warnings when loading omegapy: <code>Warning: $OMEGA_BIN_PATH not defined</code> and/or <code>Warning: $OMEGA_PY_PATH not defined</code>).</p> <p>In that case, you can set these path directly with Python using the <code>omega_data.set_omega_bin_path()</code> and <code>omega_data.set_omega_py_path()</code> functions. Assuming you have already load <code>omegapy.omega_data</code> as <code>od</code>, simply execute:</p> WindowsLinux/Mac <pre><code>od.set_omega_bin_path(\"C:\\\\path\\\\to\\\\binary\\\\files\\\\folder\\\")\nod.set_omega_py_path(\"C:\\\\path\\\\to\\\\omegapy-made\\\\files\\\\folder\\\")\n</code></pre> <pre><code>od.set_omega_bin_path(\"/path/to/binary/files/folder/\")\nod.set_omega_py_path(\"/path/to/omegapy-made/files/folder/\")\n</code></pre> <p>Adapt the path to suit your own architecture.</p> <p>You will have to run these commands everytime you start a new Python console, so I suggest to put these lines at the beginning of your script, just after the omegapy import.</p>"},{"location":"credits/","title":"Credits","text":"<p>\u00a9 Aur\u00e9lien Stcherbinine (2020\u20132025)</p> <p>Institut d'Astrophysique Spatiale (IAS), Universit\u00e9 Paris-Saclay, CNRS, Orsay, France</p> <p>LATMOS/IPSL, UVSQ Universit\u00e9 Paris-Saclay, Sorbonne Universit\u00e9, CNRS, Guyancourt, France</p> <p>Department of Astronomy and Planetary Science, Northern Arizona University, Flagstaff, AZ, USA</p> <p>Institut de Recherche en Astrophysique et Plan\u00e9tologie (IRAP), CNES, Universit\u00e9 Toulouse III, CNRS, Toulouse, France</p>"},{"location":"credits/#license","title":"License","text":"<p>This package is released under a MIT open source license. See <code>LICENSE</code> for more details.</p>"},{"location":"credits/#citing-omega-py","title":"Citing OMEGA-Py","text":"<p>If you are using OMEGA-Py in your research, please cite it with our article in the Journal of Open Source Software and the Zenodo archive repository of the source code.</p>"},{"location":"credits/#joss-article","title":"JOSS article","text":"<p>A. Stcherbinine, Y. Langevin, J. Carter, M. Vincendon, Y. Leseigneur, O. Barraud (2024).  OMEGA-Py: Python Tools for OMEGA data. Journal of Open Source Software, 9(99), 6566.  doi:10.21105/joss.06566</p> <p>BibTeX entry</p> <pre><code>@article{omegapy_joss,\nauthor       = {Stcherbinine, Aur\u00e9lien and\n                Langevin, Yves and\n                Carter, John and\n                Vincendon, Mathieu and\n                Leseigneur, Yann and\n                Barraud, Oc\u00e9ane},\ntitle        = {OMEGA-Py: Python Tools for OMEGA Data}, \njournal      = {Journal of Open Source Software},\ndoi          = {10.21105/joss.06566}, \nyear         = 2024, \nmonth        = jul,\nvolume       = {9}, \nnumber       = {99}, \npages        = {6566}, \npublisher    = {The Open Journal}, \nurl          = {https://doi.org/10.21105/joss.06566}, \n}\n</code></pre>"},{"location":"credits/#zenodo-archive-repository","title":"Zenodo archive repository","text":"<p>A. Stcherbinine, Y. Langevin, J. Carter, M. Vincendon, Y. Leseigneur, O. Barraud, F. Schmidt (2025).  OMEGA-Py: Python Tools for OMEGA data (v3.2). Zenodo.  doi:10.5281/zenodo.12775568</p> <p>BibTeX entry</p> <pre><code>@software{omegapy_v3-2,\nauthor       = {Stcherbinine, Aur\u00e9lien and\n                Langevin, Yves and\n                Carter, John and\n                Vincendon, Mathieu and\n                Leseigneur, Yann and\n                Barraud, Oc\u00e9ane and\n                Schmidt, Fr\u00e9d\u00e9ric},\ntitle        = {OMEGA-Py: Python Tools for OMEGA data},\nyear         = 2025,\nmonth        = jan,\npublisher    = {Zenodo},\nversion      = {v3.2},\ndoi          = {10.5281/zenodo.12775568},\nurl          = {https://doi.org/10.5281/zenodo.12775568}\n}\n</code></pre>"},{"location":"data_correction/","title":"Data correction","text":"<p>In addition to the raw data importation, which is done similarly to the IDL <code>readomega</code>, OMEGA-Py also includes build-in functions to perform the atmospheric and thermal corrections on a previously loaded <code>OMEGAdata</code> object, using methods described for instance in Jouglet et al. (2007)<sup>1</sup> or Langevin et al. (2005)<sup>2</sup>.</p> <p> </p>      Illustration of the atmospheric and thermal corrections applied to an OMEGA spectrum      (figure 1 from Stcherbinine et al., 2021)[^3].    <p>In the following, we assume that we have already loaded an OMEGA observation as follows: <pre><code>import omegapy.omega_data as od\n\nomega = od.OMEGAdata('0967_3')\n</code></pre></p>"},{"location":"data_correction/#atmospheric-correction","title":"Atmospheric correction","text":"<p>The atmospheric correction of a data cube is performed using the volcano-scan technique, by scaling a typical atmospheric spectrum from the 2 \u03bcm CO<sub>2</sub> atmospheric band (Langevin et al., 2005)<sup>2</sup>. </p> <p>Info</p> <p>Upcoming versions will allow the user to use a custom atmospheric spectrum instead of the one currently provided. </p> <p>Two methods are available to scale the atmospheric spectrum:</p> Method 1 <p>The first method (mostly used) adjust the atmospheric scaling to force the values of  the reflectance at 1.93 and 2.01 \u03bcm to be the same. <pre><code>omega_corr_atm = od.corr_atm(omega)     # Method 1\n</code></pre></p> Method 2 <p>The second method (less used) adjust the atmospheric scaling to have the \"flattest\" spectra between 1.93 and 2.00 \u03bcm. As it requires a call to a minimization function, the computation time for this method is longer than for the first one. <pre><code>omega_corr_atm2 = od.corr_atm2(omega)   # Method 2\n</code></pre></p>"},{"location":"data_correction/#thermal-correction","title":"Thermal correction","text":"<p>If the thermal contribution of the planet in the OMEGA spectra can be neglected for wavelength  smaller than ~3 \u03bcm, it has to be taken into account when using larger wavelength (i.e., data from the L-channel ; see figure above).</p> <p>The thermal correction can also be performed using two methods.  However, only the first one has been optimized to use  <code>multiprocessing</code> for now.</p> Method 1 (with C-channel) <p>The reflectance at 5 \u03bcm is theoretically estimated from the measured reflectance at 2.4 \u03bcm, using typical spectra of the bright and dark regions of Mars from Calvin (1997)<sup>3</sup>. Then the additional black body component is derived and substracted to the entire spectrum (Jouglet et al., 2007)<sup>1</sup>.</p> <p>In addition, to reduce the computation time of the thermal correction, parallel processing has been implemented using the  <code>multiprocessing</code>  module for this method.  <pre><code>omega_corr_them = od.corr_therm(omega, npool=1)     # Method 1 with 1 single process\n# or\nomega_corr_them = od.corr_therm(omega, npool=10)    # Method 1 with 10 simultaneous processes\n</code></pre></p> <p>Using multiple processes</p> <p><code>npool</code> controls the number of simultaneous processes used to compute the thermal correction of the OMEGA data cube. I.e., it defines the number of <code>multiprocessing.Pool</code> that will be created.</p> Method 2 (without C-channel) <p>If the data from the C-channel are not available, the first method is no longer usable, and it is necessary to fit both the surface temperature ad the reflectance at 5 \u03bcm, as described in Audouard (2014)<sup>4</sup>. <pre><code>omega_corr_them2 = od.corr_therm2(omega)            # Method 2\n</code></pre></p>"},{"location":"data_correction/#simultaneous-atmospheric-thermal-corrections","title":"Simultaneous atmospheric &amp; thermal corrections","text":"<p>For the analysis of data from the L-channel, that requires thermal and atmospheric correction of the spectra, one can performs both corrections at the same time with a dedicated function. This is the recommended way if you want to perform both corrections as the atmosphere will be better taken into account while removing the thermal correction.</p> Method 1 (with C-channel) <p>For now, only the use of both methods 1 for the atmospheric and thermal corrections has been implemented. <pre><code>omega_corr_them_atm = od.corr_therm_atm(omega, npool=10)    # Method 1-1\n</code></pre></p> <p>Using multiple processes</p> <p><code>npool</code> controls the number of simultaneous processes used to compute the thermal correction of the OMEGA data cube. I.e., it defines the number of <code>multiprocessing.Pool</code> that will be created.</p> <p>Correcting and saving OMEGA observations in one single command</p> <p>As the correction of an OMEGA observation can take some time, you may want to save the final cube to avoid reprocessing it every time.</p> <p>Instead of returning an <code>OMEGAdata</code> object after processing the thermal &amp; atmospheric corrections, it is also possible to  save it into a file that can be loaded later using the  <code>corr_save_omega2</code> function (more details here).</p>"},{"location":"data_correction/#checking-applied-corrections","title":"Checking applied corrections","text":"<p>The correction status of an <code>OMEGAdata</code> object can be checked via the value of the booleans: <pre><code>omega.therm_corr    # True if thermal correction applied\n\nomega.atm_corr      # True if atmospheric correction applied\n</code></pre></p> <p>Alternatively, these informations are also displayed in the interactive representation of the object.</p> <p> </p> <p>(left) No corrections applied. (right) Both corrections applied.</p> <p>The informations about the method applied for the corrections can be accessed via: <pre><code>omega.therm_corr_infos\n\nomega.atm_corr_infos\n</code></pre></p> <ol> <li> <p>D. Jouglet, F. Poulet, R. E. Milliken, et al. (2007).  Hydration state of the Martian surface as seen by Mars Express OMEGA : 1. Analysis of the 3 \u03bcm hydration feature.  Journal of Geophysical Research: Planets, 112, E08S06.  doi:10.1029/2006JE002846 \u21a9\u21a9</p> </li> <li> <p>Y. Langevin, F. Poulet, J.-P. Bibring &amp; B. Gondet (2005).  Sulfates in the North Polar Region of Mars Detected by OMEGA/Mars Express. Science, 307, 1584-1586.  doi :10.1126/science.1109091 \u21a9\u21a9</p> </li> <li> <p>W. N. Calvin (1997).  Variation of the 3-\u03bcm absorption feature on Mars : Observations over eastern Valles Marineris by the Mariner 6 infrared spectrometer. Journal of Geophysical Research: Planets, 102, 9097. doi:10.1029/96JE03767 \u21a9</p> </li> <li> <p>J. Audouard (2014). PhD thesis, Universit\u00e9 Paris-Sud XI.\u00a0\u21a9</p> </li> <li> <p>A. Stcherbinine, M. Vincendon, F. Montmessin, P. Beck (2021).  Identification of a new spectral signature at 3 \u00b5m over Martian northern high latitudes: implications for surface composition.  Icarus, 369, 114627.  doi:10.1016/j.icarus.2021.114627 \u21a9</p> </li> </ol>"},{"location":"data_handling/","title":"Data handling","text":"<p>In the following, we assume that we have imported the module as follows: <pre><code>import omegapy.omega_data as od\nimport omegapy.useful_functions as uf\n</code></pre></p>"},{"location":"data_handling/#saving-loading-omega-data","title":"Saving &amp; Loading OMEGA data","text":"<p>The importation and correction of OMEGA data cubes take some time to be achieved. Thus, it is convenient to be able to directly save and load  <code>OMEGAdata</code> object to avoid reprocessing them every time.</p> <p>The saving and loading is done using the <code>pickle</code> module.</p>"},{"location":"data_handling/#saving-omega-data","title":"Saving OMEGA data","text":"<p>Assuming we have an <code>OMEGAdata</code> object <code>omega</code>, the easiest and recommended way to save it is to use the  <code>autosave_omega</code> function:</p> <pre><code>od.autosave_omega(omega)\n</code></pre> <p>Info</p> <p>This function will automatically define the filename depending on the OMEGA cube ID, the OMEGA-Py major version, and the status of the thermal and atmospheric corrections.</p> <p>Observations that are saved with <code>autosave_omega</code> can then be loaded easily with the <code>autoload_omega</code> function, as they use the same filenaming convention.</p> <p>If you prefer to manually define the filename when saving the data, it can be done by using the <code>save_omega</code> function instead.</p>"},{"location":"data_handling/#correcting-and-saving-omega-observations-in-one-single-command","title":"Correcting and saving OMEGA observations in one single command","text":"<p>OMEGA-Py includes functions that will compute the thermal &amp; atmospheric corrections as described here and then automatically save the result for further use with <code>autosave_omega</code>.</p> <p>For one OMEGA cube, this can be done by calling the <code>corr_save_omega2</code> function (instead of <code>corr_therm_atm</code> which will apply the corrections and return the newly created <code>OMEGAdata</code> object).</p> <p>Example</p> <pre><code>od.corr_save_omega2(\n    '0967_3',       # Cube ID\n    npool=10,       # Number of parallel processes for the thermal correction\n    compress=True,  # Remove the radiance (cube_i) cube to decrease the size of the saved file by replacing it by `None`\n    )\n</code></pre> <p>Similarly, it can also be done directly for a list of OMEGA observations (that you would need to process for a specific project) using the  <code>corr_save_omega2_list</code> function. The only difference with the call for one observation is that here the cube ID (<code>str</code>) is  replaced by a list of cube IDs.</p> <p>Example</p> <pre><code>od.corr_save_omega_list2(\n    ['0967_2', '0967_3', '0967_4'],     # List of cube IDs\n    npool=10,       # Number of parallel processes for the thermal correction\n    compress=True,  # Remove the radiance (cube_i) cube to decrease the size of the saved file by replacing it by `None`\n    )\n</code></pre>"},{"location":"data_handling/#loading-omega-data","title":"Loading OMEGA data","text":"<p>Assuming that you have saved an <code>OMEGAdata</code> object using the <code>autosave_omega</code> function, it can be easily loaded with  <code>autoload_omega</code>. As in this case, the filenames and path follows a specific convention, all it needs is the OMEGA cube number and the status of the thermal and atmospheric corrections.</p> <pre><code>omega = od.autoload_omega('0967_3', therm_corr=False, atm_corr=False)       # Cube 0967_3 with no corrections\n\nomega_corr = od.autoload_omega('0967_3', therm_corr=True, atm_corr=True)    # Cube 0967_3 with both corrections\n</code></pre> <p>Not specifying the corrections status</p> <p>If the correction status is not specified, or the exact ID of the OMEGA cube is not provided and there is an ambiguity, it will show all the matching products and ask you to choose the one you want to load by entering the corresponding number (see figure below).</p> <p>Example</p> <pre><code>omega = od.autoload_omega('0967_3')\n</code></pre> <p>      Loading of OMEGA cube 0967_3 with both thermal and atmospheric corrections applied.    </p> <p>It is also possible to load an previously saved OMEGA\u00a0observation by specifying its exact filename, using the <code>load_omega</code> function:</p> <pre><code>omega = od.load_omega('/path/to/saved/data/ORB0967_3.pkl')\n</code></pre>"},{"location":"data_handling/#loading-multiple-omega-observations","title":"Loading multiple OMEGA observations","text":"<p>If needed to load multiple previously computed and saved OMEGA observations, it can be done by using the  <code>load_omega_list2</code> function, which is based on <code>autoload_omega</code>. The only difference between the two is that in this case the cube ID (<code>str</code>) is replaced by a list of cube IDs:</p> <pre><code>omega_list = od.load_omega_list2(\n    ['0967_2', '0967_3', '0967_4', '0979_3'],   # List of OMEGA cubes to load\n    therm_corr=True,    # With thermal correction applied\n    atm_corr=True       # With atmospheric correction applied\n    )\n</code></pre> <p>Alternatively, it is also possible to use a more manual method with the <code>load_omega_list</code> function, which is based on <code>load_omega</code> and takes as an argument the full basename of the files to load.</p> <pre><code>omega_list = od.load_omega_list('/path/to/saved/data/ORB0967_?.pkl')\n</code></pre>"},{"location":"data_handling/#finding-wavelength-indexes","title":"Finding wavelength indexes","text":"<p>The spectra are automatically \"cleaned\" during the importation of the binary files into an <code>OMEGAdata</code> object by:</p> <ul> <li>sorting the wavelength in ascending order</li> <li>removing the wavelength overlap between the different channels</li> <li>removing the corrupted spectels, as identified by the <code>ic</code> array</li> </ul> <p>Consequently, the index of a specific wavelength may change depending on the OMEGA observation considered, especially across the time of the mission. So we provided an easy way to search for the index of a value in an array, that can be used to easily retrieve the index of a specific wavelength, which will be needed to compute any spectral criteria: the <code>where_closer</code> and <code>where_closer_array</code> functions from <code>omegapy.useful_function</code>.</p> <pre><code>omega = od.OMEGAdata('0967_3')      # Loading an OMEGA observation\n\ni_108 = uf.where_closer(1.085, omega.lam)   # Index of \u03bb=1.085\u03bcm\n\ni_150, i_226 = uf.where_closer_array([1.5, 2.26], omega.lam)    # Indexes of \u03bb=1.5\u03bcm and \u03bb=2.26\u03bcm\n</code></pre>"},{"location":"data_handling/#dealing-with-omega-spectra-that-have-different-wavelength-arrays","title":"Dealing with OMEGA spectra that have different wavelength arrays","text":"<p>As mentioned above, it is possible that different OMEGA observations may not have the exact same wavelength array, as some spectels got corrupted across the duration of the mission. It may be of importance especially if you want to compute operations over multiple spectra from different observations (spectral ratio, average...), so OMEGA-Py include some functions to help you tackle this: the <code>shared_lam</code> and <code>shared_lam_omegalist</code> functions.</p> <p>Example 1: individual spectra</p> <p>Let's assume we have 3 spectra as 1D arrays <code>sp1</code>, <code>sp2</code>, <code>sp3</code> and their corresponding wavelength arrays <code>lam1</code>, <code>lam2</code>, <code>lam3</code>.</p> <p>We can find the common wavelengths with <pre><code>lam_new = od.shared_lam([lam1, lam2, lam3])     # Array with all the common wavelengths\n</code></pre></p> <p>Then we sample the spectra to match the new common wavelength array <pre><code>sp1_new = sp1[uf.where_closer_array(lam_new, lam1)]\nsp2_new = sp2[uf.where_closer_array(lam_new, lam2)]\nsp3_new = sp3[uf.where_closer_array(lam_new, lam3)]\n</code></pre></p> <p>And we can now perform any operations on the spectra as they all have the same dimension and wavelengths.</p> <p>Example 2: list of OMEGA observations</p> <p>Let's assume we have 3 <code>OMEGAdata</code> objects <code>omega1</code>, <code>omega2</code>, <code>omega3</code>.</p> <p>We can find the common wavelengths with <pre><code>lam_new = od.shared_lam_omegalist([omega1, omega2, omega3])     # Array with all the common wavelengths\n</code></pre></p> <p>Then we search for the indexes that correspond to the wavelengths of the new array <pre><code>i_lam1 = uf.where_closer_array(lam_new, omega.lam1)\ni_lam2 = uf.where_closer_array(lam_new, omega.lam2)\ni_lam3 = uf.where_closer_array(lam_new, omega.lam3)\n</code></pre></p> <p>And we just need to sample the spectra to match the new common wavelength array when we get them from the data cube. <pre><code>sp1 = omega1.cube_rf[x1, y1, i_lam1]  # Loading the spectrum from pixel (x1, y1) of omega1, sampled on the new wavelength array\nsp2 = omega2.cube_rf[x2, y2, i_lam2]  # Loading the spectrum from pixel (x2, y2) of omega2, sampled on the new wavelength array\nsp3 = omega3.cube_rf[x3, y3, i_lam3]  # Loading the spectrum from pixel (x3, y3) of omega3, sampled on the new wavelength array\n</code></pre></p> <p>And we can now perform any operations on the spectra as they all have the same dimension and wavelengths.</p>"},{"location":"data_handling/#generating-masks","title":"Generating masks","text":"<p>For the scientific analysis of OMEGA data some pixels of the data cubes need to be removed because they correspond to internal calibration measurements, or are corrupted. Extensive description of filtering criteria that have been used for the analysis of OMEGA observations can be found in several published studies, e.g., Langevin et al. (2007)<sup>1</sup>, Poulet et al. (2007)<sup>2</sup>, Ody et al. (2012)<sup>3</sup>,  Vincendon et al. (2015)<sup>4</sup>, Stcherbinine et al. (2021)<sup>5</sup>.</p> <p>The <code>omega_mask</code> function generate masks associated to an OMEGA observation that can be used in all the display functions presented in Data visualization.</p>"},{"location":"data_handling/#default","title":"Default","text":"<p>By default, the function will generate a mask that takes into account all the calibration lines as described in the SOFT10_README.txt (see below),  but it can be refined to exclude some pixels depending on their associated observation geometry or detector behavior using optional arguments of the function.</p> Calibration lines \u2013 Note from the SOFT10_README.txt <p>The last 4 scans (16 pixels), 2 scans (32 pixels) or 1 scan (64, 128 pixels) of <code>idat</code> and <code>jdat</code> have only IR data (spectels 0 to 255).</p> <p>There is calibration data at the beginning of each cube for the visible channel, at the beginning of the ORBNNNN_0.QUB cubes for the IR channels The number of calibration scans depend on the pixel length (16 to 128) and the summation (1, 2 or 4 for 128 pixel modes):</p> <ul> <li> <p>for every cube, the first scan (128 pixels x 4), 3 scans (128 x 2)  7 scans (128 x 1), 14 scans (64 pixels),  28 scans (32 pixels), 56 scans (16 pixels) of the visible channel (spectels 256 and above) correspond to an internal calibration</p> </li> <li> <p>for cubes with names NNNN_0 (first cube in a sequence), the first 6 scans (128 x 4), 12 scans (128 x 2), 24 scans (128 x 1) 48 scans (64 pixels), 96 scans (32 pixels) or 192 scans (16 pixels) of the IR channel (spectels 0 to 255) correspond to an internal  calibration (closed shutter, lamp on at 6 different levels,  in order 0,4,3,2,1,0).</p> </li> </ul>"},{"location":"data_handling/#customizing-masks","title":"Customizing masks","text":""},{"location":"data_handling/#viewing-geometry","title":"Viewing geometry","text":"<p>The viewing geometry can affect the spectra measured by OMEGA (e.g., Pommerol &amp; Schmitt, 2008<sup>6</sup>), so studies focussing on the surface used to restrain themselves to pixels acquired in near-nadir mode.</p> <p>Thus, if set, the <code>emer_lim</code> keyword will remove all the pixels with an emergence angle larger than the value passed as an argument. And similarly, the <code>inci_lim</code> keyword will remove all the pixels with an incidence angle larger than the given value.</p>"},{"location":"data_handling/#detector-temperature","title":"Detector temperature","text":"<p>The OMEGA IR detectors (C &amp; L channels) have been designed and calibrated to operate at  temperatures below 80 K, above this value the dark current level and the noise will increase. However, a certain amount of time is needed to cool them down to this temperature before an acquisition, so it happened that the detectors were not at their nominal temperature during the entire acquisition of a data cube, especially as the performance of the cryocoolers started to decline around MY 30.</p> <p>If the <code>tempc_lim</code> is set, all pixels acquired with the C-channel detector at a temperature higher than the provided one (in \u00b0C) will be removed.</p>"},{"location":"data_handling/#near-saturation-of-pixels","title":"Near-saturation of pixels","text":"<p>Near-saturation of some pixels can occur when observing a surface element brighter than expected (e.g., sun-lighted tilted surface). Vincendon et al., (2015)<sup>4</sup> introduce a criterion to avoid non-linearity effects when approaching the saturation based on the value measured by the spectel #40 (i.e., \u03bb = 1.486\u03bcm), by excluding pixels with a value higher than a defined threshold.</p> <p>If the <code>limsat_c</code> keyword is set, pixels measured with a value higher than the given one (in DN) will be removed.</p>"},{"location":"data_handling/#hiding-corrupted-columns-in-128-px-wide-orbservations","title":"Hiding corrupted columns in 128-px wide orbservations","text":"<p>As described in  Corrupted 128-px wide cubes, an instrumental issue perturbs 128 pixels wide observations from orbit 513 to 3283. The easiest way to handle it is to ignore the corrupted columns.</p> <p>This is done if the <code>hide_128</code> option is activated.</p>"},{"location":"data_handling/#low-quality-observations","title":"Low quality observations","text":"<p>In some cases, one may want to completely ignore some OMEGA cubes as they are considered as \"low quality observations\".</p> <p>It can be done by checking some parameters of the observation to ignore the unwanted ones after the data importation, but as an example  <code>omega_mask</code> has its own pre-implemented low-quality test.</p> <p>If the <code>reject_low_quality</code> keyword is set to <code>True</code>, such observations will be hided by having a mask entirely filled with <code>NaN</code>.</p> <p>Pre-implemented low quality criterion</p> <p>Is condidered as \"low quality\" by the  <code>omega_mask</code> function  (according to Stcherbinine et al. (2021)<sup>5</sup>) any OMEGA cube that meet one of the conditions below.</p> Test Description <code>omega.data_quality == 0</code> Low quality cube <code>omega.quality == 0</code> <code>(numCube == 0) and (npixel == 64) and (omega.bits_per_data == 1)</code> <code>not omega.orbit in good_orbits_OBC</code> Orbit not in the \"good orbits\" file (relative to on-board calibration (OBC)) <code>omega.target != 'MARS'</code> Mars pointing only <code>omega.mode_channel != 1</code> All 3 channels required <code>omega.point_mode == 'N/A'</code> Unknown pointing informations <p>Example of the masks used in Stcherbinine et al. (2021)<sup>5</sup></p> <pre><code>mask = od.omega_mask(\n    omega, \n    emer_lim=10,                # Emergence angles &lt; 10\u00b0\n    inci_lim=70,                # Incendence angles &lt; 70\u00b0\n    tempc_lim=-194,              # Detector temperature &lt; -194\u00b0C\n    limsat_c=500,               # Spectel #40 &lt; 500 DN\n    hide_128=True,              # Remove corrupted columns\n    reject_low_quality=True     # Ignore low-quality observations\n    )\n</code></pre> <p>In addition to this instrumental criteria, spectral criteria to filter clouds and surface ice were added to generate the masks.</p> <p>Adding spectral criterion to the masks \u2013 Illustration with surface ice</p> <p>Assuming that you have loaded an OMEGA observation <code>omega</code> and computed the  associated band depth at 1.5\u03bcm <code>bd15</code> and default mask <code>mask</code>, you can add the filtering of all the pixels with a BD &gt; 0.1 (spectral criterion used to remove the surface ice in Stcherbinine et al. (2021)<sup>5</sup>) with: <pre><code>mask[bd15 &gt; 0.1] = np.nan\n</code></pre></p>"},{"location":"data_handling/#corrupted-128-px-wide-cubes","title":"Corrupted 128-px wide cubes","text":"<p>From orbit 513, observations acquired in the 128-px wide mode present a disruption of some columns (Ody et al., 2012<sup>3</sup>; Vincendon et al. 2015<sup>4</sup>):</p> <ul> <li> <p>From orbit 513 to 2123, the columns #81 to #96 (i.e., 12.5% of the image) exhibit 44 corrupted wavelength, distributed across the entire spectral range according to a regular pattern (4 contiguous spectels every 32 spectels, from spectel 12 or 28 depending on the observation, every other row of the image ; cf panels a &amp; b). For these observations, it is possible to partially reconstruct the cube by using spatial and spectral interpolation, which can be done using the  <code>corr_mode_128</code> function.</p> </li> <li> <p>From orbit 2124 to 3283 (no more 128-px wide acquisitions after) the corrupted wavelengths already present remained, but combined with a random noise that affected all columns between #61 and #128 (i.e., half of the image ;\u00a0cf panels c &amp; d). This second effect, random and affecting all rows and wavelengths cannot be corrected, so the corrupted columns have to be removed.</p> </li> </ul> <p> </p>      Illustration of the perturbation that affect cubes acquired in a 128-px wide mode from     orbit 513 to 2123 (a &amp; b) and from orbit 2124 to 3283 (c &amp; d)     (figure 4.10 from Stcherbinine 2021)[^7]."},{"location":"data_handling/#observation-search","title":"Observation search","text":""},{"location":"data_handling/#find_cube","title":"<code>find_cube</code>","text":"<p>The <code>find_cube</code> function allows you to search for all the observations that include a specific location on Mars (over the first few thousands orbits). Plus, if you have the corresponding .NAV files, it will display geometry informations for the pixel of the cube which is the closest to the target coordinates (see figure below).</p> <p> </p>      Example use of the find_cube function to search for available observations of the      Phoenix landing site region (234\u00b0E / 68\u00b0N) between orbits 923 and 1223.    <p>Nadir-only filtering</p> <p>It is possible to filter the results so the search only returns the OMEGA cubes acquired with a nadir viewing geometry with the <code>nadir_only</code> argument:</p> <ul> <li><code>nadir_only = True</code> \u2192 Only returns cubes acquired with nadir geometry.</li> <li><code>nadir_only = False</code> (default) \u2192 Returns all matching OMEGA cubes.</li> </ul>"},{"location":"data_handling/#jmars","title":"JMARS","text":"<p>Alternatively, as OMEGA data are included in JMARS  it is possible to use this tool to perform a request to search for OMEGA observations as a function of time, location...</p> <p>Then, if you export the search results as a .csv file, you can use the  <code>import_list_obs_csv</code> function to load it and extract the cube ID into an array that can be passed as an argument to the OMEGA-Py functions.</p> <p>JMARS</p> <p>JMARS is an acronym that stands for Java Mission-planning and Analysis for Remote Sensing. It is a geospatial information system (GIS) developed by ASU's Mars Space Flight Facility to provide mission planning and data-analysis tools to NASA scientists, instrument team members, students of all ages and the general public.</p> <ol> <li> <p>Y. Langevin, J.-P. Bibring, F. Montmessin, F. Forget, et al. (2007). Observations of the south seasonal cap of Mars during recession in 2004\u20132006 by the OMEGA visible/near-infrared imaging spectrometer on board Mars Express.  JGR Planets 112 (E8). doi:10.1029/2006JE002841 \u21a9</p> </li> <li> <p>F. Poulet, C. Gomez, J.-P. Bibring, Y. Langevin, et al. (2007). Martian surface mineralogy from Observatoire pour la Min\u00e9ralogie, l'Eau, les Glaces et l'Activit\u00e9 on board the Mars Express spacecraft (OMEGA/MEx): Global mineral maps.  JGR Planets 112 (E8).  doi:10.1029/2006JE002840 \u21a9</p> </li> <li> <p>A. Ody, F. Poulet, Y. Langevin, J.-P. Bibring, et al. (2012).  Global maps of anhydrous minerals at the surface of Mars from OMEGA/MEx. JGR Planets 117 (E11).  doi:10.1029/2012JE004117 \u21a9\u21a9</p> </li> <li> <p>M. Vincendon, J. Audouard, F. Altieri, A. Ody, (2015).  Mars Express measurements of surface albedo changes over 2004\u20132010.  Icarus 251, 145\u2013163.  doi:10.1016/j.icarus.2014.10.029 \u21a9\u21a9\u21a9</p> </li> <li> <p>A. Stcherbinine, M. Vincendon, F. Montmessin, P. Beck (2021).  Identification of a new spectral signature at 3 \u00b5m over Martian northern high latitudes: implications for surface composition.  Icarus, 369, 114627.  doi:10.1016/j.icarus.2021.114627 \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>A. Pommerol &amp; B. Schmitt (2008).  Strength of the H<sub>2</sub>O near-infrared absorption bands in hydrated minerals:  Effects of measurement geometry.  JGR Planets 113 (E12). doi:10.1029/2008JE003197 \u21a9</p> </li> <li> <p>A. Stcherbinine (2021). PhD thesis, Universit\u00e9 Paris-Saclay. NNT:2021UPASP064 \u21a9</p> </li> </ol>"},{"location":"data_importation/","title":"Data importation","text":""},{"location":"data_importation/#reading-the-binaries","title":"Reading the binaries","text":"<p>Similarly to the <code>readomega.pro</code> IDL routine of the SOFT 10, OMEGA-Py read the level 1B binary .QUB &amp; .NAV files that can be downloaded from the ESA  PSA to generate level 2A data with reflectance spectra. </p> <p>Attention</p> <p>OMEGA-Py assumes filenames with uppercase letters and not lowercase, so pay attention if you download the data from the PDS instead of the PSA. </p> <p>Unlike the IDL software, the module has been implemented with Object Oriented Programming (OOP), which makes easier the simultaneous handling of different OMEGA observations. The loading of an OMEGA observation is done by calling the <code>__init__</code> method of the <code>OMEGAdata</code> class.</p> <p>Example</p> <p><code>omega = OMEGAdata(\"0967_3\")</code> to load the cube 0967_3. </p> <p>OMEGA files stored in subdirectories</p> <p>OMEGA-Py can handle storage of the OMEGA binary files (.QUB &amp; .NAV) in subdirectories, similarly to how it is stored on the PSA,  with also potentially data and geometry files in separate folders. When calling <code>omega = OMEGAdata(\"0967_3\")</code> for instance, a recursive search is performed from the parent directory defined by <code>omega_bin_path</code>, independantly for the .QUB and .NAV files.</p> <p>The user can then access all the data (reflectance, geometry, wavelengths\u2026) from the attributes of the newly created omega object. </p> <p>Automatically cleaned spectra</p> <p>The wavelengths are also automatically reordered in ascending order and the spectra are \"cleaned\" to remove the overlaps between the three channels of the instrument (V, C, L) along with the corrupted spectels as identified in the ic array of readomega.</p> <p>Cube ID</p> <p>As shown in the figure below, OMEGA-Py will search for any matching observation in the data present on the machine when calling  <code>OMEGAdata</code>. If the exact ID of the OMEGA cube ('XXXX_N') is not provided and there is an ambiguity, it will show you the possible products and ask you to choose the one you want by entering the corresponding number (see figure below).</p> <p> </p>      Verbose importation of cube ORB0967_3."},{"location":"data_importation/#non-verbose-importation","title":"Non-verbose importation","text":"<p>By default, OMEGA-Py will display some informations in the console while reading the binary files, as the original IDL <code>readomega.pro</code> routine (see above figure). However, this may be unwanted in some cases, especially when dealing with a large number of observations if you want to use some king of progress bar  (like tqdm) for instance.</p> <p>Thus, we included a way to disable this display: simply set the <code>disp</code> parameter to <code>False</code> when loading the OMEGA observation (see figure below).</p> <p>Example</p> <p><code>omega = OMEGAdata(\"0967_3\", disp=False)</code> to load the cube 0967_3 without displaying any information in the console.</p> <p> </p>      Non-verbose importation of cube ORB0967_3."},{"location":"data_importation/#ignoring-some-channels","title":"Ignoring some channels","text":"<p>Compared to the C channel (0.93\u20132.73 \u03bcm), the V (0.35\u20131.05 \u03bcm) and L (2.55\u20135.1 \u03bcm) channels require additional specific corrections to generate the L1B data from the binaries. We are talking here about seconds or less, but when dealing with large datasets of hundreds to thousands of observations it may become a noticeable amount of time.</p> <p>Thus, it is possible to skip these correction steps the <code>corrV</code> and/or <code>corrL</code> parameters to <code>False</code> when loading the OMEGA observation:</p> <pre><code># Loading cube 0967_3 with all channels corrections\nomega      = OMEGAdata('0967_3')\n# No V channel correction\nomega_noV  = OMEGAdata('0967_3', corrV=False)\n# No L channel correction\nomega_noL  = OMEGAdata('0967_3', corrL=False)\n# No V &amp; L channels corrections\nomega_noVL = OMEGAdata('0967_3', corrV=False, corrL=False)\n</code></pre> <p>Danger</p> <p>Always be careful when using this feature, especially if you save the data after the importation. The data from the V &amp; L channels will still be present in the <code>OMEGAdata</code> object anyway, but they should not be used as they did not go over the entire instrumental correction process.</p> <p>Checking the correction status of the channels</p> <p>It is possible to check the status of the corrections of the V &amp; L channels of an <code>OMEGAdata</code> object via the values of the booleans: <pre><code>omega.corrV     # True if V-channel correction applied\n\nomega.corrL     # True if L-channel correction applied\n</code></pre></p>"},{"location":"data_importation/#accessing-the-file-headers","title":"Accessing the file headers","text":"<p>Even though many informations from the .QUB and .NAV files headers are accessible as attributes of the <code>OMEGAdata</code> class, it is also possible to get the full headers as dictionaries with the  <code>get_header_qub</code> and <code>get_header_nav</code> methods:</p> <pre><code>header_qub = omega.get_header_qub() # Header of the .QUB file (dict)\n\nheader_nav = omega.get_header_nav() # Header of the .NAV file (dict)\n</code></pre>"},{"location":"data_importation/#cube-quality","title":"Cube quality","text":"<p>A <code>data_quality</code> attribute is provided as part of the <code>OMEGAdata</code> class. It incidates possible problems within the data cube. A data cube is transmitted as sets of 64 spectra (\"slices\"). There are 500 to 1500 slices in a typical data cube. Each slice is transmitted as 6 TM packets. A typical cube corresponds to 3000 to 9000 TM packets.</p> <p>The values of this index are the following:</p> Quality Description 5 perfect 4 one data gap (gap of 40 TM packets or more) 3 missing data (up to 9 TM packets are missing or corrupted) 2 acceptable (&lt; 3 gaps, &lt; 10 isolated missing packets) 1 poor (3 to 5 gaps or 10 to 100 isolated missing packets) 0 bad (&gt; 5 gaps or &gt; 100 missing/corrupted packets)"},{"location":"data_importation/#data-representation","title":"Data representation","text":"<p>The representation of an <code>OMEGAdata</code> object in the console provides several informations about the OMEGA observation (see figure below):</p> <ul> <li>The cube ID (orbit and cube number).</li> <li>The major version of OMEGA-Py used to generate the object from the binaries.</li> <li>The Solar longitude (L<sub>s</sub>).</li> <li>The Martian Year (MY).</li> <li>The cube quality.</li> <li>Status of the thermal &amp; atmospheric corrections.</li> <li>If applicable, additional informations contained in the <code>omega.add_infos</code> attribute.</li> </ul> <p> </p>      Representation of an OMEGAdata object."},{"location":"data_visualization/","title":"Data visualization","text":"<p>OMEGA-Py comes with a series of visualization functions specifically developed. All of them are packed in <code>omegapy.omega_plots</code>, the user can choose to project the data on a lat/lon grid or a polar view, or display the image without projection.</p> <p>In the following, we assume that we have already loaded the module and a corrected OMEGA observation as follows: <pre><code>import omegapy.omega_data as od\nimport omegapy.omega_plots as op\n\nomega = od.autoload_omega('0979_3', therm_corr=True, atm_corr=True)\n</code></pre></p>"},{"location":"data_visualization/#unprojected-data","title":"Unprojected data","text":"<p>The first way to display OMEGA data is to show one slice of the cube using matplotlib.pyplot.imshow. The figure axes are here the X, Y\u00a0axes of the data cube, in pixels,  without considering the geometry.</p> <p>This is done by calling the show_omega function, which requires an <code>OMEGAdata</code> object and a given wavelength (in \u03bcm).</p> <pre><code>op.show_omega(omega, lam=1.085)\n</code></pre> <p> </p>      ORB0979_3 reflectance \u2013 Non-projected"},{"location":"data_visualization/#data-projection","title":"Data projection","text":"<p>The other way to display an OMEGA observation is to use the geometry information for each pixel to project the image on a longitude/latitude grid. Here we use the coordinates of the corners of the OMEGA pixels to plot the image with matplotlib.pyplot.pcolormesh.</p> <p>The advantage of this visualization is that it gives a direct access to the geographic coordinates of the observed features, and it render the actual shape of the OMEGA pixels, instead of assuming that they are all squares with the same size.</p> <p>This is done by all the <code>*_v2</code> functions of <code>omega_plots</code>.</p>"},{"location":"data_visualization/#equatorial-projection","title":"Equatorial projection","text":"<p>The display of an OMEGA observation on a regular equatorial longitude/latitude grid can be obtain by using the <code>show_omega_v2</code> function. Similarly to <code>show_omega</code>, all it needs is an <code>OMEGAdata</code> object and a wavelength (in \u03bcm).</p> <p>Info</p> <p>Several other parameters to customize the plot are available, see the API documentation of the function.</p> <pre><code>op.show_omega_v2(omega, lam=1.085)\n</code></pre> <p> </p>      ORB0979_3 reflectance \u2013 Equatorial projection    <p>Longitude range</p> <p>Two options are possible to display the longitudes and can be selected with the <code>negatives_longitudes</code> argument (valid for all functions that use equatorial projection, including composite maps):</p> <ul> <li><code>negatives_longitudes = False</code> \u2192 Longitudes between 0\u00b0E and 360\u00b0E</li> <li><code>negatives_longitudes = True</code> \u2192 Longitudes between -180\u00b0E and 180\u00b0E</li> </ul> <p>By default, it will pick the one that seems the most adapted to the min/max longitudes of the observation. Especially in order to avoid splitting it on both edges of the figure.</p>"},{"location":"data_visualization/#polar-projection","title":"Polar projection","text":"<p>For observations that are located at high latitudes, close to the poles, it may be preferred to use a polar projection for the axes instead of an equatorial projection. This can be done simply by adding <code>polar=True</code> in the call of the function.</p> <pre><code>op.show_omega_v2(omega, lam=1.085, polar=True)\n</code></pre> <p> </p>      ORB0979_3 reflectance \u2013 Polar projection    <p>Selecting the pole</p> <p>By default, the function will automatically select the hemisphere and latitude range to have the best rendering of the observation. But the hemisphere can also be selected manually but setting the latitude bounds of the figure with the <code>latlim</code> argument:</p> <ul> <li><code>latlim = (90, 0)</code> for the entire North hemisphere</li> <li><code>latlim = (-90, 0)</code> for the entire South hemisphere</li> </ul>"},{"location":"data_visualization/#v-channel-geometry","title":"V-channel geometry","text":"<p>The field of view of the V-channel is not perfectly co-aligned with the C &amp; L-channels, so the geometry information (longitude, latitude, etc) is slightly different depending on the selected wavelength. The default behaviour of OMEGA-Py is to use the C/L-channels geometry, but all the data for the V-channel are available as well (e.g., <code>lat_v</code>, <code>lon_v</code>, ...).</p> <p>So, if you are displaying data from the V-channel (i.e., \u03bb &lt; 1 \u03bcm), it is possible to use the appropriate geometry information by setting the <code>use_V_geom</code> parameter to <code>True</code> (this option is available in all the display functions that use projection, i.e., all the <code>*_v2</code> functions).</p> C-channel reflectance with C-channel geometryV-channel reflectance with C-channel geometryV-channel reflectance with V-channel geometry <pre><code>op.show_omega_v2(omega, lam=2.26, mask=data_mask)\n</code></pre> <p></p> <pre><code>op.show_omega_v2(omega, lam=0.80, mask=data_mask)\n</code></pre> <p></p> <pre><code>op.show_omega_v2(omega, lam=0.80, mask=data_mask, use_V_geom=True)\n</code></pre> <p></p>"},{"location":"data_visualization/#applying-masks","title":"Applying masks","text":"<p>Let's assume you have generated a mask associated with your OMEGA observation, stored in the <code>data_mask</code> array, and you want to hide the flagged pixels while displaying the data.</p> <pre><code>data_mask = od.omega_mask(\n    omega, \n    hide_128=True, \n    emer_lim=10, \n    inci_lim=70, \n    tempc_lim=-194, \n    limsat_c=500\n    )\n</code></pre> <p>This is simply done by passing the <code>data_mask</code> array to the <code>mask</code> parameter of the <code>show_omega_v2</code> function:</p> <pre><code>op.show_omega_v2(omega, lam=1.085, polar=False, mask=data_mask)\n</code></pre> <p> </p>      ORB0979_3 reflectance \u2013 Equatorial projection with mask    <p>Same example with polar viewing: <pre><code>op.show_omega_v2(omega, lam=1.085, polar=True, mask=data_mask)\n</code></pre></p> <p> </p>      ORB0979_3 reflectance \u2013 Polar projection with mask"},{"location":"data_visualization/#reflectance-vs-previously-computed-data","title":"Reflectance vs previously computed data","text":"<p>It is possible to replace the reflectance by any data array derived from the OMEGA observation (assuming the X,Y dimensions remains identical), to show for instance the spatial variations of a spectral criterion  (e.g., example 1 \u2013 Band depth).</p> <p>This is done by using the <code>show_data_v2</code> function, which is very similar to <code>show_omega_v2</code> except that instead of requiring a wavelength (<code>lam</code>) it uses an array of floats that will replace the reflectance values (<code>data</code>).</p> <p>Colorbar</p> <p>Unlike the case of the reflectance, here the function cannot know by itself the nature of the data that you are plotting. Thus, you need to define the title of the colorbar with the <code>cb_title</code> argument (otherwise it will be set to <code>'data'</code> by default).</p> <p>It is also possible to deactivate the display of the colorbar with <code>cbar=False</code>, which may be useful when plotting multiple maps on the same figure (i.e., see example 2 \u2013 Overplotting).</p> <p>Here we assume that we have computed the 3\u03bcm IBD defined in Jouglet et al. (2007)<sup>1</sup> (also referred as \"Wide 3\u03bcm BD\" in Stcherbinine et al. (2021)<sup>2</sup>) for the cube ORB0979_3, and stored it in the array <code>ibd30</code>.</p> <pre><code>op.show_data_v2(omega, data=ibd30, cb_title=\"3\u03bcm wide BD\", mask=data_mask, polar=False)\n</code></pre> <p> </p>      ORB0979_3 3\u03bcm IBD \u2013 Equatorial projection with mask    <p>Same example with polar viewing: <pre><code>op.show_data_v2(omega, data=ibd30, cb_title=\"3\u03bcm wide BD\", mask=data_mask, polar=True)\n</code></pre></p> <p> </p>      ORB0979_3 3\u03bcm IBD \u2013 Polar projection with mask"},{"location":"data_visualization/#interactive-visualization","title":"Interactive visualization","text":"<p>One of the very useful features for the exploration of OMEGA data is the interactive display, similar to what can be done with ENVI for IDL users. By clicking with the mouse on the OMEGA image (reflectance or derived map), the user can explore and extract the spectra from every pixel of the map.</p> <p>Plus, by holding the Ctrl key while clicking on the map, it is possible to select multiple spectra.</p> <p>Important note for the interactive visualization</p> <p>Using the interactive function requires to have the figure displayed in an external window. So if you are using Jupyter or an IDE like Spyder, make sure to configure matplotlib for that.</p> <p>For instance, assuming you've already installed a Qt binding, e.g., with: <pre><code>pip install pyqt5\n</code></pre> you can activate it with <pre><code>%matplotlib qt\n</code></pre> (put this line at the beginning of your Jupyter notebook, or in your IDE console)</p> Additional point if using a Google Colab notebook <p>It seems that Google Colab notebooks are blocking non inline backends diplay, so you cannot enable the Qt backend as described above. One workaround is to install and use the <code>ipympl</code> backend with:</p> <p>Install <code>ipympl</code> <pre><code>pip install ipympl\n</code></pre></p> <p>And allow third-party Jupyter widgets as described here by putting these lines at the beginning of your notebook (instead of <code>%matplotlib qt</code>): <pre><code># Allow for third-party Jupyter widgets\nfrom google.colab import output\noutput.enable_custom_widget_manager()\n\n# Activate the ipympl interactive backend\n%matplotlib ipympl\n</code></pre></p> <p>This is done by calling the <code>show_omega_interactif_v2</code> function, which requires an <code>OMEGAdata</code> object and either a wavelength (<code>lam</code>, in \u03bcm) or a data array to display (<code>data</code>):</p> <p>Info</p> <p>If <code>data</code> is provided,  <code>show_data_v2</code> will be used to display the map, otherwise it will be <code>show_omega_v2</code>. So other customization arguments of these functions can be used here.</p> <pre><code>op.show_omega_interactif_v2(\n    omega,\n    lam = 2.26,\n    mask = data_mask,\n    vmin = 0,\n    vmax = 0.5,\n    data = None,    # Can be used to replace the reflectance by an other pre-computed map\n    )\n</code></pre> <p> </p>      Interactive display of cube ORB0979_3  Equatorial projection of surface reflectance at     2.26 \u03bcm with mask.    <p>Unprojected interactive visualization</p> <p>It is also possible to use a similar interactive display of an OMEGA data cube without any equatorial or polar projection, only using the (X, Y) axes of the cube with the show_omega_interactif function. In this case it uses show_omega instead of show_omega_v2 to display the OMEGA map.</p>"},{"location":"data_visualization/#composite-maps","title":"Composite maps","text":"<p>OMEGA-Py provides functions to generate composite maps from multiple OMEGA observations, with either the reflectance or previously processed high-level maps (such as band depth). For instance, the maps in figures 3 to 5 of Stcherbinine et al. (2021)<sup>2</sup> have been generated using OMEGA-Py functions.</p> <p>For the following examples, let's assume we have loaded these 3 OMEGA observations: <pre><code>omega41  = od.autoload_omega('0041_1', therm_corr=True, atm_corr=True)\nomega61  = od.autoload_omega('0061_1', therm_corr=True, atm_corr=True)\nomega103 = od.autoload_omega('0103_1', therm_corr=True, atm_corr=True)\n</code></pre></p> <p>Computing and displaying a composite map is done by using the  <code>show_omega_list_v2</code> function.</p> <p>Defining the grid</p> <p>Generating composite maps requires to project all the OMEGA observations on the same longitude/latide grid, defined by the following parameters in the call of the function:</p> Parameter Decription <code>lon_min</code> Minimum longitude in degrees E (comprised between 0 and 360) <code>lon_max</code> Maximum longitude in degrees E (comprised between 0 and 360) <code>pas_lon</code> Resolution of the longidude grid in degrees (i.e., size of the pixels along the longitude axis) <code>lat_min</code> Minimum latitude in degrees N (comprised between -90 and 90) <code>lat_max</code> Maximum latitude in degrees N (comprised between -90 and 90) <code>pas_lat</code> Resolution of the latidude grid in degrees (i.e., size of the pixels along the latitude axis) <p>Extracting the projected map</p> <p>The newly created arrays containing the composite map, and the associated longitude/latitude grids can be retrieved as an output of the <code>show_omega_list_v2</code> function by adding <code>out = True</code> in the call.</p> <p>Alternatively, they can also be saved in a specific file then loaded when you want, as described in Saving &amp; Loading composite maps.</p>"},{"location":"data_visualization/#reflectance","title":"Reflectance","text":"<p>To generate a composite reflectance map, all we need to provide is:</p> <ul> <li>The list of OMEGA observations previously loaded as OMEGAdata    objects.</li> <li>The grid parameters.</li> <li>The desired wavelength in \u03bcm (<code>lam</code>).</li> </ul> <p>Then additional optional parameters can be used to customize the displayed map  (polar viewing, colormap, colorscale, title...).</p> <pre><code>op.show_omega_list_v2(\n    # OMEGA observations\n    [omega41, omega61, omega103],\n    # Grid parameters\n    lat_min=-90, lat_max=-75,\n    lon_min=0, lon_max=360,\n    pas_lon=0.1, pas_lat=0.1,\n    # Polar viewing\n    polar=True,\n    # Colorscale min/max\n    vmin=0, vmax=0.6,\n    # Reflectance wavelength\n    lam=1.085,\n    # Colormap\n    cmap='Greys_r',\n    )\n</code></pre> <p> </p>      ORB0041_1/ORB0061_1/ORB0103_1  Reflectance \u2013 Polar projection"},{"location":"data_visualization/#data-masks","title":"Data &amp; Masks","text":"<p>Let's assume we have now also computed the corresponding masks (<code>mask_41</code>, <code>mask_61</code>, <code>mask_103</code>) and 1.5\u03bcm BD maps (<code>bd15_41</code>, <code>bd15_61</code>, <code>bd15_103</code>).</p> <p>Similarly to how it works for the <code>show_omega_v2</code> function, adding masks to hide some specific pixels of the OMEGA observations can be done simply by passing these masks as a list to the <code>mask_list</code> parameter. If using masks, then it is required that masks for all the observations present in <code>omega_list</code> are given, in the same order.</p> <p>Replacing the reflectance by pre-computed data maps for all OMEGA observations can be done by passing them to the <code>data_list</code> argument of the function  (instead of specifying the <code>lam</code> argument).</p> <p>Important</p> <p>The data in <code>mask_list</code> and <code>data_list</code> (if used) must be in the same order as <code>omega_list</code>. Otherwise, if the dimensions of the content of all lists do not match, a <code>ValueError</code> will be raised.</p> <pre><code>import cmocean.cm as cmo    # Some more very nice colormaps\n\nop.show_omega_list_v2(\n    # OMEGA observations\n    [omega41, omega61, omega103],\n    # Grid parameters\n    lat_min=-90, lat_max=-75,\n    lon_min=0, lon_max=360,\n    pas_lon=0.1, pas_lat=0.1,\n    # Polar viewing\n    polar=True,\n    # Colorscale min/max\n    vmin=0, vmax=0.4,\n    # Colormap\n    cmap=cmo.ice,\n    # Data\n    data_list = [bd15_41, bd15_61, bd15_103],\n    # Masks\n    mask_list = [mask_41, mask_61, mask_103],\n    # Colorbar title\n    cb_title = r'1.5 \u03bcm BD',\n    )\n</code></pre> <p> </p>      ORB0041_1/ORB0061_1/ORB0103_1  1.5\u03bcm BD \u2013 Polar projection with mask"},{"location":"data_visualization/#projection-methods","title":"Projection methods","text":"<p>Since version 2.4, two projections methods are available to generate composite maps of OMEGA observations.</p> <p>They can be selected by specifying <code>proj_method=1</code> or <code>proj_method=2</code> in the call of the <code>show_omega_list_v2</code> function (current default is method 1).</p>"},{"location":"data_visualization/#method-1","title":"Method 1","text":"<p>The fastest way to generate composite maps. It will only consider the coordinates of the center of every pixels of an observation to fill the new grid.</p> <p>It works well for a grid with a coarser resolution compared to the size of the actual OMEGA pixels, but for high-resolution maps (typically with pixels smaller than 1\u00b0x1\u00b0) it may results in gaps in the newly created map.</p> <p>Nicer maps with method 1</p> <p>There is still a way to improve the rendering of high-resolution maps generated with the method 1, as shown in Illustration: it is possible to hide the small lines of <code>NaN</code> pixels within the map by adding contours on the edges of the plot.</p> <p>This is done by setting the <code>edgecolor</code> parameter to <code>'face'</code>, and controlling the with with <code>lw</code>. Default behaviour of the function is: <code>edgecolor='face'</code> and <code>lw=0.1</code>.</p>"},{"location":"data_visualization/#method-2","title":"Method 2","text":"<p>The second method allows to generate high-resolution composite maps.</p> <p>Here the algorithm is going to search for every pixels of the grid that are within the OMEGA pixels footprints polygons. It fixes the issue of the gaps within the composite map that can be observed with the method 1 for high-resolution grid, but takes much more time to process.</p> <p>Tip</p> <p>If the generation of composite maps can take a few seconds to minutes with the method 1, it can easily be hours with method 2 for a large number of observations.</p> <p>Thus, we suggest to use method 1 to preview the maps and make some test, then only use method 2 for the final processing, and save them directly (see Saving &amp; Loading composite maps) to only have to process them once.</p> <p>Displaying maps generated with method 2</p> <p>For maps computed with method 2, it no longer needed to add the edges to hide the data gaps, so the <code>edgecolor</code> parameter can be set to <code>'none'</code>.</p>"},{"location":"data_visualization/#illustration","title":"Illustration","text":"Method 1 with <code>edgecolor = 'face'</code> (default)Method 1 with <code>edgecolor = 'none'</code>Method 2 with <code>edgecolor = 'none'</code> Source code <pre><code>op.show_omega_list_v2(\n    # OMEGA observations\n    [omega41, omega61, omega103],\n    # Grid parameters\n    lat_min=-90, lat_max=-75,\n    lon_min=0, lon_max=360,\n    pas_lon=0.1, pas_lat=0.1,\n    # Polar viewing\n    polar=True,\n    # Colorscale min/max\n    vmin=0, vmax=0.4,\n    # Colormap\n    cmap=cmo.ice,\n    # Data\n    data_list = [bd15_41, bd15_61, bd15_103],\n    # Masks\n    mask_list = [mask_41, mask_61, mask_103],\n    # Colorbar title\n    cb_title = r'1.5 \u03bcm BD',\n    # Projection method &amp; display\n    proj_method = 1,\n    edgecolor = 'face',\n    lw = 0.1,\n    )\n</code></pre> Source code <pre><code>op.show_omega_list_v2(\n    # OMEGA observations\n    [omega41, omega61, omega103],\n    # Grid parameters\n    lat_min=-90, lat_max=-75,\n    lon_min=0, lon_max=360,\n    pas_lon=0.1, pas_lat=0.1,\n    # Polar viewing\n    polar=True,\n    # Colorscale min/max\n    vmin=0, vmax=0.4,\n    # Colormap\n    cmap=cmo.ice,\n    # Data\n    data_list = [bd15_41, bd15_61, bd15_103],\n    # Masks\n    mask_list = [mask_41, mask_61, mask_103],\n    # Colorbar title\n    cb_title = r'1.5 \u03bcm BD',\n    # Projection method &amp; display\n    proj_method = 1,\n    edgecolor = None,\n    )\n</code></pre> Source code <pre><code>op.show_omega_list_v2(\n    # OMEGA observations\n    [omega41, omega61, omega103],\n    # Grid parameters\n    lat_min=-90, lat_max=-75,\n    lon_min=0, lon_max=360,\n    pas_lon=0.1, pas_lat=0.1,\n    # Polar viewing\n    polar=True,\n    # Colorscale min/max\n    vmin=0, vmax=0.4,\n    # Colormap\n    cmap=cmo.ice,\n    # Data\n    data_list = [bd15_41, bd15_61, bd15_103],\n    # Masks\n    mask_list = [mask_41, mask_61, mask_103],\n    # Colorbar title\n    cb_title = r'1.5 \u03bcm BD',\n    # Projection method &amp; display\n    proj_method = 2,\n    edgecolor = None,\n    )\n</code></pre>"},{"location":"data_visualization/#saving-loading-composite-maps","title":"Saving &amp; Loading composite maps","text":"<p>To avoid reprocessing every time the projection of the OMEGA observations to generate the composite maps, which may take time, especially for large datasets and/or if you are using the method 2, it is possible to export them in a single file after the processing. Then, all you have to do is to load this file and display the map as you want.</p>"},{"location":"data_visualization/#saving-composite-map","title":"Saving composite map","text":"<p>Computing and saving a composite map is done by using the  <code>save_map_omega_list</code> function. It is very similar to <code>show_omega_list_v2</code> except that you do not need to give the parameters related to the display of the map.</p> <p>Instead, you can define the path where the data will be saved, and the filename.</p> <p>Good practises</p> <p>If you are not using the reflectance, it is recommended to fill the <code>data_desc</code> argument with a description of the data (similarly to <code>cb_title</code>). This value will be used by default as the colorbar label when displaying the map, and it is a good way to know what data are stored within the file when you load it.</p> <p>Also, if you use the automatically generated filename, it is recommended to use the <code>ext</code> argument to indicate the data used to generate the map, and identify them.</p> <pre><code>op.save_map_omega_list(\n    # OMEGA observations\n    omega_list,\n    # Grid parameters\n    lat_min=50, lat_max=90,\n    lon_min=0, lon_max=360,\n    pas_lat=0.1, pas_lon=0.1,\n    # Data\n    data_list=bd_19_list,\n    data_desc='1.9 \u03bcm BD',\n    # Masks\n    mask_list=mask_ice_list,\n    # Output file parameters\n    ext='BD_1.9microns_mask4C',\n    sub_folder='mask4C',\n    folder='../data',\n    )\n</code></pre>"},{"location":"data_visualization/#loading-displaying-previously-saved-map","title":"Loading &amp; displaying previously saved map","text":"<p>Once you have saved a composite map in a file with  <code>save_map_omega_list</code>, you can load its content with <code>load_map_omega_list</code> and display the map with  <code>show_omega_list_v2_man</code>.</p> <p>The function takes as argument the arrays previously loaded, and parameters to customize the plot, similarly to <code>show_omega_v2</code> or <code>show_omega_list_v2</code> (colormap, colorscale, title, polar viewing...).</p> <p>Colorbar title</p> <p>By default, the colorbar title will used the one passed to <code>data_desc</code> when saving the map, but it can be changed using the <code>cb_title</code> argument.</p> <pre><code>data_bd19, mask, grid_lat, grid_lon, mask_obs, infos = op.load_map_omega_list(\n    '../data/mask4C/res_show_omega_list_v2__lat50-90_pas0.1_lon000-360_pas0.1_BD_1.9microns_mask4C.pkl'\n    )\n\nop.show_omega_list_v2_man(\n    data_bd19,\n    grid_lat,\n    grid_lon,\n    infos,\n    cmap = 'inferno',\n    vmin = 0.02,\n    vmax = 0.08,\n    title = '',\n    polar = True,\n    cb_title = 'auto',\n    )\n</code></pre> <p> </p>      North 1.9\u03bcm BD \u2013 Polar projection with water ice mask (Stcherbinine et al., 2021)    <ol> <li> <p>D. Jouglet, F. Poulet, R. E. Milliken, et al. (2007).  Hydration state of the Martian surface as seen by Mars Express OMEGA : 1. Analysis of the 3 \u03bcm hydration feature.  Journal of Geophysical Research: Planets, 112, E08S06.  doi:10.1029/2006JE002846 \u21a9</p> </li> <li> <p>A. Stcherbinine, M. Vincendon, F. Montmessin, P. Beck (2021).  Identification of a new spectral signature at 3 \u00b5m over Martian northern high latitudes: implications for surface composition.  Icarus, 369, 114627.  doi:10.1016/j.icarus.2021.114627 \u21a9\u21a9</p> </li> </ol>"},{"location":"example1_band_depth/","title":"Band depth","text":"<p>Here is an example on how to compute and display a band depth on an OMEGA observation using OMEGA-Py.</p> <p>Let's assume that you have downloaded the OMEGA data cube ORB0979_2 from the PSA (or from these links:\u00a0 QUB, NAV) and loaded the module and data as follows: <pre><code>import omegapy.omega_data as od\nimport omegapy.omega_plots as op\n</code></pre></p>"},{"location":"example1_band_depth/#step-1-loading-the-data","title":"Step 1 \u2013 Loading the data","text":"<p>Option 1: Load the binary files and apply the thermal and atmospheric corrections if needed. <pre><code># Load the data cube\nomega0 = od.OMEGAdata('0979_2')\n# Apply thermal and atmospheric corrections\nomega = od.corr_therm_atm(omega0, npool=15)     # Adjust npool according to your system\n</code></pre></p> <p>Option 2: Load directly a previously saved <code>OMEGAdata</code> object  (with or without the corrections already applied). <pre><code># Load directly the already corrected data cube\nomega = od.autoload_omega('0979_2', therm_corr=True, atm_corr=True)\n</code></pre></p>"},{"location":"example1_band_depth/#step-2-generating-the-data-mask-optional","title":"Step 2 \u2013 Generating the data mask (optional)","text":"<pre><code>mask = od.omega_mask(\n    omega, \n    hide_128=True, \n    emer_lim=10, \n    inci_lim=70, \n    tempc_lim=-194, \n    limsat_c=500\n    )\n</code></pre>"},{"location":"example1_band_depth/#step-3-computing-band-depth-at-15-m","title":"Step 3 \u2013 Computing band depth at 1.5 \u03bcm","text":"<p>Let's compute the water ice 1.5 \u03bcm band depth as defined in Poulet et al. (2007)<sup>1</sup>:</p> <pre><code>bd_15 = od.BD_omega(omega, [1.5, 1.51], 1.30, 1.71, norm=True)\n</code></pre> Source code for function <code>BD_omega(omega, lam0, lamc1, lamc2, norm=True)</code> <pre><code>import omegapy.useful_functions as uf\nimport numpy as np\n\ndef BD_omega(omega, lam0, lamc1, lamc2, norm=True):\n    \"\"\"Compute the band depth on an OMEGA observation cube.\n    Continuum linear between lamc1 and lamc2.\n\n    If an array is passed as argument for a wavelength value, the average is used.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation.\n    lam0 : float or array-like\n        The wavelength of the center of the band.\n    lamc1 : float or array-like\n        The wavelength of the bluer point for the continuum determination.\n    lamc2 : float or array-like\n        The wavelength of the redder point for the continuum determination.\n    norm :\u00a0bool, optional (default True)\n        | True -&gt; band_depth output is the normalized BD values.\n        | False -&gt; band_depth output is the BD values.\n\n    Returns\n    -------\n    band_depth : 2D array\n        The array of the band depth values for the observation \n        (normalized or not depending on norm).\n    rf_c : 2D array\n        The value of the continuum used to measure the band depth.\n    \"\"\"\n    if not omega.therm_corr:\n        print(\"\\033[01;33mWarning: No thermal correction applied.\\033[0m\")\n    # Initialisation\n    refl_cube = omega.cube_rf\n    nx, ny, nlam = refl_cube.shape\n    # Conversion floats -&gt; list\n    if isinstance(lam0, (int, float)):\n        lam0 = [lam0]\n    if isinstance(lamc1, (int, float)):\n        lamc1 = [lamc1]\n    if isinstance(lamc2, (int, float)):\n        lamc2 = [lamc2]\n    # Search for wavelength indexes\n    i_lam0 = uf.where_closer_array(lam0, omega.lam)\n    i_lamc1 = uf.where_closer_array(lamc1, omega.lam)\n    i_lamc2 = uf.where_closer_array(lamc2, omega.lam)\n    # Average wavelengths\n    lam0 = np.mean(omega.lam[i_lam0])\n    lamc1 = np.mean(omega.lam[i_lamc1])\n    lamc2 = np.mean(omega.lam[i_lamc2])\n    # Average reflectances\n    rf_band = np.mean(refl_cube[:, :, i_lam0], axis=2)\n    rf_c1 = np.mean(refl_cube[:, :, i_lamc1], axis=2)\n    rf_c2 = np.mean(refl_cube[:, :, i_lamc2], axis=2)\n    # Average continuum\n    rf_c = rf_c1 + (rf_c2 - rf_c1) * (lam0 - lamc1) / (lamc2 - lamc1)\n    # Compute BD over the OMEGA cube\n    if norm:\n        band_depth = (rf_c - rf_band) / rf_c\n    else:\n        band_depth = rf_c - rf_band\n    # Output\n    return band_depth\n</code></pre>"},{"location":"example1_band_depth/#step-4-displaying-the-band-depth-map","title":"Step 4 \u2013 Displaying the band depth map","text":"<p>Now that we have computed the band depth map, we can display it with the <code>show_data_v2</code> function, as described in the data visualization page.</p> <p>Tip</p> <p>Install and import the cmocean module to access some more nice colormaps:</p> <pre><code>import cmocean.cm as cmo\n</code></pre> 1.5\u03bcm Band DepthSurface reflectance <pre><code>op.show_data_v2(omega, data=bd_15, cb_title=\"1.5\u03bcm BD\", polar=True, cmap=cmo.ice, vmin=0, vmax=0.75)\n</code></pre> <p>      ORB0979_2 1.5\u03bcm BD \u2013 Polar projection  </p> <pre><code>op.show_omega_v2(omega, lam=1.085, polar=True, vmin=0, vmax=0.6)\n</code></pre> <p>      ORB0979_2 reflectance \u2013 Polar projection  </p> <ol> <li> <p>F. Poulet, C. Gomez, J.-P. Bibring, et al. (2007). Martian surface mineralogy from Observatoire pour la Min\u00e9ralogie, l'Eau, les Glaces et l'Activit\u00e9 on board the Mars Express spacecraft (OMEGA/MEx): Global mineral maps. JGR, 112, E08S02. doi:10.1029/2006JE002840 \u21a9</p> </li> </ol>"},{"location":"example2_overplot/","title":"Overplotting","text":"<p>Here is an example on how to overplot multiple map layers with the OMEGA-Py display functions. In this example will plot a 1.5\u03bcm band depth map over a reflectance background to highlight the areas  covered by water ice.</p> <p>In the following, we assume that we have already loaded the module and a corrected OMEGA observation as follows: <pre><code>import omegapy.omega_data as od\nimport omegapy.omega_plots as op\n</code></pre></p> <p>Also let's assume that you have completed step 1 to 3 of the band depth example to process the OMEGA data cube ORB0979_2 and compute its 1.5\u03bcm band depth map.</p> <p>Quick reminder</p> <pre><code>omega = od.autoload_omega('0972_2')\n\nbd_15 = od.BD_omega(omega, [1.5, 1.51], 1.30, 1.71, norm=True)\n</code></pre>"},{"location":"example2_overplot/#step-1-define-the-additional-layers","title":"Step 1 \u2013 Define the additional layers","text":"<p>Let's say that you want to show the pixels cover with water ice, that we will define as pixels with a 1.5\u03bcm BD &gt; 10%. We will create a mask to hide the pixels with no water ice / lower BD:</p> <pre><code>import numpy as np\n\nmask_bd15 = np.ones(bd_15.shape)    # Initialisation with array of 1\nmask_bd15[bd_15 &lt; 0.1] = np.nan     # NaN for the pixels with no ice that we want to hide\n</code></pre>"},{"location":"example2_overplot/#step-2-display-the-figure","title":"Step 2 \u2013 Display the figure","text":"<p>Important</p> <p>The important point here is to select the same figure for all the plots, which is handled by the <code>Nfig</code> argument.</p>"},{"location":"example2_overplot/#plot-the-background","title":"Plot the background","text":"<p>For the background map, we plot the reflectance at 1.085 \u03bcm with  <code>show_omega_v2</code>.</p> <p>We hide the colorbar with <code>cbar = False</code> here to only have the one associated with the BD map.</p> <pre><code>op.show_omega_v2(\n    omega,\n    lam = 1.085,\n    polar = True,\n    vmin = 0,\n    vmax = 0.5,\n    cbar = False,   # We don't want to display the colorbar for the reflectance background\n    Nfig = 1,       # int or str\n    )\n</code></pre>"},{"location":"example2_overplot/#plot-the-bd-layer","title":"Plot the BD layer","text":"<p>Then we plot the 1.5 \u03bcm BD with <code>show_data_v2</code> on the same figure, using the mask to hide the pixels of the BD map without water ice signature.</p> <pre><code>import cmocean.cm as cmo\n\nop.show_data_v2(\n    omega,\n    data = bd_15,\n    mask = mask_bd15,\n    polar = True,\n    cmap = cmo.ice,\n    cb_title = \"1.5 \u03bcm BD\",\n    vmin = 0,\n    vmax = 0.75,\n    Nfig = 1,       # int or str - same as for the background\n    )\n</code></pre> <p>Transparent overlays</p> <p>One can also use the <code>alpha</code> keyword of the <code>show_data_v2</code> function to set the transparency of the different overlays, in addition or instead of using a mask.</p> Overplot1.5\u03bcm Band DepthSurface reflectance <p>      ORB0979_2 1.5\u03bcm BD on reflectance \u2013 Polar projection  </p> <p>      ORB0979_2 1.5\u03bcm BD \u2013 Polar projection  </p> <p>      ORB0979_2 reflectance \u2013 Polar projection  </p>"},{"location":"installation/","title":"Installation &amp; Update","text":""},{"location":"installation/#method-1-from-pypi-recommended","title":"Method 1: from PyPI (recommended)","text":"<p>Installation: <code>pip3 install omegapy</code></p> <p>Update: <code>pip3 install omegapy --upgrade</code> </p>"},{"location":"installation/#method-2-from-the-github-repository-development-version","title":"Method 2: from the GitHub repository (development version)","text":"<p>Installation: Clone the repository and install with pip:</p> <pre><code>git clone https://github.com/AStcherbinine/omegapy.git\ncd omegapy\npip3 install .\n</code></pre> <p>Update: Go to the previously cloned repository, pull the last updates, and install them with pip: <pre><code>cd omegapy\ngit pull\npip3 install .\n</code></pre></p>"},{"location":"litterature/","title":"Litterature","text":""},{"location":"litterature/#omega-py-communications","title":"OMEGA-Py communications","text":"<p>A. Stcherbinine, Y. Langevin, J. Carter, et al. (2025).  The OMEGA-Py Python module: a complete and easy way to work with OMEGA/MEX observations. EPSC-DPS Joint Meeting 2025, Helsinki, 7\u201312 September 2025, abstract 1434, doi:10.5194/epsc-dps2025-1434 (poster): abstract &amp; poster</p> <p>A. Stcherbinine, Y. Langevin, J. Carter, M. Vincendon, Y. Leseigneur, O. Barraud (2024).  OMEGA-Py: Python Tools for OMEGA data. Journal of Open Source Software, 9(99), 6566.  doi:10.21105/joss.06566</p> <p>A. Stcherbinine, J. Carter, Y. Langevin, et al. (2024).  OMEGA-Py: a New All-in-One Python Solution for OMEGA/MEX Data.  10<sup>th</sup> International Conference on Mars, Pasadena, 22\u201325 July 2024, abstract 3048 (poster): abstract &amp; poster</p> <p>A. Stcherbinine, J. Carter, Y. Langevin, et al. (2023).  OMEGA-Py: Python Tools for OMEGA Data \u2013 v2.3.  6<sup>th</sup> Planetary Data Workshop, Flagstaff, 26\u201328 June 2023, abstract 7007 (talk): abstract &amp; slides</p>"},{"location":"litterature/#articles-using-omega-py","title":"Articles using OMEGA-Py","text":"<p>F. Brasil, P. Machado, G. Gilli, et al. (2025). Atmospheric Gravity Waves in Mars' Lower Atmosphere: Nadir Observations From OMEGA/Mars Express Data. JGR: Planets, 130, e2024JE008726. doi:10.1029/2024JE008726</p> <p>Y. Leseigneur &amp; M. Vincendon (2023).  OMEGA/Mars Express: A new martian atmospheric dust hunter. Icarus, 392, 115366.  doi:10.1016/j.icarus.2022.115366</p> <p>A. Stcherbinine, M. Vincendon, F. Montmessin, P. Beck (2021).  Identification of a new spectral signature at 3 \u00b5m over Martian northern high latitudes: implications for surface composition.  Icarus, 369, 114627.  doi:10.1016/j.icarus.2021.114627</p>"},{"location":"litterature/#omega-ressources","title":"OMEGA ressources","text":"<p>SOFT10_README.txt</p> <p>OMEGA EAICD</p> <p>J.-P. Bibring, A. Soufflot, M. Berth\u00e9, et al. (2004).  OMEGA : Observatoire pour la Min\u00e9ralogie, l'Eau, les Glaces et l'Activit\u00e9. ESA Publication Division, 1240, 37. pdf</p>"},{"location":"tests/","title":"Tests","text":""},{"location":"tests/#check-if-the-module-has-been-installed","title":"Check if the module has been installed","text":"<p>After installing the module with <code>pip</code> (as described here), you can check that the module has been actually installed in your environment by opening a Python terminal and trying to import the module:</p> <pre><code>import omegapy\nimport omegapy.omega_data as od\nimport omegapy.omega_plots as op\nimport omegapy.useful_functions as uf\n</code></pre> <p>If these commands do not raise any error, the OMEGA-Py module is installed in your Python environment.</p> <p>Failure</p> <p>If the module is not available, here are a few things that you can try:</p> <ul> <li>Restart your terminal or application to reload the environment.</li> <li>Check that you are in the expected Python environment.</li> <li>Re-install the module:    <pre><code> pip3 install omegapy\n</code></pre></li> </ul> <p>If it is still not working, does it work if you try to install an other module? Search for how to install a Python module with your local setup.</p>"},{"location":"tests/#check-the-module-version","title":"Check the module version","text":"<p>You can also check that you have the latest version of the module installed:</p> <p></p> <p>From a Python console <pre><code>omegapy.__version__\n</code></pre></p> <p>From a terminal with pip <pre><code>pip freeze | grep omegapy\n</code></pre></p> <p>Failure</p> <p>If you don't have the last version, update it with <pre><code>pip3 install omegapy --upgrade\n</code></pre></p>"},{"location":"tests/#check-the-paths-configuration","title":"Check the paths configuration","text":"<p>Please refer to this page for how to configure the default paths for the OMEGA binary and the  omegapy-made files.</p> <p>You can check the values stored in them by displaying the output of <code>od.get_omega_bin_path()</code> (OMEGA .QUB &amp; .NAV binary files) and <code>od.get_omega_py_path()</code> (omegapy-made files).</p> <p>Failure</p> <p>If these functions do not return the expected path, please refer to this paragraph and use the  <code>od.set_omega_bin_path()</code> and <code>od.set_omega_py_path()</code> functions.</p>"},{"location":"tests/#test-to-process-and-display-an-omega-observation","title":"Test to process and display an OMEGA observation","text":"<p>The final test would be to actually download and process an OMEGA observation.</p> <p>For instance, download the data from cube 2 of orbit 0979:</p> <ul> <li>ORB0979_2.QUB</li> <li>ORB0979_2.NAV</li> </ul> <p>Then download the <code>example_test_script.py</code> Python file and run it to load, process, and display this OMEGA observation.</p> Source code for <code>example_test_script.py</code> example_test_script.py<pre><code>#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n## example_test_script.py\n## Created by Aur\u00e9lien STCHERBININE\n## Last modified by Aur\u00e9lien STCHERBININE : 29/05/2024\n\n##----------------------------------------------------------------------------------------\n\"\"\"Example test for OMEGA-Py: import, apply corrections, compute band depth and display\nfigures for OMEGA observation 0979_2.\n\"\"\"\n##----------------------------------------------------------------------------------------\n##----------------------------------------------------------------------------------------\n## Package importation\nimport omegapy.omega_data as od\nimport omegapy.omega_plots as op\nimport omegapy.useful_functions as uf\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.ion()   # Activation of Matplotlib interactive mode\n\n##----------------------------------------------------------------------------------------\n## Parameters to adjust\n# Number of simultaneous processes uses to perform the thermal correction\nnpool = 10\n\n# Colormap for reflectance maps\ncmap_refl = 'Greys_r'\n\n# Colormap for BD maps\ncmap_bd = 'Blues'\n\n########\n## Alternative with cmocean (if installed)\n# import cmocean.cm as cmo\n# cmap_bd = cmo.ice\n########\n\n## If needed, set the paths with the functions below\n## (see https://astcherbinine.github.io/omegapy/configuration/#windows-or-if-you-have-troubles-using-the-environment-variables)\n# od.set_omega_bin_path(\"/path/to/binary/files/folder/\")\n# od.set_omega_py_path(\"/path/to/omegapy-made/files/folder/\")\n##\n\n##----------------------------------------------------------------------------------------\n## Data importation &amp; correction\n# Load the data cube\nomega0 = od.OMEGAdata('0979_2')\n\n# Apply thermal and atmospheric corrections\nomega = od.corr_therm_atm(\n    omega0, \n    npool = npool,    # Adjust npool according to your system\n    )\n\n##----------------------------------------------------------------------------------------\n## OMEGA mask to hide bad pixels / calibration lines\nmask = od.omega_mask(\n    omega,\n    hide_128 = True,\n    emer_lim = 10,\n    inci_lim = 70,\n    tempc_lim = -194,\n    limsat_c = 500\n    )\n\n##----------------------------------------------------------------------------------------\n## Compute band depth at 1.5\u03bcm\nbd_15 = od.BD_omega(\n    omega, \n    [1.5, 1.51], \n    1.30, \n    1.71, \n    norm = True\n    )\n\n# Mask on band depth values for overplotting\nmask_bd15 = np.ones(bd_15.shape)    # Initialisation with array of 1\nmask_bd15[bd_15 &lt; 0.1] = np.nan     # NaN for the pixels with no ice that we want to hide\n\n##----------------------------------------------------------------------------------------\n## Display figures\n# Surface reflectance\nop.show_omega_v2(\n    omega, \n    lam = 1.085, \n    polar = True, \n    vmin = 0, \n    vmax = 0.6,\n    Nfig = \"reflectance\",\n    cmap = cmap_refl,\n    )\n\n# 1.5\u03bcm Band Depth\nop.show_data_v2(\n    omega, \n    data = bd_15, \n    cb_title = \"1.5\u03bcm BD\", \n    polar = True, \n    cmap = cmap_bd, \n    vmin = 0, \n    vmax = 0.75,\n    Nfig = \"BD15\",\n    )\n\n# Overplotting 1.5\u03bcm BD over surface reflectance\nop.show_omega_v2(\n    omega,\n    lam = 1.085,\n    polar = True,\n    vmin = 0,\n    vmax = 0.5,\n    cbar = False,\n    Nfig = \"overplot\",\n    cmap = cmap_refl,\n    )\n\nop.show_data_v2(\n    omega,\n    data = bd_15,\n    mask = mask_bd15,\n    polar = True,\n    cmap = cmap_bd,\n    cb_title = \"1.5 \u03bcm BD\",\n    vmin = 0,\n    vmax = 0.75,\n    Nfig = \"overplot\",\n    title = 'Overplot map for ORB0979_2',\n    )\n\nplt.figure('reflectance').savefig('omegapy_ORB0979_2_reflectance.png')\nplt.figure('BD15').savefig('omegapy_ORB0979_2_BD15.png')\nplt.figure('overplot').savefig('omegapy_ORB0979_2_overplot_reflectance_BD15.png')\n\n# Interactive display of the observation (@ \u03bb = 1.085 \u00b5m)\nop.show_omega_interactif_v2(\n    omega, \n    lam = 1.085, \n    cmap = cmap_refl, \n    vmin = 0, \n    vmax = 0.5, \n    polar = True,\n    mask = mask,\n    title = 'Interactive map',\n    autoyscale = False,\n    ylim_sp = (0, 0.6),\n    )\n\nplt.show()\n\n##----------------------------------------------------------------------------------------\n# Search for the index of \u03bb = 1.085 \u00b5m in the wavelength array\ni_lam = uf.where_closer(1.085, omega.lam)\n\n##----------------------------------------------------------------------------------------\n## Print completed\nprint(\"\\n\\033[32;1m[OMEGA-Py test example completed]\\033[0m\")\n\n##----------------------------------------------------------------------------------------\n## End of code\n##----------------------------------------------------------------------------------------\n</code></pre> <p>This example script will:</p> <ul> <li>load the binary files;</li> <li>apply the atmospheric and thermal corrections to the OMEGA observation;</li> <li>compute the 1.5\u03bcm band depth criteria (see the band depth example);</li> <li>display and save the reflectance, 1.5\u03bcm BD, and overplotted maps     (see the overplotting example);</li> <li>display the interactive visualization tool (if running the code in an IPython shell).</li> </ul> <p>You can then check that you have reproduced the figures shown in the examples.</p> <p>Notes</p> <p>If running the code directly from a bash terminal (with <code>python3 example_test_script.py</code>), the data will be processed, and the figures saved in your current directory. But you will not have access to the interactive visualization of the cube.</p> <p>To use the interactive aspect of OMEGA-Py, open an IPython terminal to run the code with <code>run example_test_script.py</code> (or execute it from your favorite IDE with a IPython console).</p> <p>Failure</p> <ul> <li>If encountering an error in the data loading/processing, check your installation with the above steps.</li> <li>If encountering an error with displaying the interactive map, check that you have an appropriate <code>matplotlib</code>   backend installed and activated (e.g., <code>PyQt5</code>) and   refer to this paragraph.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>omega_data</li> <li>omega_plots</li> <li>useful_functions</li> </ul>"},{"location":"reference/omega_data/","title":"omega_data","text":"<p>Importation and correction of OMEGA/MEx observations from binaries files.</p>"},{"location":"reference/omega_data/#omega_data.CubeError","title":"<code>omega_data.CubeError(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised if encounter an issue when reading the OMEGA/MEx cube binaries data.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def __init__(self, message):\n    self.message = message\n</code></pre>"},{"location":"reference/omega_data/#omega_data.OMEGAdata","title":"<code>omega_data.OMEGAdata(obs='', empty=False, data_path='_omega_bin_path', corrV=True, corrL=True, disp=True)</code>","text":"<p>Importation of OMEGA/MEx observation.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>str</code> <p>The name of the OMEGA observation.</p> <code>''</code> <code>empty</code> <code>bool</code> <p>If <code>True</code>, return an empty OMEGAdata object.</p> <code>False</code> <code>data_path</code> <code>str</code> <p>The path of the directory containing the data (.QUB) and  navigation (.NAV) files.</p> <code>_omega_bin_path</code> <code>corrV</code> <code>bool</code> <p>If <code>True</code>, compute the correction on the visible channel (Vis).</p> <code>True</code> <code>corrL</code> <code>bool</code> <p>If <code>True</code>, compute the correction on the long-IR channel (L).</p> <code>True</code> <code>disp</code> <code>bool</code> <p>Enable or disable the display of informations during the file reading. | <code>True</code> \u2192 Enable display.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The observation ID.</p> <code>lam</code> <code>1D array</code> <p>The wavelength array (in \u00b5m).</p> <code>cube_i</code> <code>3D array</code> <p>The hyperspectral data cube in physical units (W.m-2.sr-1.\u00b5m-1). <code>dim : [X, Y, wvl]</code></p> <code>cube_rf</code> <code>3D array</code> <p>The I/F ratio hyperspectral data cube. <code>dim : [X, Y, wvl]</code></p> <code>ls</code> <code>float</code> <p>The Solar longitude of the observation (deg).</p> <code>my</code> <code>int</code> <p>The Martian Year number at the time of the observation.</p> <code>loct</code> <code>2D array of floats</code> <p>The array of the local time for each pixel of the observation.</p> <code>lat</code> <code>2D array</code> <p>The latitude of each pixel (deg). C channel</p> <code>lon</code> <code>2D array</code> <p>The longitude of each pixel (deg). C channel</p> <code>alt</code> <code>2D array</code> <p>The elevation of the pixel footprint center point from MOMA topography (km). C channel</p> <code>dist</code> <code>2D array</code> <p>The slant distance from the spacecraft to the pixel footprint center point (km). C channel</p> <code>emer</code> <code>2D array</code> <p>The angle of emergent line (from the surface) (deg). W.r.t. the outward normal to the reference ellipsoid. C channel</p> <code>inci</code> <code>2D array</code> <p>The incidence angle at the surface (deg).  W.r.t. the outward normal to the reference ellipsoid. C channel</p> <code>emer_n</code> <code>2D array</code> <p>The angle of emergent line (from the surface) (deg). W.r.t. the local normal. C channel</p> <code>inci_n</code> <code>2D array</code> <p>The incidence angle at the surface (deg).  W.r.t. the local normal. C channel</p> <code>phase_n</code> <code>2D array</code> <p>The phase angle at the surface (deg). W.r.t. the local normal. C channel</p> <code>specmars</code> <code>1D array</code> <p>The Solar radiation spectrum on Mars (W.m-2.sr-1.\u00b5m-1).</p> <code>utc</code> <code>datetime</code> <p>The average UTC time of the observation.</p> <code>ic</code> <code>dict</code> <p>The index of the used spectral pixels for each channel.</p> <code>lat_grid</code> <code>2D array</code> <p>The latitude grid of the observation (from the edge of the pixels). C &amp; L channels</p> <code>lon_grid</code> <code>2D array</code> <p>The longitude grid of the observation (from the edge of the pixels). C &amp; L channels</p> <code>surf_temp</code> <code>2D array</code> <p>The retrieved surface temperature of each pixel (from the thermal correction).</p> <code>sensor_temp_c</code> <code>1D array</code> <p>The temperature of the sensor for each line of the (for the C-channel).</p> <code>sensor_temp_l</code> <code>1D array</code> <p>The temperature of the sensor for each line of the (for the L-channel).</p> <code>saturation_c</code> <code>2D array</code> <p>Information about the saturation of the C-channel.</p> <code>saturation_vis</code> <code>2D array</code> <p>Information about the saturation of the Vis-channel.</p> <code>ref_C</code> <code>2D array</code> <p>Average reflectance at \u03bb = 1.285/1.299/1.314 \u03bcm, to be compared with <code>ecl_n = cos(inci_n)</code> to check the geometry spatial calibration.</p> <code>lat_v</code> <code>2D array</code> <p>The latitude of each pixel (deg). V channel</p> <code>lon_v</code> <code>2D array</code> <p>The longitude of each pixel (deg). V channel</p> <code>alt_v</code> <code>2D array</code> <p>The elevation of the pixel footprint center point from MOMA topography (km). V channel</p> <code>dist_v</code> <code>2D array</code> <p>The slant distance from the spacecraft to the pixel footprint center point (km). V channel</p> <code>emer_n_v</code> <code>2D array</code> <p>The angle of emergent line (from the surface) (deg). W.r.t. the local normal. V channel</p> <code>inci_n_v</code> <code>2D array</code> <p>The incidence angle at the surface (deg).  W.r.t. the local normal. V channel</p> <code>phase_n_v</code> <code>2D array</code> <p>The phase angle at the surface (deg). W.r.t. the local normal. V channel</p> <code>lat_grid_v</code> <code>2D array</code> <p>The latitude grid of the observation (from the edge of the pixels). V channel</p> <code>lon_grid_v</code> <code>2D array</code> <p>The longitude grid of the observation (from the edge of the pixels). V channel</p> <code>lat_l</code> <code>2D array</code> <p>The latitude of each pixel (deg). L channel</p> <code>lon_l</code> <code>2D array</code> <p>The longitude of each pixel (deg). L channel</p> <code>alt_l</code> <code>2D array</code> <p>The elevation of the pixel footprint center point from MOMA topography (km). L channel</p> <code>dist_l</code> <code>2D array</code> <p>The slant distance from the spacecraft to the pixel footprint center point (km). L channel</p> <code>emer_n_l</code> <code>2D array</code> <p>The angle of emergent line (from the surface) (deg). W.r.t. the local normal. L channel</p> <code>inci_n_l</code> <code>2D array</code> <p>The incidence angle at the surface (deg).  W.r.t. the local normal. L channel</p> <code>phase_n_l</code> <code>2D array</code> <p>The phase angle at the surface (deg). W.r.t. the local normal. L channel</p> <code>lat_grid_l</code> <code>2D array</code> <p>The latitude grid of the observation (from the edge of the pixels). L channel</p> <code>lon_grid_l</code> <code>2D array</code> <p>The longitude grid of the observation (from the edge of the pixels). L channel</p> <code>summation</code> <code>int</code> <p>The downtrack summing.</p> <code>bits_per_data</code> <code>float</code> <p>The compression rate in bits per data.</p> <code>data_quality</code> <code>int</code> <p>Information about the data quality, from 0 to 5 depending on missing lines and compression errors. (See SOFT10_readme.txt or the online documentation for more details.)</p> <code>lrec</code> <code>int</code> <p>The number of bytes in each physical record in the data product file.</p> <code>nrec</code> <code>int</code> <p>The number of physical records that make up the PDS product label.</p> <code>sol_dist</code> <code>float</code> <p>The distance between the center of the observation and the Sun (km).</p> <code>sol_dist_au</code> <code>float</code> <p>The distance between the center of the observation and the Sun (a.u.).</p> <code>npixel</code> <code>int</code> <p>The number of pixels of the length of scan (can be 16, 32, 64, or 128 pixels).</p> <code>nscan</code> <code>int</code> <p>Number of scanned pixel lines.</p> <code>npara</code> <code>int</code> <p>Number of parameters describing the geometry of the observation.</p> <code>point_mode</code> <code>str</code> <p>The pointing mode of the instrument.</p> <code>target</code> <code>str</code> <p>The name of the target of the observation (<code>'MARS'</code>, <code>'PHOBOS'</code> or <code>'DEIMOS'</code>).</p> <code>mode_channel</code> <code>int</code> <p>Information about the presence of each channel.</p> <code>orient</code> <code>array</code> <p>The vector orientation of the spacecraft.</p> <code>subsol_lat</code> <code>float</code> <p>Latitude of the sub-solar point at observation time (deg).</p> <code>subsol_lon</code> <code>float</code> <p>Longitude of the sub-solar point at observation time (deg).</p> <code>min_lat</code> <code>float</code> <p>Southernmost latitude of the observation (deg).</p> <code>max_lat</code> <code>float</code> <p>Northernmost latitude of the observation (deg).</p> <code>min_lon</code> <code>float</code> <p>Easternmost longitude of the observation (deg).</p> <code>max_lon</code> <code>float</code> <p>Westernmost longitude of the observation (deg).</p> <code>slant</code> <code>float</code> <p>Distance from the spacecraft to the center of the observation along the line of sight (km).</p> <code>focal_plane_temperatures</code> <code>dict</code> <p>Temperatures of the C, L, V detectors (K).</p> <code>spectrometer_temperatures</code> <code>dict</code> <p>Temperatures of the C, L, V spectrometers (K).</p> <code>quality</code> <code>int</code> <p>The quality level of the cube. | <code>0</code>: corrupted | <code>1</code>: good | <code>128</code> : corrupted mode 128</p> <code>therm_corr</code> <code>bool</code> <p>| <code>True</code> \u2192 Thermal correction applied. | <code>False</code> \u2192 No thermal correction.</p> <code>therm_corr_infos</code> <code>dict</code> <p>Information about the thermal correction (date, method).</p> <code>atm_corr</code> <code>bool</code> <p>| <code>True</code> \u2192 Atmospheric correction applied. | <code>False</code> \u2192 No atmospheric correction.</p> <code>atm_corr_infos</code> <code>dict</code> <p>Information about the atmospheric correction (date, method).</p> <code>corrV</code> <code>bool</code> <p>Correction state of the visible channel (Vis).</p> <code>corrL</code> <code>bool</code> <p>Correction state of the long-IR channel (L).</p> <code>version</code> <code>int</code> <p>The major release version of the <code>omegapy.omega_data.py</code> file used.</p> <code>add_infos</code> <code>str</code> <p>Additional informations about the observation. Shown in the OMEGAdata representation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def __init__(self, obs='', empty=False, data_path=\"_omega_bin_path\", corrV=True, corrL=True, disp=True):\n    # Default paths\n    if data_path == \"_omega_bin_path\":\n        data_path = _omega_bin_path\n    # Infos\n    self.version = int(_Version)\n    self.therm_corr = False\n    self.atm_corr = False\n    self.therm_corr_infos = {'datetime': None, 'method': None}\n    self.atm_corr_infos = {'datetime': None, 'method': None}\n    self.quality = 1\n    self.add_infos = ''\n\n    if not empty:\n        obs_name = uf.myglob(os.path.join(data_path, '**', '*' + obs + '*.QUB'), recursive=True)\n        if obs_name is None:\n            print(\"\\033[1;33mAborted\\033[0m\")\n            empty = True\n\n    if empty:\n        # Data\n        self.name = ''\n        self.corrV = None\n        self.corrL = None\n        self.lam = np.array([])\n        self.cube_i = np.array([[[]]])\n        self.cube_rf = np.array([[[]]])\n        self.ls = np.nan\n        self.lat = np.array([[]])\n        self.lon = np.array([[]])\n        self.alt = np.array([[]])\n        self.dist = np.array([[]])\n        self.loct = np.array([[]])\n        self.emer = np.array([[]])\n        self.emer_n = np.array([[]])\n        self.inci = np.array([[]])\n        self.inci_n = np.array([[]])\n        self.phase_n = np.array([[]])\n        self.specmars = np.array([])\n        self.utc = datetime.datetime.now()\n        self.my = np.nan\n        self.orbit = None\n        self.surf_temp = np.array([[]])\n        self.ic = {'V' : np.arange(265, 333),\n                   'C' : np.arange(8, 123),\n                   'L' : np.arange(137, 256)}\n        self.lon_grid = np.array([[]])\n        self.lat_grid = np.array([[]])\n        self.sensor_temp_c = np.array([])\n        self.sensor_temp_l = np.array([])\n        self.saturation_c = np.array([[]])\n        self.saturation_vis = np.array([[]])\n        self.surf_temp = np.array([[]])\n        self.summation = None\n        self.bits_per_data = None\n        self.data_quality = None\n        self.mode_channel = None\n        self.lat_v = np.array([[]])\n        self.lon_v = np.array([[]])\n        self.alt_v = np.array([[]])\n        self.dist_v = np.array([[]])\n        self.emer_n_v = np.array([[]])\n        self.inci_n_v = np.array([[]])\n        self.phase_n_v = np.array([[]])\n        self.lon_grid_v = np.array([[]])\n        self.lat_grid_v = np.array([[]])\n        self.lat_l = np.array([[]])\n        self.lon_l = np.array([[]])\n        self.alt_l = np.array([[]])\n        self.dist_l = np.array([[]])\n        self.emer_n_l = np.array([[]])\n        self.inci_n_l = np.array([[]])\n        self.phase_n_l = np.array([[]])\n        self.lon_grid_l = np.array([[]])\n        self.lat_grid_l = np.array([[]])\n        self.focal_plane_temperatures = {'V' : None, 'C' : None, 'L' : None}\n        self.spectrometer_temperatures = {'V' : None, 'C' : None, 'L' : None}\n        # Nav\n        self.lrec = None\n        self.nrec = None\n        self.sol_dist = None\n        self.sol_dist_au = None\n        self.npixel = None\n        self.npara = None\n        self.nscan = None\n        self.point_mode = None\n        self.orient = np.array([])\n        self.subsol_lon = None\n        self.subsol_lat = None\n        self.min_lat = None\n        self.max_lat = None\n        self.min_lon = None\n        self.max_lon = None\n        self.slant = None\n        self.target = None\n        # Ajout pour correction position\n        self.ref_C = np.array([[]])\n\n    else:\n        nomfic0 = os.path.split(obs_name)[1][:-4]   # R\u00e9cup\u00e9ration nom + d\u00e9codage UTF-8\n        data_path_qub = os.path.split(obs_name)[0]  # R\u00e9cup\u00e9ration chemin dossier (utile si r\u00e9cursif)\n        nomgeo = obs_name[:-4] + '.NAV'\n        if os.path.exists(nomgeo):\n            data_path_nav = data_path_qub\n        else:\n            nomgeo = uf.myglob(os.path.join(data_path, '**', '*' + obs + '*.NAV'), recursive=True)\n            if nomgeo is None:\n                raise CubeError('No corresponding NAV cube {0:s}'.format(nomfic0 + '.NAV'))\n            else:\n                data_path_nav = os.path.split(nomgeo)[0]\n        data_dict, geom_dict = _readomega(nomfic0, disp=disp, corrV=corrV, corrL=corrL, \n                                          data_path_qub=data_path_qub, data_path_nav=data_path_nav)\n\n        if disp:\n            print(\"\\n\\033[01;34mComputing data extraction and correction...\\033[0m\", end=' ')\n        # Extract values\n        ldat = data_dict['ldat']\n        jdat = data_dict['jdat']\n        wvl = data_dict['wvl']\n        ic = data_dict['ic']\n        specmars = data_dict['specmars']\n        utc = geom_dict['ut_time']\n        temperature_c = geom_dict['temperature_c']\n        temperature_l = geom_dict['temperature_l']\n        saturation_c = geom_dict['saturation_c']\n        saturation_vis = geom_dict['saturation_vis']\n\n        lat = geom_dict['latitude']\n        lon = geom_dict['longitude']\n        alt = geom_dict['altitude']\n        dist = geom_dict['dist']            \n        emer = geom_dict['emergence']\n        emer_n = geom_dict['emergence_norm']\n        phase_n = geom_dict['phase_norm']\n        inci = geom_dict['incidence']\n        inci_n = geom_dict['incidence_norm']\n        lon_px = geom_dict['lon_grid']\n        lat_px = geom_dict['lat_grid']\n\n        lat_L = geom_dict['latitude_l']\n        lon_L = geom_dict['longitude_l']\n        alt_L = geom_dict['altitude_l']\n        dist_L = geom_dict['dist_l']\n        emer_n_L = geom_dict['emergence_norm_l']\n        phase_n_L = geom_dict['phase_norm_l']\n        inci_n_L = geom_dict['incidence_norm_l']\n        lon_px_L = geom_dict['lon_grid_l']\n        lat_px_L = geom_dict['lat_grid_l']\n\n        lat_V = geom_dict['latitude_v']\n        lon_V = geom_dict['longitude_v']\n        alt_V = geom_dict['altitude_v']\n        dist_V = geom_dict['dist_v']\n        emer_n_V = geom_dict['emergence_norm_v']\n        phase_n_V = geom_dict['phase_norm_v']\n        inci_n_V = geom_dict['incidence_norm_v']\n        lon_px_V = geom_dict['lon_grid_v']\n        lat_px_V = geom_dict['lat_grid_v']       \n\n        # Correction of OMEGA data (same as clean_spec.pro)\n        ic_C= ic[(ic &gt;= 8) &amp; (ic &lt;= 122)]        # IR short (voie C)\n        ic_L = ic[(ic &gt;= 137) &amp; (ic &lt;= 255)]     # IR long (voie L)\n        ic_V = ic[(ic &gt;= 265) &amp; (ic &lt;= 332)]     # visible\n        ic2 = np.concatenate([ic_V, ic_C, ic_L])\n        lam = wvl[ic2]\n        specmars = specmars[ic2]\n        # orbit_nb = int(nomfic0[3:-2])\n        orbnum = int.from_bytes(str.encode(nomfic0[3]), byteorder='big') - 48\n        if orbnum &gt; 9:\n            orbnum -= 7\n        orbit_nb = 1000 * orbnum + int(nomfic0[4:7])\n        # Cube in physical units (W.m-2.sr-1.\u00b5m-1)\n        cube_i = jdat[:, ic2, :]\n        # Cube of reflectance factor I/F\n        cube_rf = ldat[:, ic2, :]\n        # Cube as [X, Y, lam]\n        cube_i2 = np.swapaxes(cube_i, 1, 2)\n        cube_rf2 = np.swapaxes(cube_rf, 1, 2)\n        # Observation UTC date &amp; time\n        Y, M, D, h, m, s = np.median(utc[:,:6], axis=0).astype(np.int64)\n        utc_dt = datetime.datetime(Y, M, D, h, m, s)\n        # Longitude pixels grid\n        ny, nx = lon.shape\n        lon_grid = np.zeros((ny+1, nx+1))\n        lon_grid[1:,1:] = lon_px[:,:,0]\n        lon_grid[1:,0] = lon_px[:,0,1]\n        lon_grid[0,1:] = lon_px[0,:,3]\n        lon_grid[0,0] = lon_px[0,0,2]\n        lon_grid_L = np.zeros((ny+1, nx+1))\n        lon_grid_L[1:,1:] = lon_px_L[:,:,0]\n        lon_grid_L[1:,0] = lon_px_L[:,0,1]\n        lon_grid_L[0,1:] = lon_px_L[0,:,3]\n        lon_grid_L[0,0] = lon_px_L[0,0,2]\n        lon_grid_V = np.zeros((ny+1, nx+1))\n        lon_grid_V[1:,1:] = lon_px_V[:,:,0]\n        lon_grid_V[1:,0] = lon_px_V[:,0,1]\n        lon_grid_V[0,1:] = lon_px_V[0,:,3]\n        lon_grid_V[0,0] = lon_px_V[0,0,2]\n        # Latitude pixels grid\n        lat_grid = np.zeros((ny+1, nx+1))\n        lat_grid[1:,1:] = lat_px[:,:,0]\n        lat_grid[1:,0] = lat_px[:,0,1]\n        lat_grid[0,1:] = lat_px[0,:,3]\n        lat_grid[0,0] = lat_px[0,0,2]\n        lat_grid_L = np.zeros((ny+1, nx+1))\n        lat_grid_L[1:,1:] = lat_px_L[:,:,0]\n        lat_grid_L[1:,0] = lat_px_L[:,0,1]\n        lat_grid_L[0,1:] = lat_px_L[0,:,3]\n        lat_grid_L[0,0] = lat_px_L[0,0,2]\n        lat_grid_V = np.zeros((ny+1, nx+1))\n        lat_grid_V[1:,1:] = lat_px_V[:,:,0]\n        lat_grid_V[1:,0] = lat_px_V[:,0,1]\n        lat_grid_V[0,1:] = lat_px_V[0,:,3]\n        lat_grid_V[0,0] = lat_px_V[0,0,2]\n\n        # Storage as class arguments\n        self.lam = lam.astype(np.float64)\n        self.cube_i = cube_i2.astype(np.float64)\n        self.cube_rf = cube_rf2.astype(np.float64)\n        self.lat = lat.astype(np.float64)\n        self.lon = lon.astype(np.float64)\n        self.alt = alt.astype(np.float64)\n        self.dist = dist.astype(np.float64)\n        self.emer = emer.astype(np.float64)\n        self.emer_n = emer_n.astype(np.float64)\n        self.phase_n = phase_n.astype(np.float64)\n        self.inci = inci.astype(np.float64)\n        self.inci_n = inci_n.astype(np.float64)\n        self.specmars = specmars.astype(np.float64)\n        self.name = nomfic0\n        self.orbit = orbit_nb\n        self.utc = utc_dt\n        self.ic = {'V' : ic_V.astype(int), \n                   'C' : ic_C.astype(int), \n                   'L' : ic_L.astype(int)}\n        self.lat_grid = lat_grid\n        self.lon_grid = lon_grid\n        self.sensor_temp_c = temperature_c.astype(np.float64)\n        self.sensor_temp_l = temperature_l.astype(np.float64)\n        self.saturation_c = saturation_c.astype(np.float64)\n        self.saturation_vis = saturation_vis.astype(np.float64)\n\n        self.lat_l = lat_L.astype(np.float64)\n        self.lon_l = lon_L.astype(np.float64)\n        self.alt_l = alt_L.astype(np.float64)\n        self.dist_l = dist_L.astype(np.float64)\n        self.emer_n_l = emer_n_L.astype(np.float64)\n        self.inci_n_l = inci_n_L.astype(np.float64)\n        self.phase_n_l = phase_n_L.astype(np.float64)\n        self.lat_grid_l = lat_grid_L\n        self.lon_grid_l = lon_grid_L\n\n        self.lat_v = lat_V.astype(np.float64)\n        self.lon_v = lon_V.astype(np.float64)\n        self.alt_v = alt_V.astype(np.float64)\n        self.dist_v = dist_V.astype(np.float64)\n        self.emer_n_v = emer_n_V.astype(np.float64)\n        self.inci_n_v = inci_n_V.astype(np.float64)\n        self.phase_n_v = phase_n_V.astype(np.float64)\n        self.lat_grid_v = lat_grid_V\n        self.lon_grid_v = lon_grid_V\n        #--------------------------\n        # Data from the .QUB header\n        #--------------------------\n        hd_qub = _read_header(obs_name[:-4] + '.QUB')\n        self.summation = np.int64(hd_qub['DOWNTRACK_SUMMING'])\n        self.bits_per_data = np.float64(hd_qub['INST_CMPRS_RATE'])\n        self.data_quality = np.int64(hd_qub['DATA_QUALITY_ID'])\n        mode_channel_tmp = hd_qub['COMMAND_DESC'][34:36]\n        if mode_channel_tmp == 'EF':\n            self.mode_channel = 1\n        elif mode_channel_tmp == '80':\n            self.mode_channel = 2\n        elif mode_channel_tmp == 'C7':\n            self.mode_channel = 3\n        else:\n            self.mode_channel = mode_channel_tmp\n\n        T_fp_C, T_fp_L, T_fp_V = np.array(\n            hd_qub['MEX:FOCAL_PLANE_TEMPERATURE'][1:-5].split(','), dtype=np.float64)\n        self.focal_plane_temperatures = {'V' : T_fp_V, 'C' : T_fp_C, 'L' : T_fp_L}\n        T_sp_C, T_sp_L, T_sp_V = np.array(\n            hd_qub['MEX:SPECTROMETER_TEMPERATURE'][1:-5].split(','), dtype=np.float64)\n        self.spectrometer_temperatures = {'V' : T_sp_V, 'C' : T_sp_C, 'L' : T_sp_L}\n        #--------------------------\n        # Data from the .NAV header\n        #--------------------------\n        hd_nav = _read_header(nomgeo[:-4] + '.NAV')\n        npixel, npara, nscan = np.array(hd_nav['CORE_ITEMS'][1:-1].split(','), dtype=np.int64)\n        self.lrec = np.int64(hd_nav['RECORD_BYTES'])\n        self.nrec = np.int64(hd_nav['LABEL_RECORDS'])\n        self.sol_dist = np.float64(hd_nav['SOLAR_DISTANCE'])\n        self.sol_dist_au = np.float64(hd_nav['SOLAR_DISTANCE']) / 14960e4\n        npixel, npara, nscan = np.array(hd_nav['CORE_ITEMS'][1:-1].split(','), dtype=np.int64)\n        self.npixel = npixel\n        self.npara = npara\n        self.nscan = nscan\n        self.point_mode = hd_nav['SPACECRAFT_POINTING_MODE'][1:-1]\n        try:\n            self.orient = np.array(hd_nav['SPACECRAFT_ORIENTATION'][1:-1].split(','), dtype=np.int64)\n        except ValueError:\n            self.orient = hd_nav['SPACECRAFT_ORIENTATION'][1:-1]\n        self.ls = np.float64(hd_nav['SOLAR_LONGITUDE'])\n        self.subsol_lon = np.float64(hd_nav['SUB_SOLAR_LONGITUDE'])\n        self.subsol_lat = np.float64(hd_nav['SUB_SOLAR_LATITUDE'])\n        self.min_lat = np.float64(hd_nav['MINIMUM_LATITUDE'])\n        self.max_lat = np.float64(hd_nav['MAXIMUM_LATITUDE'])\n        self.min_lon = np.float64(hd_nav['WESTERNMOST_LONGITUDE'])\n        self.max_lon = np.float64(hd_nav['EASTERNMOST_LONGITUDE'])\n        self.slant = np.float64(hd_nav['SLANT_DISTANCE'])\n        self.target = hd_nav['TARGET_NAME']\n        #--------------------------\n        temp_init = np.zeros(self.lat.shape)\n        temp_init[:] = np.nan\n        self.surf_temp = temp_init\n        #--------------------------\n        # Local time &amp; MY\n        self.loct = _compute_local_time(self.lon, self.subsol_lon)\n        self.my = _utc_to_my(self.utc)\n        #--------------------------\n        # Cube quality\n        OBC = readsav(os.path.join(package_path, 'OMEGA_dataref', 'OBC_OMEGA_OCT2017.sav'))\n        good_orbits_OBC = np.array(OBC['good_orbits'][0], dtype=int)\n        corrupted_orbits_csv = pd.read_csv(os.path.join(package_path, 'OMEGA_dataref', 'corrupted_obs.csv'), comment='#',\n                                            skipinitialspace=True)\n        corrupted_orbits = np.array(corrupted_orbits_csv['corrupted_obs'], dtype=str)\n        corrupted_orbits_comments = np.array(corrupted_orbits_csv['comment'], dtype=str)\n        if (npixel==128) &amp; (orbit_nb &gt;= 513):\n            self.quality = 128\n            self.add_infos = 'Corrupted 128 pixels cube'\n        if orbit_nb not in good_orbits_OBC:\n            self.quality = 0\n            self.add_infos = 'Corrupted orbit'\n        if nomfic0 in corrupted_orbits:\n            self.quality = 0\n            i_obs = int(np.where(corrupted_orbits==nomfic0)[0])\n            self.add_infos = corrupted_orbits_comments[i_obs]\n        #--------------------------\n        # Ajout pour correction position\n        # self.ecl_n = np.cos(inci_n * np.pi / 180)\n        i25, i26, i27 = uf.where_closer_array([1.270, 1.285, 1.299], lam)\n        self.ref_C = np.mean(deepcopy(cube_rf2.astype(np.float32))[:, :, i25:i27+1], axis=2)\n        #--------------------------\n        # V &amp; L corrections status\n        self.corrV = corrV\n        self.corrL = corrL\n        start = ''\n        if self.add_infos != '':\n            start = '\\n        '\n        if (not corrV) and (not corrL):\n            self.add_infos += (start + 'No V &amp; L channels correction')\n        elif (not corrV) and corrL:\n            self.add_infos += (start + 'No V channel correction')\n        elif corrV and (not corrL):\n            self.add_infos += (start + 'No L channel correction')\n        #--------------------------\n        # End of data extraction &amp; correction\n        if disp:\n            print(\"\\033[01;32m[done]\\033[0m\")\n</code></pre>"},{"location":"reference/omega_data/#omega_data.OMEGAdata.get_header_nav","title":"<code>omega_data.OMEGAdata.get_header_nav(data_path='_omega_bin_path', recursive_search=True)</code>","text":"<p>Return the data from the header of the .NAV file, as a dictionary.</p> <p>See the OMEGA ECAID for informations about the header entries.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>str</code> <p>The path of the directory containing the navigation (.NAV) files.</p> <code>_omega_bin_path</code> <code>recursive_search</code> <code>bool</code> <p>If <code>True</code>, enable the search for the .QUB file in subdirectories from <code>data_path</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>hd_nav</code> <code>dict</code> <p>Dictionary containing the data from the ORBXXXX_X.NAV file.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_header_nav(self, data_path='_omega_bin_path', recursive_search=True):\n    \"\"\"Return the data from the header of the .NAV file, as a dictionary.\n\n    See the OMEGA ECAID for informations about the header entries.\n\n    Parameters\n    ----------\n    data_path : str, default _omega_bin_path\n        The path of the directory containing the navigation (.NAV) files.\n    recursive_search : bool, default True\n        If `True`, enable the search for the .QUB file in subdirectories\n        from `data_path`.\n\n    Returns\n    -------\n    hd_nav : dict\n        Dictionary containing the data from the ORBXXXX_X.NAV file.\n    \"\"\"\n    # Default path\n    if data_path == \"_omega_bin_path\":\n        data_path = _omega_bin_path\n    if recursive_search:\n        nav_path = uf.myglob(os.path.join(data_path, '**', self.name+'.NAV'), recursive=True)\n    else:\n        nav_path = os.path.join(data_path, self.name+'.NAV')\n    hd_nav = _read_header(nav_path)\n    return hd_nav\n</code></pre>"},{"location":"reference/omega_data/#omega_data.OMEGAdata.get_header_qub","title":"<code>omega_data.OMEGAdata.get_header_qub(data_path='_omega_bin_path', recursive_search=True)</code>","text":"<p>Return the data from the header of the .QUB file, as a dictionary.</p> <p>See the OMEGA ECAID for informations about the header entries.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>str</code> <p>The path of the directory containing the data (.QUB) files.</p> <code>_omega_bin_path</code> <code>recursive_search</code> <code>bool</code> <p>If <code>True</code>, enable the search for the .QUB file in subdirectories from <code>data_path</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>hd_qub</code> <code>dict</code> <p>Dictionary containing the data from the ORBXXXX_X.QUB file.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_header_qub(self, data_path='_omega_bin_path', recursive_search=True):\n    \"\"\"Return the data from the header of the .QUB file, as a dictionary.\n\n    See the OMEGA ECAID for informations about the header entries.\n\n    Parameters\n    ----------\n    data_path : str, default _omega_bin_path\n        The path of the directory containing the data (.QUB) files.\n    recursive_search : bool, default True\n        If `True`, enable the search for the .QUB file in subdirectories\n        from `data_path`.\n\n    Returns\n    -------\n    hd_qub : dict\n        Dictionary containing the data from the ORBXXXX_X.QUB file.\n    \"\"\"\n    # Default path\n    if data_path == \"_omega_bin_path\":\n        data_path = _omega_bin_path\n    if recursive_search:\n        qub_path = uf.myglob(os.path.join(data_path, '**', self.name+'.QUB'), recursive=True)\n    else:\n        qub_path = os.path.join(data_path, self.name+'.QUB')\n    hd_qub = _read_header(qub_path)\n    return hd_qub\n</code></pre>"},{"location":"reference/omega_data/#omega_data.BD_omega","title":"<code>omega_data.BD_omega(omega, lam0, lamc1, lamc2, norm=True)</code>","text":"<p>Compute the band depth on an OMEGA observation cube. Continuum linear between lamc1 and lamc2.</p> <p>If an array is passed as argument for a wavelength value, the average is used.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation.</p> required <code>lam0</code> <code>float or array - like</code> <p>The wavelength of the center of the band.</p> required <code>lamc1</code> <code>float or array - like</code> <p>The wavelength of the bluer point for the continuum determination.</p> required <code>lamc2</code> <code>float or array - like</code> <p>The wavelength of the redder point for the continuum determination.</p> required <code>norm</code> <code>bool</code> <p>| <code>True</code> \u2192 band_depth output is the normalized BD values. | <code>False</code> \u2192 band_depth output is the BD values.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>band_depth</code> <code>2D array</code> <p>The array of the band depth values for the observation (normalized or not depending on <code>norm</code>).</p> <code>rf_c</code> <code>2D array</code> <p>The value of the continuum used to measure the band depth.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def BD_omega(omega, lam0, lamc1, lamc2, norm=True):\n    \"\"\"Compute the band depth on an OMEGA observation cube.\n    Continuum linear between lamc1 and lamc2.\n\n    If an array is passed as argument for a wavelength value, the average is used.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation.\n    lam0 : float or array-like\n        The wavelength of the center of the band.\n    lamc1 : float or array-like\n        The wavelength of the bluer point for the continuum determination.\n    lamc2 : float or array-like\n        The wavelength of the redder point for the continuum determination.\n    norm : bool, default True\n        | `True` --&gt; band_depth output is the normalized BD values.&lt;/br&gt;\n        | `False` --&gt; band_depth output is the BD values.\n\n    Returns\n    -------\n    band_depth : 2D array\n        The array of the band depth values for the observation\n        (normalized or not depending on `norm`).\n    rf_c : 2D array\n        The value of the continuum used to measure the band depth.\n    \"\"\"\n    if not omega.therm_corr:\n        print(\"\\033[01;33mWarning: No thermal correction applied.\\033[0m\")\n    # Initialisation\n    refl_cube = omega.cube_rf\n    nx, ny, nlam = refl_cube.shape\n    # Conversion floats -&gt; list\n    if isinstance(lam0, (int, float)):\n        lam0 = [lam0]\n    if isinstance(lamc1, (int, float)):\n        lamc1 = [lamc1]\n    if isinstance(lamc2, (int, float)):\n        lamc2 = [lamc2]\n    # Search for wavelength indexes\n    i_lam0 = uf.where_closer_array(lam0, omega.lam)\n    i_lamc1 = uf.where_closer_array(lamc1, omega.lam)\n    i_lamc2 = uf.where_closer_array(lamc2, omega.lam)\n    # Average wavelengths\n    lam0 = np.mean(omega.lam[i_lam0])\n    lamc1 = np.mean(omega.lam[i_lamc1])\n    lamc2 = np.mean(omega.lam[i_lamc2])\n    # Average reflectances\n    rf_band = np.mean(refl_cube[:, :, i_lam0], axis=2)\n    rf_c1 = np.mean(refl_cube[:, :, i_lamc1], axis=2)\n    rf_c2 = np.mean(refl_cube[:, :, i_lamc2], axis=2)\n    # Average continuum\n    rf_c = rf_c1 + (rf_c2 - rf_c1) * (lam0 - lamc1) / (lamc2 - lamc1)\n    # Compute BD over the OMEGA cube\n    if norm:\n        band_depth = (rf_c - rf_band) / rf_c\n    else:\n        band_depth = rf_c - rf_band\n    # Output\n    return band_depth\n</code></pre>"},{"location":"reference/omega_data/#omega_data.autoload_omega","title":"<code>omega_data.autoload_omega(obs_name, folder='auto', version=_Version, base_folder='_omega_py_path', therm_corr=None, atm_corr=None, disp=True, bin_folder='_omega_bin_path', recursive=False)</code>","text":"<p>Load and return a previously saved <code>OMEGAdata</code> object using pickle (with <code>autosave_omega()</code>).</p> <p>Parameters:</p> Name Type Description Default <code>obs_name</code> <code>str</code> <p>The observation ID.</p> required <code>folder</code> <code>str</code> <p>The subfolder where the data is. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>version</code> <code>float</code> <p>The version of the target file (if folder is <code>'auto'</code>).</p> <code>_Version</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>therm_corr</code> <code>bool or None</code> <p>| <code>True</code> \u2192 Only results with thermal correction. | <code>False</code> \u2192 Only results without thermal correction. | <code>None</code> \u2192 Both with and without thermal correction.</p> <code>None</code> <code>atm_corr</code> <code>bool or None</code> <p>| <code>True</code> \u2192 Only results with atmospheric correction. | <code>False</code> \u2192 Only results without atmospheric correction. | <code>None</code> \u2192 Both with and without atmospheric correction.</p> <code>None</code> <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the loading filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> <code>bin_folder</code> <code>str</code> <p>The path of the directory containing the data (.QUB) and  navigation (.NAV) files.</p> <code>_omega_bin_path</code> <code>recursive</code> <code>bool</code> <p>Option passed to the <code>uf.myglob</code> function. If recursive is True, the pattern <code>**</code> will match any files and zero or more directories and subdirectories. Note: The recursive search option is not compatible with the default automatic paths, as they do not include the <code>**</code> pattern. One should add it where needed (e.g., in the <code>folder</code> argument).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>omega</code> <code>OMEGAdata</code> <p>The loaded object of OMEGA/MEx observation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def autoload_omega(obs_name, folder='auto', version=_Version, base_folder='_omega_py_path',\n                   therm_corr=None, atm_corr=None, disp=True, bin_folder='_omega_bin_path',\n                   recursive=False):\n    \"\"\"Load and return a previously saved `OMEGAdata` object using pickle (with `autosave_omega()`).\n\n    Parameters\n    ----------\n    obs_name : str\n        The observation ID.\n    folder : str, default 'auto'\n        The subfolder where the data is.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    version : float, default _Version\n        The version of the target file (if folder is `'auto'`).\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    therm_corr : bool or None, default None\n        | `True` --&gt; Only results with thermal correction.&lt;/br&gt;\n        | `False` --&gt; Only results without thermal correction.&lt;/br&gt;\n        | `None` --&gt; Both with and without thermal correction.\n    atm_corr : bool or None, default None\n        | `True` --&gt; Only results with atmospheric correction.&lt;/br&gt;\n        | `False` --&gt; Only results without atmospheric correction.&lt;/br&gt;\n        | `None` --&gt; Both with and without atmospheric correction.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the loading filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n    bin_folder : str, default _omega_bin_path\n        The path of the directory containing the data (.QUB) and \n        navigation (.NAV) files.\n    recursive : bool, default False\n        Option passed to the `uf.myglob` function.&lt;/br&gt;\n        If recursive is True, the pattern `**` will match any files and\n        zero or more directories and subdirectories.&lt;/br&gt;\n        Note: The recursive search option is not compatible with the default\n        automatic paths, as they do not include the `**` pattern.\n        One should add it where needed (e.g., in the `folder` argument).\n\n    Returns\n    -------\n    omega : OMEGAdata \n        The loaded object of OMEGA/MEx observation.\n    \"\"\"\n    # Default paths\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    if bin_folder == \"_omega_bin_path\":\n        bin_folder = _omega_bin_path\n    # Initialisation\n    ext = ''\n    excl = []\n    if therm_corr:\n        ext += '_therm'\n    elif therm_corr == False:\n        excl.append('therm')\n    if atm_corr:\n        ext += '_atm'\n    elif atm_corr == False:\n        excl.append('atm')\n    filename = '*{name}*{corr_ext}*.pkl'.format(name=obs_name, corr_ext=ext)\n    if folder == 'auto':\n        Mversion = int(version)\n        folder = 'v' + str(Mversion)\n    filename2 = uf.myglob(os.path.join(base_folder, folder, filename), exclude=excl, recursive=recursive)\n    if filename2 is None:\n        if (therm_corr in [None, False]) and (atm_corr in [None, False]):\n            obs_name_bin = glob.glob(os.path.join(bin_folder, '**', '*' + obs_name + '*.QUB'), recursive=True)\n            if len(obs_name_bin) == 0 :\n                return None\n            else:\n                print('\\033[1mMatching binary files:\\033[0m')\n                return OMEGAdata(obs_name, data_path=bin_folder)\n        else:\n            return None\n    else:\n        with open(filename2, 'rb') as input_file:\n            omega = pickle.load(input_file)\n            if disp:\n                print('\\033[03m' + filename2 + '\\033[0;01;34m loaded\\033[0m')\n            return omega\n</code></pre>"},{"location":"reference/omega_data/#omega_data.autosave_omega","title":"<code>omega_data.autosave_omega(omega, folder='auto', base_folder='_omega_py_path', security=True, disp=True)</code>","text":"<p>Save an <code>OMEGAdata</code> object at the selected path using the pickle module, with automatic configuration of the target name.</p> <p><code>Final_path = base_folder + folder + name{_corr_therm_atm}.pkl</code></p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation object.</p> required <code>folder</code> <code>str</code> <p>The subfolder to save the data. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Didn't care about the already existing files.</p> <code>True</code> <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the saving filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def autosave_omega(omega, folder='auto', base_folder='_omega_py_path', security=True, disp=True):\n    \"\"\"Save an `OMEGAdata` object at the selected path using the pickle module, with automatic\n    configuration of the target name.\n\n    *`Final_path = base_folder + folder + name{_corr_therm_atm}.pkl`*\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation object.\n    folder : str, default 'auto'\n        The subfolder to save the data.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Didn't care about the already existing files.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the saving filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n    \"\"\"\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    # Initialisation nom fichier auto\n    if omega.therm_corr and omega.atm_corr:\n        suff = '_corr_therm_atm'\n    elif omega.therm_corr:\n        suff = '_corr_therm'\n    elif omega.atm_corr:\n        suff = '_corr_atm'\n    else:\n        suff = ''\n    savname = '{name}{suff}.pkl'.format(name=omega.name, suff=suff)\n    if folder == 'auto':\n        folder = 'v' + str(int(omega.version))\n    # Chemin sav fichier\n    target_path = os.path.join(base_folder, folder, savname)\n    # Testing existent file\n    if security:\n        write = uf.test_security_overwrite(target_path)\n    else:\n        write = True\n    # Sauvegarde pickle\n    if write:\n        with open(target_path, 'wb') as output:\n            pickle.dump(omega, output)\n        if disp:\n            print('\\033[01;34mSaved as \\033[0;03m' + target_path + '\\033[0m')\n</code></pre>"},{"location":"reference/omega_data/#omega_data.compute_list_good_observations","title":"<code>omega_data.compute_list_good_observations(savfilename='liste_good_obs.csv', folder='../data/OMEGA/liste_obs', security=True)</code>","text":"<p>Scan the available OMEGA/MEx data cubes and list the observations considered as  good quality.</p> <p>The results are saved in the specified csv file.</p> <p>Parameters:</p> Name Type Description Default <code>savfilename</code> <code>str</code> <p>The name of the csv file to save the data.</p> <code>'liste_good_obs.csv'</code> <code>folder</code> <code>str</code> <p>The name of the folder where the saved file will be located. Final saved file path = folder + savfilename</p> <code>'../data/OMEGA/liste_obs'</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Didn't care about the already existing files.</p> <code>True</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def compute_list_good_observations(savfilename='liste_good_obs.csv', \n                                   folder='../data/OMEGA/liste_obs', security=True):\n    \"\"\"Scan the available OMEGA/MEx data cubes and list the observations considered as \n    good quality.\n\n    The results are saved in the specified csv file.\n\n    Parameters\n    ----------\n    savfilename : str, default 'liste_good_obs.csv'\n        The name of the csv file to save the data.\n    folder : str, default '../data/OMEGA/liste_obs'\n        The name of the folder where the saved file will be located.&lt;/br&gt;\n        *Final saved file path = folder + savfilename*\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Didn't care about the already existing files.\n    \"\"\"\n    # Test existence fichier de sauvegarde\n    sav_file_path = os.path.join(folder, savfilename)\n    if security:\n        test_overwrite = uf.test_security_overwrite(sav_file_path)\n        if not test_overwrite:\n            return None\n    # Liste observations disponibles\n    bin_obs_list = glob.glob(os.path.join(_omega_bin_path, 'ORB*.QUB'))\n    bin_obs_list.sort()\n    # Initialisation\n    gobs = open(sav_file_path, 'w', encoding='utf-8')\n    gobs.write('obsname, Ls [\u00b0], lat_min [\u00b0], lat_max [\u00b0], lon_min [\u00b0], lon_max [\u00b0], '\n               + 'UTC date/time, Npixel, Nscan\\n')\n    Nacc = 0\n    # Test qualit\u00e9 de chaque observation\n    for obs_name in tqdm(bin_obs_list):\n        nomfic0 = os.path.split(obs_name)[1][:-4]    # R\u00e9cup\u00e9ration nom + d\u00e9codage UTF-8\n        numCube = nomfic0[-1]\n        # Lecture header fichier .QUB\n        hd_qub = _read_header(obs_name[:-4] + '.QUB')\n        summation = np.int64(hd_qub['DOWNTRACK_SUMMING'])\n        bits_per_data = np.float64(hd_qub['INST_CMPRS_RATE'])\n        data_quality = np.int64(hd_qub['DATA_QUALITY_ID'])\n        mode_channel_tmp = hd_qub['COMMAND_DESC'][34:36]\n        if mode_channel_tmp == 'EF':\n            mode_channel = 1\n        elif mode_channel_tmp == '80':\n            mode_channel = 2\n        elif mode_channel_tmp == 'C7':\n            mode_channel = 3\n        else:\n            mode_channel = mode_channel_tmp\n        # Lecture header fichier .NAV\n        if glob.glob(obs_name[:-4] + '.NAV') == []:\n            continue\n        hd_nav = _read_header(obs_name[:-4] + '.NAV')\n        npixel, npara, nscan = np.array(hd_nav['CORE_ITEMS'][1:-1].split(','), dtype=np.int64)\n        point_mode = hd_nav['SPACECRAFT_POINTING_MODE'][1:-1]\n        target = hd_nav['TARGET_NAME']\n        test = True\n        # Test si cube OK\n        if target != 'MARS':\n            continue\n        elif mode_channel != 1:\n            continue\n        elif data_quality == 0:\n            continue\n        elif point_mode == 'N/A':\n            continue\n        elif (numCube == '0') and (npixel == 64) and (bits_per_data == 1):\n            continue\n        else:\n            # Si OK -&gt; sauvegarde des infos dans le fichier\n            gobs.write(('{obsname:s}, {ls:s}, {lat_min:s}, {lat_max:s}, {lon_min:s},'\n                    +'{lon_max:s}, {utc:s}, {npixel:d}, {nscan:d}\\n').format(obsname = nomfic0, \n                                    ls = hd_nav['SOLAR_LONGITUDE'],\n                                    lat_min = hd_nav['MINIMUM_LATITUDE'],\n                                    lat_max = hd_nav['MAXIMUM_LATITUDE'],\n                                    lon_min = hd_nav['WESTERNMOST_LONGITUDE'],\n                                    lon_max = hd_nav['EASTERNMOST_LONGITUDE'],\n                                    utc = hd_nav['START_TIME'][:16],\n                                    npixel = npixel,\n                                    nscan = nscan))\n            Nacc += 1\n    gobs.close()\n    # R\u00e9sultats\n    Ntot = len(bin_obs_list)\n    Nrej = Ntot - Nacc\n    print('\\n\\033[1m{0} observations found\\n'.format(Ntot) +\n            '{0} accepted, {1} rejected\\033[0m'.format(Nacc, Nrej))\n    print('\\n\\033[01;34mResults saved in \\033[0;03m' + sav_file_path + '\\033[0m')\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_atm","title":"<code>omega_data.corr_atm(omega)</code>","text":"<p>Remove the atmospheric component in the OMEGA hyperspectral cube.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where the reflectance is corrected from the atmospheric component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_atm(omega):\n    \"\"\"Remove the atmospheric component in the OMEGA hyperspectral cube.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where the reflectance is corrected from\n        the atmospheric component.\n    \"\"\"\n    # Test correction\n    if omega.atm_corr:\n        print(\"\\033[1;33mAtmospheric correction already applied\\033[0m\")\n        return deepcopy(omega)\n    # Initialisation\n    omega2 = deepcopy(omega)\n    omega_corr = deepcopy(omega)\n    ny, nx, nlam = omega2.cube_rf.shape\n    lam = omega2.lam\n    cube_rf = omega2.cube_rf\n    ic_CL = np.concatenate([omega.ic['C'], omega.ic['L']])\n    nV = len(omega.ic['V'])\n    # Chargement donn\u00e9es atmosph\u00e8re\n    atmorap = np.loadtxt(os.path.join(package_path, 'OMEGA_dataref', 'omega_atmorap_CL.dat'))\n    tr_atm = np.ones(nlam)\n    tr_atm[nV:] = atmorap[ic_CL]    # donn\u00e9es atm uniquement voies C &amp; L\n    # D\u00e9termination exposant\n    i_lam1, i_lam2 = uf.where_closer_array([1.93, 2.01], lam)\n    expo = np.log(cube_rf[:,:,i_lam1] / cube_rf[:,:,i_lam2]) / np.log(tr_atm[i_lam1] / tr_atm[i_lam2])\n    # Correction spectres\n    for x in tqdm(range(nx), desc='Atmospheric correction'):\n        for y in range(ny):\n            sp_rf_corr = cube_rf[y,x] * tr_atm**(-expo[y,x])\n            omega_corr.cube_rf[y,x] = sp_rf_corr\n    # Sortie\n    omega_corr.atm_corr = True\n    omega_corr.atm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.atm_corr_infos['method'] = 'M1 : same reflectance level at 1.93\u03bcm and 2.01\u03bcm'\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_atm2","title":"<code>omega_data.corr_atm2(omega)</code>","text":"<p>Remove the atmospheric component in the OMEGA hyperspectral cube.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where the reflectance is corrected from the atmospheric component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_atm2(omega):\n    \"\"\"Remove the atmospheric component in the OMEGA hyperspectral cube.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where the reflectance is corrected from\n        the atmospheric component.\n    \"\"\"\n    # Test correction\n    if omega.atm_corr:\n        print(\"\\033[1;33mAtmospheric correction already applied\\033[0m\")\n        return deepcopy(omega)\n    # Initialisation\n    omega2 = deepcopy(omega)\n    omega_corr = deepcopy(omega)\n    ny, nx, nlam = omega2.cube_rf.shape\n    lam = omega2.lam\n    cube_rf = omega2.cube_rf\n    ic_CL = np.concatenate([omega.ic['C'], omega.ic['L']])\n    nV = len(omega.ic['V'])\n    # Chargement donn\u00e9es atmosph\u00e8re\n    atmorap = np.loadtxt(os.path.join(package_path, 'OMEGA_dataref', 'omega_atmorap_CL.dat'))\n    tr_atm = np.ones(nlam)\n    tr_atm[nV:] = atmorap[ic_CL]    # donn\u00e9es atm uniquement voies C &amp; L\n    # D\u00e9termination exposant\n    i_lams = uf.where_closer_array([1.97, 1.98, 2.0], lam)\n    cube_rf2 = cube_rf[:,:,i_lams]\n    sp_atm2 = tr_atm[i_lams]\n    expo0 = 1\n    # Correction spectres\n    for x in tqdm(range(nx)):\n        for y in range(ny):\n            expo = minimize(f_min, expo0, args=(cube_rf2[y,x], sp_atm2)).x[0]\n            omega_corr.cube_rf[y,x] = cube_rf[y,x] * tr_atm**(-expo)\n    # Sortie\n    omega_corr.atm_corr = True\n    omega_corr.atm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.atm_corr_infos['method'] = 'M2 : flattest spectra between 1.97\u00b5m and 2.00\u00b5m'\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_atm2_sp","title":"<code>omega_data.corr_atm2_sp(lam, sp_rf, tr_atm)</code>","text":"<p>Remove the atmospheric component in an OMEGA spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>1D array</code> <p>The wavelength array.</p> required <code>sp_rf</code> <code>1D array</code> <p>The reflectance spectrum.</p> required <code>tr_atm</code> <code>1D array</code> <p>Atmospheric transmission spectrum.</p> required <p>Returns:</p> Name Type Description <code>sp_rf_corr</code> <code>1D array</code> <p>The reflectance spectrum, corrected from the atmospheric component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_atm2_sp(lam, sp_rf, tr_atm):\n    \"\"\"Remove the atmospheric component in an OMEGA spectrum.\n\n    Parameters\n    ----------\n    lam : 1D array\n        The wavelength array.\n    sp_rf : 1D array\n        The reflectance spectrum.\n    tr_atm : 1D array\n        Atmospheric transmission spectrum.\n\n    Returns\n    -------\n    sp_rf_corr : 1D array\n        The reflectance spectrum, corrected from the atmospheric component.\n    \"\"\"\n    # D\u00e9termination exposant\n    i_lams = uf.where_closer_array([1.97, 1.98, 2.00], lam)\n    sp_rf2 = sp_rf[i_lams]\n    sp_atm2 = tr_atm[i_lams]\n    expo0 = 1\n    res_opt = minimize(f_min, expo0, args=(sp_rf2, sp_atm2))\n    # if res_opt.success:\n    expo = res_opt.x[0]\n    print(expo)\n    # Correction\n    sp_rf_corr = sp_rf * tr_atm**(-expo)\n    # Sortie\n    return sp_rf_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_atm_sp","title":"<code>omega_data.corr_atm_sp(lam, sp_rf, tr_atm)</code>","text":"<p>Remove the atmospheric component in an OMEGA spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>1D array</code> <p>The wavelength array.</p> required <code>sp_rf</code> <code>1D array</code> <p>The reflectance spectrum.</p> required <code>tr_atm</code> <code>1D array</code> <p>Atmospheric transmission spectrum.</p> required <p>Returns:</p> Name Type Description <code>sp_rf_corr</code> <code>1D array</code> <p>The reflectance spectrum, corrected from the atmospheric component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_atm_sp(lam, sp_rf, tr_atm):\n    \"\"\"Remove the atmospheric component in an OMEGA spectrum.\n\n    Parameters\n    ----------\n    lam : 1D array\n        The wavelength array.\n    sp_rf : 1D array\n        The reflectance spectrum.\n    tr_atm : 1D array\n        Atmospheric transmission spectrum.\n\n    Returns\n    -------\n    sp_rf_corr : 1D array\n        The reflectance spectrum, corrected from the atmospheric component.\n    \"\"\"\n    # TODO &gt; retirer /0\n\n    # D\u00e9termination exposant\n    i_lam1, i_lam2 = uf.where_closer_array([1.93, 2.01], lam)\n    expo = np.log(sp_rf[i_lam1] / sp_rf[i_lam2]) / np.log(tr_atm[i_lam1] / tr_atm[i_lam2])\n    print(expo)\n    # Correction\n    sp_rf_corr = sp_rf * tr_atm**(-expo)\n    # Sortie\n    return sp_rf_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_mode_128","title":"<code>omega_data.corr_mode_128(omega)</code>","text":"<p>Correction corrupted pixels mode 128.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where data from the corrupted columns of 128-pixels wide observations have been corrected if possible.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_mode_128(omega):\n    \"\"\"Correction corrupted pixels mode 128.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where data from the corrupted columns of 128-pixels wide\n        observations have been corrected if possible.\n    \"\"\"\n    omega_corr = deepcopy(omega)\n    ic128 = deepcopy(omega.ic)\n    npixel = omega.npixel\n    nscan = omega.nscan\n    if npixel != 128:\n        print('\\033[1mNot a 128 pixel cube\\033[0m')\n    elif (npixel==128) &amp; (omega.orbit &gt;= 513):\n        print('\\033[33mCorrupted 128 pixel cube\\033[0m')\n        omega128_interp = readsav(os.path.join(package_path, 'OMEGA_dataref', 'omega128_interpol.sav'))\n        if str.encode(omega.name[3:]) in omega128_interp['cublist']:\n            i_omega = np.where(omega128_interp['cublist'] == str.encode(omega.name[3:]))[0][0]\n            cubtype = omega128_interp['cubstatus'][i_omega]\n            if cubtype &lt;= 0:\n                print('\\033[01;33;41mNo correction available (good, corrupted or unusual cube)\\033[0m')\n            else:\n                if cubtype == 1:\n                    print('Parity 1 : spectel 28 corrupted in even lines')\n                    firsteven, firstodd = 28, 12\n                elif cubtype == 2:\n                    print('Parity 2 : spectel 28 corrupted in odd lines')\n                    firsteven, firstodd = 12, 28\n                even = 2 * (np.arange((nscan-2)//2, dtype=int) + 1)     # even lines\n                odd  = 2 * np.arange((nscan-1)//2, dtype=int) + 1       # odd lines\n                cube_i = omega.cube_i\n                cube_rf = omega.cube_rf\n                cube_i_corr = deepcopy(cube_i)\n                cube_rf_corr = deepcopy(cube_rf)\n                for w in range(11): # loop on spectral position\n                    cube_rf_corr[even, 80:95, firsteven+32*w:firsteven+3+32*w] = 0.5 * (\n                        cube_rf[even+1, 80:95, firsteven+32*w:firsteven+3+32*w] + \n                        cube_rf[even-1, 80:95, firsteven+32*w:firsteven+3+32*w] )\n                    cube_rf_corr[odd, 80:95, firstodd+32*w:firstodd+3+32*w] = 0.5 * (\n                        cube_rf[odd+1, 80:95, firstodd+32*w:firstodd+3+32*w] + \n                        cube_rf[odd-1, 80:95, firstodd+32*w:firstodd+3+32*w] )\n                    cube_rf_corr[0, 80:95, firsteven+32*w:firsteven+3+32*w] = (\n                        cube_rf[1, 80:95, firsteven+32*w:firsteven+3+32*w] )\n                    if (nscan/2)*2 == nscan:\n                        cube_rf_corr[nscan-1, 80:95, firstodd+32*w:firstodd+3+32*w] = (\n                            cube_rf[nscan-2, 80:95, firstodd+32*w:firstodd+3+32*w])\n                    else:\n                        cube_rf_corr[nscan-1, 80:95, firsteven+32*w:firsteven+3+32*w] = (\n                            cube_rf[nscan-2, 80:95, firsteven+32*w:firsteven+3+32*w] )\n                omega_corr.cube_i = cube_i_corr\n                omega_corr.cube_rf = cube_rf_corr\n        else:\n            print('\\033[01;33;41mCube not in list\\033[0m')\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_save_omega","title":"<code>omega_data.corr_save_omega(obsname, folder='auto', base_folder='_omega_py_path', security=True, overwrite=True, compress=True, npool=1)</code>","text":"<p>Correction and saving of OMEGA/MEx observations.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>obsname</code> <code>str</code> <p>The name of the OMEGA observation.</p> required <code>folder</code> <code>str</code> <p>The subfolder to save the data. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Didn't care about the already existing files.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>If security is <code>False</code>, default choice for overwriting on existent file.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If <code>True</code>, the radiance cube after correction is removed (i.e. set to <code>None</code>) in order to reduce the size of the saved file.</p> <code>True</code> <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_save_omega(obsname, folder='auto', base_folder='_omega_py_path', security=True,\n                    overwrite=True, compress=True, npool=1):\n    \"\"\"Correction and saving of OMEGA/MEx observations.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    obsname : str\n        The name of the OMEGA observation.\n    folder : str, default 'auto'\n        The subfolder to save the data.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Didn't care about the already existing files.\n    overwrite : bool, default True\n        If security is `False`, default choice for overwriting on existent file.\n    compress : bool, default True\n        If `True`, the radiance cube after correction is removed (i.e. set to `None`)\n        in order to reduce the size of the saved file.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n    \"\"\"\n    if folder == 'auto':\n        folder = 'v' + str(int(_Version))\n    omega = OMEGAdata(obsname)\n    name = omega.name\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    # path synthax\n    basename = os.path.join(base_folder, folder, name, '{0}.pkl')\n    # Testing existent file\n    if os.path.exists(basename.format('_corr_therm_atm')):\n        exists = True\n    else:\n        exists = False\n    if security:\n        overwrite = uf.test_security_overwrite(basename.format('*'))\n    if (not exists) or (exists and overwrite):\n        save_omega(omega, folder=folder, base_folder=base_folder)\n        print('\\n\\033[01mThermal correction\\033[0m')\n        omega_corr = corr_therm(omega, npool)\n        if compress:\n            omega_corr.cube_i = None\n        save_omega(omega_corr, folder=folder, base_folder=base_folder, suff='corr_therm')\n        print('\\n\\033[01mAtmospheric correction\\033[0m')\n        omega_corr_atm = corr_atm(omega_corr)\n        save_omega(omega_corr_atm, folder=folder, base_folder=base_folder, suff='corr_therm_atm')\n    else:\n        print('\\n\\033[01;34mExistent files preserved for {0} - v{1}\\033[0m\\n'.format(name, _Version))\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_save_omega2","title":"<code>omega_data.corr_save_omega2(obsname, folder='auto', base_folder='_omega_py_path', security=True, overwrite=True, compress=True, npool=1)</code>","text":"<p>Correction and saving of OMEGA/MEx observations.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>obsname</code> <code>str</code> <p>The name of the OMEGA observation.</p> required <code>folder</code> <code>str</code> <p>The subfolder to save the data. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Didn't care about the already existing files.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>If security is <code>False</code>, default choice for overwriting on existent file.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If <code>True</code>, the radiance cube after correction is removed (i.e. set to <code>None</code>) in order to reduce the size of the saved file.</p> <code>True</code> <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_save_omega2(obsname, folder='auto', base_folder='_omega_py_path', security=True,\n                    overwrite=True, compress=True, npool=1):\n    \"\"\"Correction and saving of OMEGA/MEx observations.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    obsname : str\n        The name of the OMEGA observation.\n    folder : str, default 'auto'\n        The subfolder to save the data.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Didn't care about the already existing files.\n    overwrite : bool, default True\n        If security is `False`, default choice for overwriting on existent file.\n    compress : bool, default True\n        If `True`, the radiance cube after correction is removed (i.e. set to `None`)\n        in order to reduce the size of the saved file.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n    \"\"\"\n    if folder == 'auto':\n        folder = 'v' + str(int(_Version))\n    omega = OMEGAdata(obsname)\n    name = omega.name\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    # path synthax\n    basename = os.path.join(base_folder, folder, name, '{0}.pkl')\n    # Testing existent file\n    if os.path.exists(basename.format('_corr_therm_atm')):\n        exists = True\n    else:\n        exists = False\n    if security:\n        overwrite = uf.test_security_overwrite(basename.format('*'))\n    if (not exists) or (exists and overwrite):\n        # save_omega(omega, folder=folder, base_folder=base_folder)\n        print('\\n\\033[01mThermal &amp; atmospheric corrections\\033[0m')\n        omega_corr = corr_therm_atm(omega, npool)\n        if compress:\n            omega_corr.cube_i = None\n        save_omega(omega_corr, folder=folder, base_folder=base_folder, suff='corr_therm_atm')\n    else:\n        print('\\n\\033[01;34mExistent files preserved for {0} - v{1}\\033[0m\\n'.format(name, _Version))\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_save_omega2_list","title":"<code>omega_data.corr_save_omega2_list(liste_obs, folder='auto', base_folder='_omega_py_path', security=True, overwrite=True, compress=True, npool=1)</code>","text":"<p>Correction and saving of a list of OMEGA/MEx observations.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>liste_obs</code> <code>list of str</code> <p>The list of the name of the OMEGA observations.</p> required <code>folder</code> <code>str</code> <p>The subfolder to save the data. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Do not care about the already existing files.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>If security is <code>False</code>, default choice for overwriting on existent file.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If <code>True</code>, the radiance cube after correction is removed (i.e. set to <code>None</code>) in order to reduce the size of the saved file.</p> <code>True</code> <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_save_omega2_list(liste_obs, folder='auto', base_folder='_omega_py_path',\n                         security=True, overwrite=True, compress=True, npool=1):\n    \"\"\"Correction and saving of a list of OMEGA/MEx observations.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    liste_obs : list of str\n        The list of the name of the OMEGA observations.\n    folder : str, default 'auto'\n        The subfolder to save the data.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Do not care about the already existing files.\n    overwrite : bool, default True\n        If security is `False`, default choice for overwriting on existent file.\n    compress : bool, default True\n        If `True`, the radiance cube after correction is removed (i.e. set to `None`)\n        in order to reduce the size of the saved file.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n    \"\"\"\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    N = len(liste_obs)\n    if folder == 'auto':\n        folder = 'v' + str(int(_Version))\n    for i, obsname in enumerate(liste_obs):\n        print('\\n\\033[01mComputing observation {0} / {1} : {2}\\033[0m\\n'.format(i+1, N, obsname))\n        corr_save_omega2(obsname, folder, base_folder, security, overwrite, compress, npool)\n    print(\"\\n\\033[01;32m Done\\033[0m\\n\")\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_save_omega_list","title":"<code>omega_data.corr_save_omega_list(liste_obs, folder='auto', base_folder='_omega_py_path', security=True, overwrite=True, compress=True, npool=1)</code>","text":"<p>Correction and saving of a list of OMEGA/MEx observations.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>liste_obs</code> <code>list of str</code> <p>The list of the name of the OMEGA observations.</p> required <code>folder</code> <code>str</code> <p>The subfolder to save the data. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>security</code> <code>bool</code> <p>Enable / disable checking before overwriting a file. | <code>True</code> \u2192 Check if the target file already exists before overwriting on it.           And if is the case, you will be asked for a confirmation. | <code>False</code> \u2192 Do not care about the already existing files.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>If security is <code>False</code>, default choice for overwriting on existent file.</p> <code>True</code> <code>compress</code> <code>bool</code> <p>If <code>True</code>, the radiance cube after correction is removed (i.e. set to <code>None</code>) in order to reduce the size of the saved file.</p> <code>True</code> <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_save_omega_list(liste_obs, folder='auto', base_folder='_omega_py_path',\n                         security=True, overwrite=True, compress=True, npool=1):\n    \"\"\"Correction and saving of a list of OMEGA/MEx observations.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    liste_obs : list of str\n        The list of the name of the OMEGA observations.\n    folder : str, default 'auto'\n        The subfolder to save the data.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    security : bool, default True\n        Enable / disable checking before overwriting a file.&lt;/br&gt;\n        | `True` --&gt; Check if the target file already exists before overwriting on it.\n                  And if is the case, you will be asked for a confirmation.&lt;/br&gt;\n        | `False` --&gt; Do not care about the already existing files.\n    overwrite : bool, default True\n        If security is `False`, default choice for overwriting on existent file.\n    compress : bool, default True\n        If `True`, the radiance cube after correction is removed (i.e. set to `None`)\n        in order to reduce the size of the saved file.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n    \"\"\"\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    N = len(liste_obs)\n    if folder == 'auto':\n        folder = 'v' + str(int(_Version))\n    for i, obsname in enumerate(liste_obs):\n        print('\\n\\033[01mComputing observation {0} / {1} : {2}\\033[0m\\n'.format(i+1, N, obsname))\n        corr_save_omega(obsname, folder, base_folder, security, overwrite, compress, npool)\n    print(\"\\n\\033[01;32m Done\\033[0m\\n\")\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_therm","title":"<code>omega_data.corr_therm(omega, npool=1)</code>","text":"<p>Remove the thermal component in the OMEGA hyperspectral cube.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where the reflectance is corrected from the thermal component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_therm(omega, npool=1):\n    \"\"\"Remove the thermal component in the OMEGA hyperspectral cube.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where the reflectance is corrected from\n        the thermal component.\n    \"\"\"\n    # Test correction\n    if omega.therm_corr:\n        print(\"\\033[1;33mThermal correction already applied\\033[0m\")\n        return deepcopy(omega)\n    # Initialisation\n    global _omega_tmp\n    _omega_tmp = deepcopy(omega)\n    omega_corr = deepcopy(omega)\n    ny, nx, nlam = omega.cube_i.shape\n    rf_corr = np.zeros((ny,nx,nlam), dtype=np.float64)\n    surf_temp = np.zeros((ny,nx), dtype=np.float64)\n    # It\u00e9rateur\n    it = [(x, y, False) for x, y in itertools.product(range(nx), range(ny))]\n    # Correction thermique\n    # chunksize = len(it) // npool    # Approx size of each process\n    chunksize = 1\n    # pool = mp.Pool(npool)\n    if (platform.system()=='Windows') and (npool&gt;1):\n        print(\"\\033[33mWarning: multiprocessing is currently not available for Windows, npool has been set to 1.\\033[0m\")\n    if (npool==1) or (platform.system()=='Windows'):\n        for args in tqdm(it, total=len(it), desc='Thermal correction'):\n            sp_rf_corr, T_fit, x, y = _corr_therm_sp(args)\n            rf_corr[y,x] = sp_rf_corr\n            surf_temp[y,x] = T_fit\n    else:\n        with mp.Pool(npool) as pool:\n            for res in tqdm(pool.imap_unordered(_corr_therm_sp, it, chunksize), total=len(it), desc='Thermal correction'):\n                sp_rf_corr, T_fit, x, y = res\n                rf_corr[y,x] = sp_rf_corr\n                surf_temp[y,x] = T_fit\n            pool.close()\n    _omega_tmp = None\n    omega_corr.cube_rf = rf_corr\n    omega_corr.surf_temp = surf_temp\n    # Update infos\n    omega_corr.therm_corr = True\n    omega_corr.therm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.therm_corr_infos['method'] = '(M1) Calvin &amp; Erard'\n    # Sortie\n    # tfin = time.time()\n    # print('Duration : {0:.0f} min {1:.2f} sec'.format((tfin-tini)//60, (tfin-tini)%60))\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_therm2","title":"<code>omega_data.corr_therm2(omega)</code>","text":"<p>Remove the thermal component in the OMEGA hyperspectral cube,  with simultaneous retriving of reflectance and temperature.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where the reflectance is corrected from the thermal component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_therm2(omega):\n    \"\"\"Remove the thermal component in the OMEGA hyperspectral cube, \n    with simultaneous retriving of reflectance and temperature.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where the reflectance is corrected from\n        the thermal component.\n    \"\"\"\n    # Test correction\n    if omega.therm_corr:\n        print(\"\\033[1;33mThermal correction already applied\\033[0m\")\n        return deepcopy(omega)\n    # Initialisation\n    omega2 = deepcopy(omega)\n    omega_corr = deepcopy(omega)\n    ny, nx, nlam = omega2.cube_i.shape\n    # Correction spectres\n    for x in tqdm(range(nx)):\n        for y in tqdm(range(ny)):\n            sp_rf_corr, surf_temp = corr_therm2_sp(omega2, x, y, disp=False)[1:]\n            omega_corr.cube_rf[y,x] = sp_rf_corr\n            omega_corr.surf_temp[y,x] = surf_temp\n    # Sortie\n    omega_corr.therm_corr = True\n    omega_corr.therm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.therm_corr_infos['method'] = '(M2) Simultaneous refl &amp; temp'\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_therm2_sp","title":"<code>omega_data.corr_therm2_sp(omega, x, y, disp=True)</code>","text":"<p>Remove the thermal component in an OMEGA spectrum, with simultaneous retriving of reflectance and temperature.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <code>x</code> <code>int</code> <p>The x-coordinate of the pixel.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the pixel.</p> required <code>disp</code> <code>bool</code> <p>If <code>True</code> display the fitted temperature/reflectance in the console.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>lam</code> <code>1D array</code> <p>The wavelength array (in \u00b5m).</p> <code>sp_rf_corr</code> <code>1D array</code> <p>The reflectance spectrum, corrected from the thermal component.</p> <code>T_fit</code> <code>float</code> <p>The retrieved surface temperature (in K).</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_therm2_sp(omega, x, y, disp=True):\n    \"\"\"Remove the thermal component in an OMEGA spectrum, with simultaneous retriving\n    of reflectance and temperature.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n    x : int\n        The x-coordinate of the pixel.\n    y : int\n        The y-coordinate of the pixel.\n    disp : bool, default True\n        If `True` display the fitted temperature/reflectance in the console.\n\n    Returns\n    -------\n    lam : 1D array\n        The wavelength array (in \u00b5m).\n    sp_rf_corr : 1D array\n        The reflectance spectrum, corrected from the thermal component.\n    T_fit : float\n        The retrieved surface temperature (in K).\n    \"\"\"\n    # Test correction\n    if omega.therm_corr:\n        print(\"\\033[1;33mThermal correction already applied\\033[0m\")\n        return omega.lam, omega.sp_rf[y, x]\n    # Extraction donn\u00e9es\n    lam = omega.lam\n    sp_rf = omega.cube_rf[y, x]\n    sp_i = omega.cube_i[y, x]\n    sp_sol = omega.specmars\n    ecl = np.cos(omega.inci[y, x] * np.pi/180)\n    # S\u00e9lection des spectels 5.03-5.09\u00b5m (4 derniers voie L)\n    i_lam3, i_lam4 = uf.where_closer_array([5.03, 5.09], lam)\n    i_lam4 += 1\n    def simu_sp_5microns2(i_lams, T, refl):\n        i1, i2 = i_lams.astype(int)\n        lam2 = lam[i1:i2] * 1e-6    # Conversion en m\n        sp_sol2 = sp_sol[i1:i2]\n        Blam = uf.planck(lam2, T) * 1e-6    # Loi de Planck en W.m-2.sr-1.\u00b5m-1\n        sp_simu2 = refl * sp_sol2 * ecl + (1-refl) * Blam\n        return sp_simu2\n    try:\n        # Fit de la temp\u00e9rature et r\u00e9flectance\n        T_fit, refl = curve_fit(simu_sp_5microns2, (i_lam3, i_lam4), sp_i[i_lam3:i_lam4], #p0=(280, 0.5),\n                                bounds=([0, 0], [400, 0.5]))[0]\n        if disp:\n            print('Temperature = {0:.3f} K   |   Reflectance = {1:.5f}'.format(T_fit, refl))\n        # Correction thermique spectre\n        Blam = uf.planck(lam*1e-6, T_fit) * 1e-6   # En W.m-2.sr-1.\u00b5m-1\n        sp_rf_corr = (sp_i - Blam) / (sp_sol*ecl - Blam)\n    except ValueError:\n        # Si fit impossible (infs ou NaN dans le spectre) -&gt; NaN partout\n        sp_rf_corr = deepcopy(sp_rf)\n        sp_rf_corr.fill(np.nan)\n        T_fit = np.nan\n    return lam, sp_rf_corr, T_fit\n</code></pre>"},{"location":"reference/omega_data/#omega_data.corr_therm_atm","title":"<code>omega_data.corr_therm_atm(omega, npool=1)</code>","text":"<p>Remove the thermal and atmospheric component in the OMEGA hyperspectral cube.</p> <p>Parallelization is implemented using the <code>multiprocessing</code> module. The number of process to run is controlled by the <code>npool</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <code>npool</code> <code>int</code> <p>Number of parallelized worker process to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>omega_corr</code> <code>OMEGAdata</code> <p>The input OMEGA observation, where the reflectance is corrected from the thermal and atmospheric component.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def corr_therm_atm(omega, npool=1):\n    \"\"\"Remove the thermal and atmospheric component in the OMEGA hyperspectral cube.\n\n    Parallelization is implemented using the `multiprocessing` module. The number of\n    process to run is controlled by the `npool` argument.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n    npool : int, default 1\n        Number of parallelized worker process to use.\n\n    Returns\n    -------\n    omega_corr : OMEGAdata\n        The input OMEGA observation, where the reflectance is corrected from\n        the thermal and atmospheric component.\n    \"\"\"\n    # Test correction\n    if omega.therm_corr and omega.atm_corr:\n        print(\"\\033[1;33mThermal &amp; atmosphecir corrections already applied\\033[0m\")\n        return deepcopy(omega)\n    # Initialisation\n    global _omega_tmp\n    _omega_tmp = deepcopy(omega)\n    omega_corr = deepcopy(omega)\n    ny, nx, nlam = omega.cube_i.shape\n    rf_corr = np.zeros((ny,nx,nlam), dtype=np.float64)\n    surf_temp = np.zeros((ny,nx), dtype=np.float64)\n    # It\u00e9rateur\n    it = [(x, y, False) for x, y in itertools.product(range(nx), range(ny))]\n    # Correction thermique\n    # chunksize = len(it) // npool    # Approx size of each process\n    chunksize = 1\n    # pool = mp.Pool(npool)\n    if (platform.system()=='Windows') and (npool&gt;1):\n        print(\"\\033[33mWarning: multiprocessing is currently not available for Windows, npool has been set to 1.\\033[0m\")\n    if (npool==1) or (platform.system()=='Windows'):\n        for args in tqdm(it, total=len(it), desc='Thermal &amp; Atmospheric corrections'):\n            sp_rf_corr, T_fit, x, y = _corr_therm_atm_sp(args)\n            rf_corr[y,x] = sp_rf_corr\n            surf_temp[y,x] = T_fit\n    else:\n        with mp.Pool(npool) as pool:\n            for res in tqdm(pool.imap_unordered(_corr_therm_atm_sp, it, chunksize), total=len(it), desc='Thermal &amp; Atmospheric corrections'):\n                sp_rf_corr, T_fit, x, y = res\n                rf_corr[y,x] = sp_rf_corr\n                surf_temp[y,x] = T_fit\n            pool.close()\n    _omega_tmp = None\n    omega_corr.cube_rf = rf_corr\n    omega_corr.surf_temp = surf_temp\n    # Update infos\n    omega_corr.therm_corr = True\n    omega_corr.therm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.therm_corr_infos['method'] = '(M1) Calvin &amp; Erard - Simultaneous atm (L channel)'\n    omega_corr.atm_corr = True\n    omega_corr.atm_corr_infos['datetime'] = datetime.datetime.now()\n    omega_corr.atm_corr_infos['method'] = 'M1 : same reflectance level at 1.93\u03bcm and 2.01\u03bcm - Simultaneous therm (L channel)'\n    # Sortie\n    # tfin = time.time()\n    # print('Duration : {0:.0f} min {1:.2f} sec'.format((tfin-tini)//60, (tfin-tini)%60))\n    return omega_corr\n</code></pre>"},{"location":"reference/omega_data/#omega_data.find_cube","title":"<code>omega_data.find_cube(lon0, lat0, cmin=0, cmax=10000, out=False, data_path='_omega_bin_path', nadir_only=False, recursive_search=True)</code>","text":"<p>Display the available OMEGA/MEx cubes with observations of the target latitude and longitude, Python translation of the IDL procedure <code>findcub.pro</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lon0</code> <code>float</code> <p>The target longitude (in degrees).</p> required <code>lat0</code> <code>float</code> <p>The target latitude (in degrees).</p> required <code>cmin</code> <code>float</code> <p>The minimum orbit number.</p> <code>0</code> <code>cmax</code> <code>float</code> <p>The maximum orbit number.</p> <code>10000</code> <code>out</code> <code>bool</code> <p>If <code>True</code> \u2192 return output</p> <code>False</code> <code>data_path</code> <code>str</code> <p>The path of the directory containing the data (.QUB) and  navigation (.NAV) files.</p> <code>_omega_bin_path</code> <code>nadir_only</code> <code>bool</code> <p>If <code>True</code> \u2192 Only cubes with nadir pointing will be returned.</p> <code>False</code> <code>recursive_search</code> <code>bool</code> <p>If <code>True</code>, enable the search for the .NAV files in subdirectories from <code>data_path</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cub_list</code> <code>array - like</code> <p>List of matching observations. <code>Format : (orbit, x, y, dmin, altMEx, inci, emer, phas, loct, Ls, MY)</code></p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def find_cube(lon0, lat0, cmin=0, cmax=10000, out=False, data_path='_omega_bin_path',\n              nadir_only=False, recursive_search=True):\n    \"\"\"Display the available OMEGA/MEx cubes with observations of the target\n    latitude and longitude, Python translation of the IDL procedure `findcub.pro`.\n\n    Parameters\n    ----------\n    lon0 : float\n        The target longitude (in degrees).\n    lat0 : float\n        The target latitude (in degrees).\n    cmin : float, default 0\n        The minimum orbit number.\n    cmax : float, default 10000\n        The maximum orbit number.\n    out : bool, default False\n        If `True` --&gt; return output\n    data_path : str, default _omega_bin_path\n        The path of the directory containing the data (.QUB) and \n        navigation (.NAV) files.\n    nadir_only : bool, default False\n        If `True` --&gt; Only cubes with nadir pointing will be returned.\n    recursive_search : bool, default True\n        If `True`, enable the search for the .NAV files in subdirectories\n        from `data_path`.\n\n    Returns\n    -------\n    cub_list : array-like\n        List of matching observations.&lt;/br&gt;\n        `Format : (orbit, x, y, dmin, altMEx, inci, emer, phas, loct, Ls, MY)`\n    \"\"\"\n    # Default path\n    if data_path == \"_omega_bin_path\":\n        data_path = _omega_bin_path\n    #-----------------------------\n    # Internal function testin\n    def testin(x0, y0, x1, y1):\n        \"\"\"Internal function for find_cube: test if the point of coordinates \n        (x0, y0) is include in the (x1, y1) grid.\n\n        Parameters\n        ----------\n        x0 : float\n            X-coordinate of the point.\n        y0 : float\n            Y-coordinate of the point.\n        x1 : 1D array\n            X-coordinates of the observation.\n        y1 : 1D array\n            Y-coordinates of the observations.\n\n        Returns\n        -------\n        res : bool\n            | True if the point (x0, y0) is in the observation grid.\n            | False if it's not.\n        \"\"\"\n        nb = len(x1)\n        x2 = np.concatenate([x1, [x1[0]]])\n        y2 = np.concatenate([y1, [y1[0]]])\n        dx = x2 - x0\n        dy = y2 - y0\n        atot = 0\n        for n in range(nb):\n            ps = dx[n] * dx[n+1] + dy[n] * dy[n+1]\n            pv = dx[n] * dy[n+1] - dx[n+1] * dy[n]\n            atot = atot + np.arctan2(pv, ps)\n        if np.abs(atot) &gt; 3:\n            return True\n        else:\n            return False\n    #-----------------------------\n    # Initialization\n    res_folder = os.path.join(package_path, 'res_findcube')\n    trans = np.pi / 180\n    x0 = np.cos(lon0*trans) * np.cos(lat0*trans)\n    y0 = np.sin(lon0*trans) * np.cos(lat0*trans)\n    z0 = np.sin(lat0*trans)\n\n    x1, y1 = np.zeros((2, 10))\n    nomc = []\n\n    nomout = os.path.join(res_folder, 'orbites_lg{lon:.0f}lt{lat:.0f}.dat'.format(lon=lon0, lat=lat0))\n    path_cubliste = os.path.join(res_folder, 'cubelist')\n    path_cubindex = os.path.join(package_path, 'OMEGA_dataref', 'cubindex.ref')\n    with open(path_cubliste, 'w') as f:\n        f.write('# long: {lon:7.3f}  lat: {lat:7.3f}\\n\\n'.format(lon=lon0, lat=lat0))\n        f.write('#{0:^9s} {1:^6s}{2:^6s}{3:^8s}{4:^9s}{5:^7s}{6:^8s}{7:^8s}{8:^8s}{9:^8s}{10:^4s}\\n'.format(\n                'orbit', 'x', 'y', 'dmin', 'altMEx', 'inci', 'emer', 'phas', 'loct', 'Ls', 'MY'))\n    with open(nomout, 'w') as f:\n        f.write('')\n    nhits = 0\n    geocube = 0\n    cubindex = open(path_cubindex, 'rb')\n    # Search for matching observations\n    # South pole\n    if lat0 &lt;= -60:\n        for ncube in range(10000):\n            nomcube = cubindex.readline().decode('utf8').replace('\\n', '')\n            norb = int(nomcube[3:7])\n            if norb == 0:\n                break   # End of file\n            lon1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            lat1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            if (norb &lt; cmin) or (norb &gt; cmax):\n                continue\n            if np.min(lat1) &gt; -60:\n                continue\n            x1 = np.cos(lon1*trans) * np.cos(lat1*trans)\n            y1 = np.sin(lon1*trans) * np.cos(lat1*trans)\n            if testin(x0, y0, x1, y1):\n                nomc.append(nomcube)\n                nhits += 1\n    # North pole\n    elif lat0 &gt;= 60:\n        for ncube in range(10000):\n            nomcube = cubindex.readline().decode('utf8').replace('\\n', '')\n            norb = int(nomcube[3:7])\n            if norb == 0:\n                break   # End of file\n            lon1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            lat1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            if (norb &lt; cmin) or (norb &gt; cmax):\n                continue\n            if np.max(lat1) &lt; 60:\n                continue\n            x1 = np.cos(lon1*trans) * np.cos(lat1*trans)\n            y1 = np.sin(lon1*trans) * np.cos(lat1*trans)\n            if testin(x0, y0, x1, y1):\n                nomc.append(nomcube)\n                nhits += 1\n    # Intermediate region\n    else:\n        for ncube in range(10000):\n            nomcube = cubindex.readline().decode('utf8').replace('\\n', '')\n            norb = int(nomcube[3:7])\n            if norb == 0:\n                break   # End of file\n            lon1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            lat1 = np.fromstring(cubindex.readline().decode('utf8').replace('\\n', ''), sep=' ')\n            if (norb &lt; cmin) or (norb &gt; cmax):\n                continue\n            x1 = np.cos(lon1*trans) * np.cos(lat1*trans)\n            y1 = np.sin(lon1*trans) * np.cos(lat1*trans)\n            z1 = np.sin(lat1*trans)\n            ps = x0*x1 + y0*y1 + z0*z1\n            if np.max(ps) &lt; 0.85:\n                continue\n            lon2 = lon1 - lon0\n            i1 = np.where(lon2 &lt; -180)[0]\n            if len(i1) &gt; 0:\n                lon2[i1] += 360\n            i2 = np.where(lon2 &gt; 180)[0]\n            if len(i2) &gt; 0:\n                lon2[i2] -= 360\n            if testin(0, lat0, lon2, lat1):\n                nomc.append(nomcube)\n                nhits += 1\n    cubindex.close()\n    # Find position &amp; infos for each observation\n    print('{0:^10s} {1:^6s}{2:^6s}{3:^8s}{4:^9s}{5:^7s}{6:^8s}{7:^8s}{8:^8s}{9:^8s}{10:^4s}'.format(\n            'orbit', 'x', 'y', 'dmin', 'altMEx', 'inci', 'emer', 'phas', 'loct', 'Ls', 'MY'))\n    for n in range(nhits):\n        if recursive_search:\n            testfile = glob.glob(os.path.join(data_path, '**', nomc[n]+'.NAV'), recursive=True)\n            if testfile == []:\n                print('{0:8s}{1:s}'.format(nomc[n], '\\033[3m   No corresponding .NAV file\\033[0m'))\n                continue\n            else:\n                testfile = testfile[0]\n        else:\n            testfile = os.path.join(data_path, nomc[n]+'.NAV')\n            if os.path.exists(testfile) == False:\n                print('{0:8s}{1:s}'.format(nomc[n], '\\033[3m   No corresponding .NAV file\\033[0m'))\n                continue\n        #--------------------------\n        # Data from the geometry .NAV file\n        #--------------------------\n        hd_nav = _read_header(testfile)\n        npixel, npara, nscan = np.array(hd_nav['CORE_ITEMS'][1:-1].split(','), dtype=np.int64)\n        lrec = np.int64(hd_nav['RECORD_BYTES'])\n        nrec = np.int64(hd_nav['LABEL_RECORDS'])\n        solong = np.float64(hd_nav['SOLAR_LONGITUDE'])\n        sslong = np.float64(hd_nav['SUB_SOLAR_LONGITUDE'])\n        point_mode = hd_nav['SPACECRAFT_POINTING_MODE'][1:-1]\n        # Test nadir pointing\n        if nadir_only:\n            if point_mode != 'NADIR':\n                # print('{0:8s}{1:s}'.format(nomc[n], '\\033[3m   Non-nadir pointing\\033[0m'))\n                continue\n        #--------------------------\n        # Lecture g\u00e9ometrie\n        class F_line_nav(ctypes.Structure):\n            _fields_ = [('C_line', ctypes.c_int32 * npixel)]\n\n        class F_frame_nav(ctypes.Structure):\n            _fields_ = [('F_line', F_line_nav * npara)]\n\n        class F_Qube_nav(ctypes.Structure):\n            _fields_ = [('F_frame', F_frame_nav * nscan)]\n\n        fqube_nav = F_Qube_nav()\n        skip = lrec * nrec  # taille header (en bytes)\n        geocube = np.ndarray((nscan, npara, npixel), np.int32)\n        with open(testfile, 'rb') as nav_cube:\n            data_hd = nav_cube.read(skip)  # bytes header\n            data_qub = nav_cube.readinto(fqube_nav)     # bytes data\n\n        fqube_nav2 = np.ctypeslib.as_array(fqube_nav.F_frame)\n        geocube[:,:,:] = fqube_nav2['F_line']['C_line']\n        # On remet dans le m\u00eame sens que readomega\n        geocube = np.swapaxes(geocube, 0, 2)\n        #--------------------------\n        longa = geocube[:, 6, :] * 1e-4\n        lata = geocube[:, 7, :] * 1e-4\n        xa = np.cos(longa*trans) * np.cos(lata*trans)\n        ya = np.sin(longa*trans) * np.cos(lata*trans)\n        za = np.sin(lata*trans)\n        xr = y0 * za - z0 * ya\n        yr = z0 * xa - x0 * za\n        zr = x0 * ya - y0 * xa\n        dist = np.sqrt(xr*xr + yr*yr + zr*zr) * 3393\n        distmin = np.min(dist)\n        [i0], [j0] = np.where(dist == distmin)\n        inci = geocube[i0, 2, j0] * 1e-4\n        emer = geocube[i0, 3, j0] * 1e-4\n        phas = geocube[i0, 10, j0] * 1e-4\n        slant = geocube[i0, 11, j0] * 1e-3\n        alt = geocube[i0, 12, j0] * 1e-3\n        possible_geom_corruption = False\n        try:\n            Y, M, D, h, m, s = geocube[:6, 1, j0]\n            utc_dt = datetime.datetime(Y, M, D, h, m, s)\n        except:     # Possible corruption of some geometry lines\n            Y, M, D, h, m, s = np.median(geocube[:6, 1, :], axis=1).astype(np.int64)\n            utc_dt = datetime.datetime(Y, M, D, h, m, s)\n            possible_geom_corruption = True\n        my = _utc_to_my(utc_dt)\n        loct = _compute_local_time(longa, sslong)[i0, j0]\n        obs_output = '{0:9s}{1:6d}{2:6d}{3:8.2f}{4:9.1f}{5:8.2f}{6:8.2f}{7:8.2f}{8:8.2f}{9:8.2f}{10:4d}'.format(\n                        nomc[n], i0, j0, distmin, slant, inci, emer, phas, loct, solong, my)\n        if possible_geom_corruption:\n            obs_output = '\\033[3m' + obs_output + '\\033[0m'\n        print(obs_output)\n\n        with open(path_cubliste, 'a') as f_cublist:\n            f_cublist.write('{0:9s}{1:6d}{2:6d}{3:8.2f}{4:9.1f}{5:8.2f}{6:8.2f}{7:8.2f}{8:8.2f}{9:8.2f}{10:4d}\\n'.format(\n                    nomc[n], i0, j0, distmin, slant, inci, emer, phas, loct, solong, my))\n        with open(nomout, 'a') as f_listeobs:\n            f_listeobs.write('{0:s}\\n'.format(nomc[n]))\n    # Output (if out==True)\n    if out:\n        cub_list = np.genfromtxt(path_cubliste, skip_header=3,\n                                 dtype=None, encoding='utf8')\n        return cub_list\n</code></pre>"},{"location":"reference/omega_data/#omega_data.get_ls","title":"<code>omega_data.get_ls(omega_list)</code>","text":"<p>Return the array of the Solar longitude of each OMEGA/MEx observation in <code>omega_list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>The input array of OMEGA observations.</p> required <p>Returns:</p> Name Type Description <code>ls</code> <code>ndarray</code> <p>The array of the <code>omega_list</code> Ls.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_ls(omega_list):\n    \"\"\"Return the array of the Solar longitude of each OMEGA/MEx observation in `omega_list`.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        The input array of OMEGA observations.\n\n    Returns\n    -------\n    ls : ndarray\n        The array of the `omega_list` Ls.\n    \"\"\"\n    ls = []\n    for omega in omega_list:\n        ls.append(omega.ls)\n    return ls\n</code></pre>"},{"location":"reference/omega_data/#omega_data.get_names","title":"<code>omega_data.get_names(omega_list)</code>","text":"<p>Return the array of the observation ID of each OMEGA/MEx observation in <code>omega_list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>The input array of OMEGA observations.</p> required <p>Returns:</p> Name Type Description <code>names</code> <code>ndarray</code> <p>The array of the <code>omega_list</code> observations ID.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_names(omega_list):\n    \"\"\"Return the array of the observation ID of each OMEGA/MEx observation in `omega_list`.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        The input array of OMEGA observations.\n\n    Returns\n    -------\n    names : ndarray\n        The array of the `omega_list` observations ID.\n    \"\"\"\n    names = []\n    for omega in omega_list:\n        names.append(omega.name)\n    return names\n</code></pre>"},{"location":"reference/omega_data/#omega_data.get_omega_bin_path","title":"<code>omega_data.get_omega_bin_path()</code>","text":"<p>Return the vavue of the global private <code>_omega_bin_path</code> variable.</p> <p>Returns:</p> Name Type Description <code>omega_bin_path</code> <code>str</code> <p>The path of the OMEGA binary files (.QUB and .NAV).</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_omega_bin_path():\n    \"\"\"Return the vavue of the global private `_omega_bin_path` variable.\n\n    Returns\n    -------\n    omega_bin_path : str\n        The path of the OMEGA binary files (.QUB and .NAV).\n    \"\"\"\n    return deepcopy(_omega_bin_path)\n</code></pre>"},{"location":"reference/omega_data/#omega_data.get_omega_py_path","title":"<code>omega_data.get_omega_py_path()</code>","text":"<p>Return the vavue of the global private <code>_omega_py_path</code> variable.</p> <p>Returns:</p> Name Type Description <code>omega_py_path</code> <code>str</code> <p>The new path of the OMEGA python-made files.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def get_omega_py_path():\n    \"\"\"Return the vavue of the global private `_omega_py_path` variable.\n\n    Returns\n    -------\n    omega_py_path : str\n        The new path of the OMEGA python-made files.\n    \"\"\"\n    return deepcopy(_omega_py_path)\n</code></pre>"},{"location":"reference/omega_data/#omega_data.import_list_obs_csv","title":"<code>omega_data.import_list_obs_csv(filename)</code>","text":"<p>Import a list of observations ID from a csv file generated by JMars.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The target path of the csv file.</p> required <p>Returns:</p> Name Type Description <code>liste_obs</code> <code>array of str</code> <p>The list of observations ID from the csv file.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def import_list_obs_csv(filename):\n    \"\"\"Import a list of observations ID from a csv file generated by *JMars*.\n\n    Parameters\n    ----------\n    filename : str\n        The target path of the csv file.\n\n    Returns\n    -------\n    liste_obs : array of str\n        The list of observations ID from the csv file.\n    \"\"\"\n    df = pd.read_csv(filename)\n    columns_id = df.columns\n    liste_obs = np.array(df['product_id_trunc'])\n    return liste_obs\n</code></pre>"},{"location":"reference/omega_data/#omega_data.load_omega","title":"<code>omega_data.load_omega(filename, disp=True)</code>","text":"<p>Load and return a previously saved <code>OMEGAdata</code> object (with <code>save_omega()</code>).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path.</p> required <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the loading filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>omega</code> <code>OMEGAdata</code> <p>The loaded object of OMEGA/MEx observation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def load_omega(filename, disp=True):\n    \"\"\"Load and return a previously saved `OMEGAdata` object (with `save_omega()`).\n\n    Parameters\n    ----------\n    filename : str\n        The file path.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the loading filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n\n    Returns\n    -------\n    omega : OMEGAdata \n        The loaded object of OMEGA/MEx observation.\n    \"\"\"\n    filename2 = uf.myglob(filename)\n    with open(filename2, 'rb') as input_file:\n        omega = pickle.load(input_file)\n        if disp:\n            print('\\033[03m' + filename2 + '\\033[0;01;34m loaded\\033[0m')\n        return omega\n</code></pre>"},{"location":"reference/omega_data/#omega_data.load_omega_list","title":"<code>omega_data.load_omega_list(basename, disp=True)</code>","text":"<p>Load a list of saved OMEGAdata objects, using <code>load_omega()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>basename</code> <code>str</code> <p>The file path basename.</p> required <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the loading filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>omega_list</code> <code>ndarray of OMEGAdata objects</code> <p>The array of loaded objects of OMEGA/MEx observation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def load_omega_list(basename, disp=True):\n    \"\"\"Load a list of saved OMEGAdata objects, using `load_omega()`.\n\n    Parameters\n    ----------\n    basename : str\n        The file path basename.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the loading filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n\n    Returns\n    -------\n    omega_list : ndarray of OMEGAdata objects\n        The array of loaded objects of OMEGA/MEx observation.\n    \"\"\"\n    path_list = glob.glob(basename)\n    omega_list = []\n    for i in range(len(path_list)):\n        omega_list.append(load_omega(path_list[i], disp))\n    return np.array(omega_list)\n</code></pre>"},{"location":"reference/omega_data/#omega_data.load_omega_list2","title":"<code>omega_data.load_omega_list2(liste_obs, therm_corr=True, atm_corr=True, **kwargs)</code>","text":"<p>Load a list of saved OMEGAdata objects, using <code>load_omega()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>liste_obs</code> <code>array of str</code> <p>List of OMEGA/MEx observations ID.</p> required <code>therm_corr</code> <code>bool or None</code> <p>| <code>True</code> \u2192 Only results with thermal correction. | <code>False</code> \u2192 Only results without thermal correction. | <code>None</code> \u2192 Both with and without thermal correction.</p> <code>None</code> <code>atm_corr</code> <code>bool or None</code> <p>| <code>True</code> \u2192 Only results with atmospheric correction. | <code>False</code> \u2192 Only results without atmospheric correction. | <code>None</code> \u2192 Both with and without atmospheric correction.</p> <code>None</code> <code>**kwargs</code> <p>Optional arguments for <code>autoload_omega()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>omega_list</code> <code>list of OMEGAdata objects</code> <p>The list of loaded objects of OMEGA/MEx observation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def load_omega_list2(liste_obs, therm_corr=True, atm_corr=True, **kwargs):\n    \"\"\"Load a list of saved OMEGAdata objects, using `load_omega()`.\n\n    Parameters\n    ----------\n    liste_obs : array of str\n        List of OMEGA/MEx observations ID.\n    therm_corr : bool or None, default None\n        | `True` --&gt; Only results with thermal correction.&lt;/br&gt;\n        | `False` --&gt; Only results without thermal correction.&lt;/br&gt;\n        | `None` --&gt; Both with and without thermal correction.\n    atm_corr : bool or None, default None\n        | `True` --&gt; Only results with atmospheric correction.&lt;/br&gt;\n        | `False` --&gt; Only results without atmospheric correction.&lt;/br&gt;\n        | `None` --&gt; Both with and without atmospheric correction.\n    **kwargs:\n        Optional arguments for `autoload_omega()`.\n\n    Returns\n    -------\n    omega_list : list of OMEGAdata objects\n        The list of loaded objects of OMEGA/MEx observation.\n    \"\"\"\n    omega_list = []\n    Nabs = 0\n    OBC = readsav(os.path.join(package_path, 'OMEGA_dataref', 'OBC_OMEGA_OCT2017.sav'))\n    good_orbits_OBC = np.array(OBC['good_orbits'][0], dtype=int)\n    for i, obsname in enumerate(tqdm(liste_obs)):\n        omega = autoload_omega(obsname, therm_corr=therm_corr, atm_corr=atm_corr, disp=False,\n                               **kwargs)\n        if omega is None:\n            Nabs += 1\n            continue\n        if not omega.orbit in good_orbits_OBC:\n            continue\n        if omega.quality == 0:\n            continue\n        if omega.target != 'MARS':\n            continue\n        if omega.mode_channel != 1:\n            continue\n        if omega.data_quality == 0:\n            continue\n        if omega.point_mode == 'N/A':\n            continue\n        if (int(omega.name[-1]) == 0) and (omega.npixel == 64) and (omega.bits_per_data == 1):\n            continue\n        # if omega.npixel == 16:\n            # continue\n        omega_list.append(omega)\n    Ntot = len(liste_obs)\n    Nacc = len(omega_list)\n    Nrej = Ntot - Nacc - Nabs\n    print('\\n\\033[1m{0} observations in list_obs\\n'.format(Ntot) +\n          '{0} loaded, {1} rejected, {2} not found\\033[0m\\n'.format(Nacc, Nrej, Nabs))\n    return omega_list\n</code></pre>"},{"location":"reference/omega_data/#omega_data.omega_mask","title":"<code>omega_data.omega_mask(omega, emer_lim=None, inci_lim=None, tempc_lim=None, limsat_c=None, hide_128=True, reject_low_quality=False)</code>","text":"<p>Return a mask to remove the bad, corrupted or undesired pixels of an observation.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA observation data.</p> required <code>emer_lim</code> <code>float or None</code> <p>The maximum emergence angle.</p> <code>None</code> <code>inci_lim</code> <code>float or None</code> <p>The maximum incidence angle.</p> <code>None</code> <code>tempc_lim</code> <code>float or None</code> <p>The maximum temperature for the C-channel.</p> <code>None</code> <code>limsat_c</code> <code>float or None</code> <p>The maximum value of the C-channel saturation [DN]. The maximum value in DN for the spectel #40 (i.e., \u03bb=1.486\u03bcm).</p> <p>See Vincendon et al. (2015) or Stcherbinine et al. (2021).</p> <code>None</code> <code>hide_128</code> <code>bool</code> <p>If <code>True</code>, hide the corrupted columns for 128-px wide cubes affected.</p> <code>True</code> <code>reject_low_quality</code> <code>bool</code> <p>Reject observations flagged as low quality, as defined in Stcherbinine et al. (2021). I.e., if: </p> <ul> <li><code>omega.data_quality == 0</code> \u2192 Low quality</li> <li>or <code>not omega.orbit in good_orbits_OBC</code> \u2192 Not in \"good orbits\" file</li> <li>or <code>omega.quality == 0</code></li> <li>or <code>(numCube == 0) and (npixel == 64) and (omega.bits_per_data == 1)</code> </li> <li>or <code>omega.target != 'MARS'</code> \u2192 Mars pointing only</li> <li>or <code>omega.mode_channel != 1</code> \u2192 All 3 channels required</li> <li>or <code>omega.point_mode == 'N/A'</code> \u2192 Unknown pointing informations</li> </ul> <code>False</code> <p>Returns:</p> Name Type Description <code>mask</code> <code>2D array </code> <p>The array that identify the bad/corrupted pixels to remove. | <code>1</code> \u2192 Good pixel | <code>NaN</code> \u2192 Bad pixel</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def omega_mask(omega, emer_lim=None, inci_lim=None, tempc_lim=None, limsat_c=None,\n               hide_128=True, reject_low_quality=False):\n    \"\"\"Return a mask to remove the bad, corrupted or undesired pixels of an observation.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA observation data.\n    emer_lim : float or None, default None\n        The maximum emergence angle.\n    inci_lim : float or None, default None\n        The maximum incidence angle.\n    tempc_lim : float or None, default None\n        The maximum temperature for the C-channel.\n    limsat_c : float or None, default None\n        The maximum value of the C-channel saturation [DN].\n        The maximum value in DN for the spectel #40 (*i.e., \u03bb=1.486\u03bcm*).\n        &gt; See Vincendon et al. (2015) or Stcherbinine et al. (2021).\n    hide_128 : bool, default True\n        If `True`, hide the corrupted columns for 128-px wide cubes affected.\n    reject_low_quality : bool, default False\n        Reject observations flagged as low quality, as defined in Stcherbinine et al. (2021).&lt;/br&gt;\n        I.e., if: \n\n         *  `omega.data_quality == 0` --&gt; Low quality\n         *  or `not omega.orbit in good_orbits_OBC` --&gt; Not in \"good orbits\" file\n         *  or `omega.quality == 0`\n         *  or `(numCube == 0) and (npixel == 64) and (omega.bits_per_data == 1)` \n         *  or `omega.target != 'MARS'` --&gt; Mars pointing only\n         *  or `omega.mode_channel != 1` --&gt; All 3 channels required\n         *  or `omega.point_mode == 'N/A'` --&gt; Unknown pointing informations\n\n    Returns\n    -------\n    mask : 2D array \n        The array that identify the bad/corrupted pixels to remove.&lt;/br&gt;\n        | `1` --&gt; Good pixel&lt;/br&gt;\n        | `NaN` --&gt; Bad pixel\n    \"\"\"\n    # Initialisation\n    mask = np.ones((omega.nscan, omega.npixel))\n    numCube = int(omega.name[-1], 16)\n    npixel = omega.npixel\n    summation = omega.summation\n    OBC = readsav(os.path.join(package_path, 'OMEGA_dataref', 'OBC_OMEGA_OCT2017.sav'))\n    good_orbits_OBC = np.array(OBC['good_orbits'][0], dtype=int)\n    # Rejected cubes : NaN everywhere\n    if reject_low_quality:\n        test_rej = ( \n            (omega.data_quality == 0)   # Low quality\n            or (not omega.orbit in good_orbits_OBC) # Not in \"good orbits\" file\n            or (omega.quality == 0)\n            or ((numCube == 0) and (npixel == 64) and (omega.bits_per_data == 1)) \n            or (omega.target != 'MARS') # Mars pointing only\n            or (omega.mode_channel != 1)    # All 3 channels required\n            or (omega.point_mode == 'N/A')  # Unknown pointing informations\n            # or (omega.npixel == 16)\n                    )\n        if test_rej:\n            mask.fill(np.nan)\n            print('\\033[1mObservation {0} rejected because of low data quality.\\033[0m'.format(omega.name))\n            return mask\n    # Create mask\n    # Modes 128\n    if (npixel == 128) and hide_128:\n        if omega.orbit &gt;= 511:\n            # print(\"Mode 128 pixels observation\")\n            mask[:, 80:96] = np.nan\n        if (omega.orbit &gt;= 2124) and (omega.orbit &lt;= 3283):\n            mask[:, 64:] = np.nan\n    # Calibration lines C-channel for cubes 0\n    if numCube == 0:\n        if npixel == 16:\n            mask[:192] = np.nan\n        elif npixel == 32:\n            mask[:96] = np.nan\n        elif npixel == 64:\n            mask[:48] = np.nan\n        elif npixel == 128:\n            if summation == 1:\n                mask[:24] = np.nan\n            elif summation == 2:\n                mask[:12] = np.nan\n            elif summation == 4:\n                mask[:6] = np.nan\n    # Calib lines VIS-channel for all cubes\n    else:   # Already included in C-channel calib lines for cubes 0\n        if npixel == 16:\n            mask[:56] = np.nan\n        elif npixel == 32:\n            mask[:28] = np.nan\n        elif npixel == 64:\n            mask[:14] = np.nan\n        elif npixel == 128:\n            if summation == 1:\n                mask[:7] = np.nan\n            elif summation == 2:\n                mask[:3] = np.nan\n            elif summation == 4:\n                mask[0] = np.nan\n    # Remove 4 last lines\n    mask[-4:] = np.nan\n    # Incidence angle limit\n    if not (inci_lim is None):\n        mask[omega.inci &gt; inci_lim] = np.nan\n    # Emergence angle limit\n    if not (emer_lim is None):\n        mask[omega.emer &gt; emer_lim] = np.nan\n    # C-channel temperature limit\n    if not (tempc_lim is None):\n        mask[omega.sensor_temp_c &gt; tempc_lim] = np.nan\n    # C-channel saturation criterion limit\n    # (cf Vincendon et al. (2015) or Stcherbinine et al. (2021))\n    if not (limsat_c is None):\n        mask[omega.saturation_c &lt; limsat_c] = np.nan\n    # Output\n    return mask\n</code></pre>"},{"location":"reference/omega_data/#omega_data.save_omega","title":"<code>omega_data.save_omega(omega, savname='auto', folder='', base_folder='_omega_py_path', pref='', suff='', disp=True)</code>","text":"<p>Save an OMEGA object at the selected path using the pickle module.</p> <p><code>Final_path = base_folder + folder + savname</code></p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation object.</p> required <code>savname</code> <code>str</code> <p>The saving filename. | If <code>'auto'</code> \u2192 <code>savname = 'pref_omega.name_ext.pkl'</code></p> <code>'auto'</code> <code>folder</code> <code>str</code> <p>The subfolder to save the data.</p> <code>''</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>pref</code> <code>str</code> <p>The prefix of the savname.</p> <code>''</code> <code>suff</code> <code>str</code> <p>The suffix of the savname.</p> <code>''</code> <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the saving filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def save_omega(omega, savname='auto', folder='', base_folder='_omega_py_path',\n               pref ='', suff='', disp=True):\n    \"\"\"Save an OMEGA object at the selected path using the pickle module.\n\n    `Final_path = base_folder + folder + savname`\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation object.\n    savname : str, default 'auto'\n        The saving filename.&lt;/br&gt;\n        | If `'auto'` --&gt; `savname = 'pref_omega.name_ext.pkl'`\n    folder : str, default ''\n        The subfolder to save the data.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    pref : str, default ''\n        The prefix of the savname.\n    suff : str, default ''\n        The suffix of the savname.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the saving filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n    \"\"\"\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    # Initialisation nom fichier auto\n    if savname == 'auto':\n        if (len(suff)&gt;0) and (suff[0] != '_'):\n            suff = '_' + suff\n        if (len(pref)&gt;0) and (pref[-1] != '_'):\n            pref = pref + '_'\n        savname = '{pref}{name}{suff}.pkl'.format(name=omega.name, pref=pref, suff=suff)\n    # Chemin sav fichier\n    target_path = os.path.join(base_folder, folder, savname)\n    # Sauvegarde pickle\n    with open(target_path, 'wb') as output:\n        pickle.dump(omega, output)\n    if disp:\n        print('\\033[01;34mSaved as \\033[0;03m' + target_path + '\\033[0m')\n</code></pre>"},{"location":"reference/omega_data/#omega_data.set_omega_bin_path","title":"<code>omega_data.set_omega_bin_path(new_path)</code>","text":"<p>Set the global private <code>_omega_bin_path</code> variable to new_path.</p> <p>Parameters:</p> Name Type Description Default <code>new_path</code> <code>str</code> <p>The new path of the OMEGA binary files (.QUB and .NAV).</p> required Source code in <code>omegapy/omega_data.py</code> <pre><code>def set_omega_bin_path(new_path):\n    \"\"\"Set the global private `_omega_bin_path` variable to new_path.\n\n    Parameters\n    ----------\n    new_path : str\n        The new path of the OMEGA binary files (.QUB and .NAV).\n    \"\"\"\n    if not isinstance(new_path, str):\n        raise ValueError('new_path must be a str')\n    global _omega_bin_path\n    _omega_bin_path = new_path\n</code></pre>"},{"location":"reference/omega_data/#omega_data.set_omega_py_path","title":"<code>omega_data.set_omega_py_path(new_path)</code>","text":"<p>Set the global private <code>_omega_py_path</code> variable to new_path.</p> <p>Parameters:</p> Name Type Description Default <code>new_path</code> <code>str</code> <p>The new path of the OMEGA python-made files.</p> required Source code in <code>omegapy/omega_data.py</code> <pre><code>def set_omega_py_path(new_path):\n    \"\"\"Set the global private `_omega_py_path` variable to new_path.\n\n    Parameters\n    ----------\n    new_path : str\n        The new path of the OMEGA python-made files.\n    \"\"\"\n    if not isinstance(new_path, str):\n        raise ValueError('new_path must be a str')\n    global _omega_py_path\n    _omega_py_path = new_path\n</code></pre>"},{"location":"reference/omega_data/#omega_data.shared_lam","title":"<code>omega_data.shared_lam(lam_list)</code>","text":"<p>Return a list of wavelength shared by all the input wavelength arrays.</p> <p>Parameters:</p> Name Type Description Default <code>lam_list</code> <code>list of 1D np.array</code> <p>The list of wavelength array.</p> required <p>Returns:</p> Name Type Description <code>lam2</code> <code>1D np.array</code> <p>The wavelength array that contains only wavelength shared by all the arrays of <code>lam_list</code>.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def shared_lam(lam_list):\n    \"\"\"Return a list of wavelength shared by all the input wavelength arrays.\n\n    Parameters\n    ----------\n    lam_list : list of 1D np.array\n        The list of wavelength array.\n\n    Returns\n    -------\n    lam2 : 1D np.array\n        The wavelength array that contains only wavelength shared by all the arrays of\n        `lam_list`.\n    \"\"\"\n    lam0 = deepcopy(lam_list[0])\n    lam2 = []\n    for lami in lam0:\n        test = True\n        for lam_array in lam_list:\n            if not (lami in lam_array):\n                test = False\n                break\n        if test:\n            lam2.append(lami)\n    lam2 = np.array(lam2)\n    return lam2\n</code></pre>"},{"location":"reference/omega_data/#omega_data.shared_lam_omegalist","title":"<code>omega_data.shared_lam_omegalist(omega_list)</code>","text":"<p>Return a list of wavelength shared by all the wavelength arrays of the input OMEGA/MEx observations.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>list of OMEGAdata</code> <p>The list of OMEGA/MEx observations.</p> required <p>Returns:</p> Name Type Description <code>lam2</code> <code>1D np.array</code> <p>The wavelength array that contains only wavelength shared by all the arrays of <code>lam_list</code>.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def shared_lam_omegalist(omega_list):\n    \"\"\"Return a list of wavelength shared by all the wavelength arrays of the input\n    OMEGA/MEx observations.\n\n    Parameters\n    ----------\n    omega_list : list of OMEGAdata\n        The list of OMEGA/MEx observations.\n\n    Returns\n    -------\n    lam2 : 1D np.array\n        The wavelength array that contains only wavelength shared by all the arrays of\n        `lam_list`.\n    \"\"\"\n    lam0 = deepcopy(omega_list[0].lam)\n    lam2 = []\n    for lami in lam0:\n        test = True\n        for omega in omega_list:\n            if not (lami in omega.lam):\n                test = False\n                break\n        if test:\n            lam2.append(lami)\n    lam2 = np.array(lam2)\n    return lam2\n</code></pre>"},{"location":"reference/omega_data/#omega_data.test_cube","title":"<code>omega_data.test_cube(obs)</code>","text":"<p>Test the quality of an OMEGA/MEx observation from the header informations witout open it.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>str</code> <p>The name of the OMEGA observation.</p> required <p>Returns:</p> Name Type Description <code>test_quality</code> <code>bool</code> <p>| <code>True</code> \u2192 Accepted observation. | <code>False</code> \u2192 Rejected observation.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def test_cube(obs):\n    \"\"\"Test the quality of an OMEGA/MEx observation from the header informations\n    witout open it.\n\n    Parameters\n    ----------\n    obs : str\n        The name of the OMEGA observation.\n\n    Returns\n    -------\n    test_quality : bool\n        | `True` --&gt; Accepted observation.&lt;/br&gt;\n        | `False` --&gt; Rejected observation.\n    \"\"\"\n    # Recherhe nom de fichier\n    data_path = _omega_bin_path\n    obs_name = uf.myglob(os.path.join(data_path, '**', '*' + obs + '*.QUB'), recursive=True)\n    if obs_name is None:\n        print(\"\\033[1;33mAborted\\033[0m\")\n        return False\n    nomfic0 = os.path.split(obs_name)[1][:-4]    # R\u00e9cup\u00e9ration nom + d\u00e9codage UTF-8\n    numCube = int(nomfic0[-1])\n    # Lecture header fichier .QUB\n    hd_qub = _read_header(obs_name[:-4] + '.QUB')\n    summation = np.int64(hd_qub['DOWNTRACK_SUMMING'])\n    bits_per_data = np.float64(hd_qub['INST_CMPRS_RATE'])\n    data_quality = np.int64(hd_qub['DATA_QUALITY_ID'])\n    mode_channel_tmp = hd_qub['COMMAND_DESC'][34:36]\n    if mode_channel_tmp == 'EF':\n        mode_channel = 1\n    elif mode_channel_tmp == '80':\n        mode_channel = 2\n    elif mode_channel_tmp == 'C7':\n        mode_channel = 3\n    else:\n        mode_channel = mode_channel_tmp\n    # Lecture header fichier .NAV\n    if glob.glob(obs_name[:-4] + '.NAV') == []:\n        return False    # Pas de fichier .NAV\n    hd_nav = _read_header(obs_name[:-4] + '.NAV')\n    npixel, npara, nscan = np.array(hd_nav['CORE_ITEMS'][1:-1].split(','), dtype=np.int64)\n    point_mode = hd_nav['SPACECRAFT_POINTING_MODE'][1:-1]\n    target = hd_nav['TARGET_NAME']\n    # Test si cube OK\n    if target != 'MARS':\n        return False\n    elif mode_channel != 1:\n        return False\n    elif data_quality == 0:\n        return False\n    elif point_mode == 'N/A':\n        return False\n    elif (numCube == 0) and (npixel == 64) and (bits_per_data == 1):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/omega_data/#omega_data.update_cube_quality","title":"<code>omega_data.update_cube_quality(obs_name='ORB*.pkl', folder='auto', version=_Version, base_folder='_omega_py_path', recursive=False)</code>","text":"<p>Update the quality attribute of previously saved OMEGAdata objects.</p> <p>Parameters:</p> Name Type Description Default <code>obs_name</code> <code>str</code> <p>The files basename.</p> <code>'ORB*.pkl'</code> <code>folder</code> <code>str</code> <p>The subfolder where the data is. | If <code>'auto'</code> \u2192 <code>folder = 'vX'</code>, where <code>X</code> is the major release version of the used code.</p> <code>'auto'</code> <code>version</code> <code>float</code> <p>The version of the target file (if folder is <code>'auto'</code>). Default is the current code version.</p> <code>_Version</code> <code>base_folder</code> <code>str</code> <p>The base folder path.</p> <code>_omega_py_path</code> <code>recursive</code> <code>bool</code> <p>Option passed to the <code>uf.myglob</code> function. If recursive is True, the pattern <code>**</code> will match any files and zero or more directories and subdirectories. Note: The recursive search option is not compatible with the default automatic paths, as they do not include the <code>**</code> pattern. One should add it where needed (e.g., in the <code>folder</code> argument).</p> <code>False</code> Source code in <code>omegapy/omega_data.py</code> <pre><code>def update_cube_quality(obs_name='ORB*.pkl', folder='auto', version=_Version, \n                        base_folder='_omega_py_path', recursive=False):\n    \"\"\"Update the quality attribute of previously saved OMEGAdata objects.\n\n    Parameters\n    ----------\n    obs_name : str, default 'ORB*.pkl'\n        The files basename.\n    folder : str, default 'auto'\n        The subfolder where the data is.&lt;/br&gt;\n        | If `'auto'` --&gt; `folder = 'vX'`, where `X` is the major release version of the used code.\n    version : float, default _Version\n        The version of the target file (if folder is `'auto'`).&lt;/br&gt;\n        Default is the current code version.\n    base_folder : str, default _omega_py_path\n        The base folder path.\n    recursive : bool, default False\n        Option passed to the `uf.myglob` function.&lt;/br&gt;\n        If recursive is True, the pattern `**` will match any files and\n        zero or more directories and subdirectories.&lt;/br&gt;\n        Note: The recursive search option is not compatible with the default\n        automatic paths, as they do not include the `**` pattern.\n        One should add it where needed (e.g., in the `folder` argument).\n    \"\"\"\n    # Default path\n    if base_folder == \"_omega_py_path\":\n        base_folder = _omega_py_path\n    # Initialisation\n    if obs_name[-4] != '.pkl':\n        obs_name += '.pkl'\n    if folder == 'auto':\n        folder = 'v' + str(int(version))\n    basename = uf.myglob(os.path.join(base_folder, folder, obs_name), recursive=recursive)\n    # Load list corrupted obs\n    OBC = readsav(os.path.join(package_path, 'OMEGA_dataref', 'OBC_OMEGA_OCT2017.sav'))\n    good_orbits_OBC = np.array(OBC['good_orbits'][0], dtype=int)\n    corrupted_orbits_csv = pd.read_csv(os.path.join(package_path, 'OMEGA_dataref', 'corrupted_obs.csv'), \n                                       comment='#', skipinitialspace=True)\n    corrupted_orbits = np.array(corrupted_orbits_csv['corrupted_obs'], dtype=str)\n    corrupted_orbits_comments = np.array(corrupted_orbits_csv['comment'], dtype=str)\n    # Loop on obs in the selected folder\n    fnames = glob.glob(basename)\n    if fnames == []:\n        print(\"\\033[1;33mNo such file found.\\033[0m\")\n    else:\n        for fname in tqdm(fnames):\n            omega = load_omega(fname, disp=False)\n            omega.quality = 1\n            if (omega.npixel==128) &amp; (omega.orbit &gt;= 513):\n                omega.quality = 128\n                omega.add_infos = 'Corrupted 128 pixels cube'\n            if omega.orbit not in good_orbits_OBC:\n                omega.quality = 0\n                omega.add_infos = 'Corrupted orbit'\n            if omega.name in corrupted_orbits:\n                omega.quality = 0\n                i_obs = int(np.where(corrupted_orbits==omega.name)[0])\n                omega.add_infos = corrupted_orbits_comments[i_obs]\n            save_omega(omega, fname, '', '', '', '', False)\n        print('\\033[1m{0} files updated\\033[0m'.format(len(fnames)))\n</code></pre>"},{"location":"reference/omega_data/#omega_data.utc_to_my","title":"<code>omega_data.utc_to_my(dt)</code>","text":"<p>Convert a UTC datetime to the corresponding Martian Year (MY).</p> <p>Martian Years are numbered according to the calendar proposed by R. Todd Clancy  (Clancy et al., Journal of Geophys. Res 105, p 9553, 2000):  Martian Year 1 begins (at a time such that Ls=0) on April 11<sup>th</sup>, 1955.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The UTC datetime object.</p> required <p>Returns:</p> Name Type Description <code>my</code> <code>int</code> <p>The corresponding Martian Year.</p> Source code in <code>omegapy/omega_data.py</code> <pre><code>def utc_to_my(dt):\n    \"\"\"Convert a UTC datetime to the corresponding Martian Year (MY).\n\n    Martian Years are numbered according to the calendar proposed by R. Todd Clancy \n    *(Clancy et al., Journal of Geophys. Res 105, p 9553, 2000)*: &lt;/br&gt;\n    Martian Year 1 begins (at a time such that Ls=0) on April 11th, 1955.\n\n    Parameters\n    ----------\n    dt : datetime.datetime\n        The UTC datetime object.\n\n    Returns\n    -------\n    my : int\n        The corresponding Martian Year.\n    \"\"\"\n    datetime_my1 = datetime.datetime(1955, 4, 11)   # Start MY 1\n    my_sol_duration = 668.6     # Nb of Martian sols during a MY\n    sol_sec_duration = 88775.245    # Duration of a sol in seconds\n    my = int( (dt - datetime_my1).total_seconds() // (my_sol_duration * sol_sec_duration)) + 1\n    return my\n</code></pre>"},{"location":"reference/omega_plots/","title":"omega_plots","text":"<p>Display of <code>OMEGAdata</code> cubes.</p>"},{"location":"reference/omega_plots/#omega_plots.check_list_data_omega","title":"<code>omega_plots.check_list_data_omega(omega_list, data_list, disp=True)</code>","text":"<p>Check the compatibility between <code>data_list</code> and the list of OMEGA/MEx observations. Raise <code>ValueError</code> if uncompatibility.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>List of OMEGA/MEx observations.</p> required <code>data_list</code> <code>3D array</code> <p>List of high-level map associated to the observations of <code>omega_list</code>.</p> required <code>disp</code> <code>bool</code> <p>Enable the display of the result of the test.</p> <code>True</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def check_list_data_omega(omega_list, data_list, disp=True):\n    \"\"\"Check the compatibility between `data_list` and the list of OMEGA/MEx observations.\n    Raise `ValueError` if uncompatibility.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        List of OMEGA/MEx observations.\n    data_list : 3D array\n        List of high-level map associated to the observations of `omega_list`.\n    disp : bool, default True\n        Enable the display of the result of the test.\n    \"\"\"\n    if len(omega_list) != len(data_list):\n        raise ValueError(\"omega_list and data_list must have the same size\")\n    else:\n        for i in range(len(omega_list)):\n            if omega_list[i].lat.shape != data_list[i].shape:\n                raise ValueError(\"The shapes of items {0} of omega_list and data_list does not match.\".format(i))\n    if disp:\n        print(\"\\033[01;32mCompatibility between omega_list and data_list OK\\033[0m\")\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.check_list_mask_omega","title":"<code>omega_plots.check_list_mask_omega(omega_list, mask_list, disp=True)</code>","text":"<p>Check the compatibility between <code>mask_list</code> and the list of OMEGA/MEx observations. Raise <code>ValueError</code> if uncompatibility.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>List of OMEGA/MEx observations.</p> required <code>mask_list</code> <code>3D array</code> <p>List of masks to remove the corrupted pixels of each OMEGA/MEx observation.</p> required <code>disp</code> <code>bool</code> <p>Enable the display of the result of the test.</p> <code>True</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def check_list_mask_omega(omega_list, mask_list, disp=True):\n    \"\"\"Check the compatibility between `mask_list` and the list of OMEGA/MEx observations.\n    Raise `ValueError` if uncompatibility.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        List of OMEGA/MEx observations.\n    mask_list : 3D array\n        List of masks to remove the corrupted pixels of each OMEGA/MEx observation.\n    disp : bool, default True\n        Enable the display of the result of the test.\n    \"\"\"\n    if len(omega_list) != len(mask_list):\n        raise ValueError(\"omega_list and mask_list must have the same size\")\n    else:\n        for i in range(len(omega_list)):\n            if omega_list[i].lat.shape != mask_list[i].shape:\n                raise ValueError(\"The shapes of items {0} of omega_list and mask_list does not match.\".format(i))\n    if disp:\n        print(\"\\033[01;32mCompatibility between omega_list and mask_list OK\\033[0m\")\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.load_map_omega_list","title":"<code>omega_plots.load_map_omega_list(filename)</code>","text":"<p>Load and return the result of <code>omega_plots.show_omega_list_v2()</code> previously saved with <code>save_map_omega_list()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>2D array</code> <p>The omega reflectance at lam, sampled on the new lat/lon grid.</p> <code>mask</code> <code>2D array</code> <p>The array indicating where the new grid has been filled by the OMEGA data.</p> <code>grid_lat</code> <code>2D array</code> <p>The new latitude grid.</p> <code>grid_lon</code> <code>2D array</code> <p>The new longitude grid.</p> <code>mask_obs</code> <code>2D array of str</code> <p>The array indicating which observations have been used to fill each grid position.</p> <code>infos</code> <code>dict</code> <p>The informations about the computation of the data.</p> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def load_map_omega_list(filename):\n    \"\"\"Load and return the result of `omega_plots.show_omega_list_v2()` previously saved\n    with `save_map_omega_list()`.\n\n    Parameters\n    ----------\n    filename : str\n        The file path.\n\n    Returns\n    -------\n    data : 2D array\n        The omega reflectance at lam, sampled on the new lat/lon grid.\n    mask : 2D array\n        The array indicating where the new grid has been filled by the OMEGA data.\n    grid_lat : 2D array\n        The new latitude grid.\n    grid_lon : 2D array\n        The new longitude grid.\n    mask_obs : 2D array of str\n        The array indicating which observations have been used to fill each grid position.\n    infos : dict\n        The informations about the computation of the data.\n    \"\"\"\n    loaded_dict = uf.load_pickle(filename, True)\n    data, mask, grid_lat, grid_lon, mask_obs, infos = loaded_dict.values()\n    return data, mask, grid_lat, grid_lon, mask_obs, infos\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.plot_psp","title":"<code>omega_plots.plot_psp(sp1_id, *args, sp2_id=(None, None), Nfig=None, sp_dict=picked_spectra, **kwargs)</code>","text":"<p>Plot previously picked spectra from interactive plots.</p> <p>If two spectra id are given, the ration sp1/sp2 is showed.</p> <p>Parameters:</p> Name Type Description Default <code>sp1_id</code> <code>tuple of int (nfig, sp_nb)</code> <p><code>nfig</code> : The figure number of the selected spectra. <code>sp_nb</code> : The number of the spectra in this figure (starting at 1).</p> required <code>*args</code> <p>Optional arguments for the <code>plt.plot()</code> function.</p> <code>()</code> <code>sp2_id</code> <code>tuple of int (nfig, sp_nb)</code> <p><code>nfig</code> : The figure number of the selected spectra. <code>sp_nb</code> : The number of the spectra in this figure (starting at 1).</p> <code>(None, None)</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>sp_dict</code> <code>dict</code> <p>The dictionary containing the picked spectra from interactive figures. Default is the current one.</p> <code>picked_spectra</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.plot()</code> function.</p> <code>{}</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def plot_psp(sp1_id, *args, sp2_id=(None, None), Nfig=None, sp_dict=picked_spectra, **kwargs):\n    \"\"\"Plot previously picked spectra from interactive plots.\n\n    If two spectra id are given, the ration sp1/sp2 is showed.\n\n    Parameters\n    ----------\n    sp1_id : tuple of int (nfig, sp_nb)\n        `nfig` : The figure number of the selected spectra.&lt;/br&gt;\n        `sp_nb` : The number of the spectra in this figure (starting at 1).\n    *args : \n        Optional arguments for the `plt.plot()` function.\n    sp2_id : tuple of int (nfig, sp_nb), default (None, None)\n        `nfig` : The figure number of the selected spectra.&lt;/br&gt;\n        `sp_nb` : The number of the spectra in this figure (starting at 1).\n    Nfig : int or str or None, default None\n        The target figure ID.\n    sp_dict : dict, default picked_spectra\n        The dictionary containing the picked spectra from interactive figures.&lt;/br&gt;\n        Default is the current one.\n    **kwargs:\n        Optional arguments for the `plt.plot()` function.\n    \"\"\"\n    nfig1, n_sp1 = sp1_id\n    nfig2, n_sp2 = sp2_id\n    if (n_sp2 is None) or (nfig2 is None):\n        lam = sp_dict[nfig1][0]\n        sp = sp_dict[nfig1][n_sp1]\n        ylabel = 'Reflectance'\n    else:\n        lam1, lam2 = sp_dict[nfig1][0], sp_dict[nfig2][0]\n        sp_1, sp_2 = sp_dict[nfig1][n_sp1], sp_dict[nfig2][n_sp2]\n        lam = od.shared_lam([lam1, lam2])\n        mask_lam1 = uf.where_closer_array(lam, lam1)\n        mask_lam2 = uf.where_closer_array(lam, lam2)\n        sp = sp_1[mask_lam1] / sp_2[mask_lam2]\n        ylabel = 'Ratioed reflectance'\n    plt.figure(Nfig)\n    plt.plot(lam, sp, *args, **kwargs)\n    plt.xlabel('\u03bb [\u00b5m]')\n    plt.ylabel(ylabel)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.point_in_poly4","title":"<code>omega_plots.point_in_poly4(x0, y0, X4, Y4)</code>","text":"<p>Test if a point of coordinates (x0, y0) is within a polygon with 4 sides.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float or array - like</code> <p>The x-coordinate of the point to test.</p> required <code>y0</code> <code>float or array - like</code> <p>The y-coordinate of the point to test.</p> required <code>X4</code> <code>4-tuple of floats</code> <p>The x-coordinates of the polygon corners.</p> required <code>Y4</code> <code>4-tuple of floats</code> <p>The y-coordinates of the polygon corners.</p> required <p>Returns:</p> Name Type Description <code>testin</code> <code>bool or array-like of bool</code> <p><code>True</code> if <code>(x0, y0)</code> is within the polygon.</p> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def point_in_poly4(x0, y0, X4, Y4):\n    \"\"\"Test if a point of coordinates (x0, y0) is within a polygon with 4 sides.\n\n    Parameters\n    ----------\n    x0 : float or array-like\n        The x-coordinate of the point to test.\n    y0 : float or array-like\n        The y-coordinate of the point to test.\n    X4 : 4-tuple of floats\n        The x-coordinates of the polygon corners.\n    Y4 : 4-tuple of floats\n        The y-coordinates of the polygon corners.\n\n    Returns\n    -------\n    testin : bool or array-like of bool\n        `True` if `(x0, y0)` is within the polygon.\n    \"\"\"\n    # Extraction\n    Xa, Xb, Xc, Xd = deepcopy(X4)\n    Ya, Yb, Yc, Yd = deepcopy(Y4)\n    # re-order to have\n    #  D--C\n    #  |  |\n    #  A--B\n    while ((Xa &gt; Xb) or (Xd &gt; Xc) or (Ya &gt; Yd) or (Yb &gt; Yc)):\n        if Xa &gt; Xb:\n            Xa, Xb = Xb, Xa\n            Ya, Yb = Yb, Ya\n        if Xd &gt; Xc:\n            Xd, Xc = Xc, Xd\n            Yd, Yc = Yc, Yd\n        if Ya &gt; Yd:\n            Ya, Yd = Yd, Ya\n            Xa, Xd = Xd, Xa\n        if Yb &gt; Yc:\n            Yb, Yc = Yc, Yb\n            Xb, Xc = Xc, Xb\n    # Internal test functions\n    def f_xmin(y):\n        return Xa + ((Xd - Xa) / (Yd - Ya)) * (y - Ya)\n    def f_xmax(y):\n        return Xb + ((Xc - Xb) / (Yc - Yb)) * (y - Yb)\n    def f_ymin(x):\n        return Ya + ((Yb - Ya) / (Xb - Xa)) * (x - Xa)\n    def f_ymax(x):\n        return Yd + ((Yc - Yd) / (Xc - Xd)) * (x - Xd)\n    # Test if point in poly\n    testin = (\n        ( x0 &gt;= f_xmin(y0) ) &amp;\n        ( x0 &lt;= f_xmax(y0) ) &amp;\n        ( y0 &gt;= f_ymin(x0) ) &amp;\n        ( y0 &lt;= f_ymax(x0) )\n        )\n    return testin\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.proj_grid","title":"<code>omega_plots.proj_grid(omega, data, lat_min=-90, lat_max=90, lon_min=0, lon_max=360, pas_lat=0.1, pas_lon=0.1, negative_values=False)</code>","text":"<p>Sample the data from the input OMEGA/MEx observation on a given lat/lon grid.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>data</code> <code>2D array</code> <p>The initial array of values associated to the OMEGAdata observation. e.g.: Refelectance at selected wvl, spectra, or derived data such as IBD map.</p> required <code>lat_min</code> <code>float</code> <p>The minimal latitude of the grid.</p> <code>-90</code> <code>lat_max</code> <code>float</code> <p>The maximum latitude of the grid.</p> <code>90</code> <code>lon_min</code> <code>float</code> <p>The minimal longitude of the grid.</p> <code>0</code> <code>lon_max</code> <code>float</code> <p>The maximal longitude of the grid.</p> <code>360</code> <code>pas_lat</code> <code>float</code> <p>The latitude intervals of the grid.</p> <code>0.1</code> <code>pas_lon</code> <code>float</code> <p>The longitude intervals of the grid.</p> <code>0.1</code> <code>negative_values</code> <code>bool</code> <p>Set if the negative values are considered as relevant data or not.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>grid_data</code> <code>2D array</code> <p>The data values, sampled on the new lat/lon grid. <code>dim = (Nlon x Nlat)</code></p> <code>mask</code> <code>2D array</code> <p>The array indicating where the new grid has been filled by the OMEGA data.</p> <code>grid_lat</code> <code>2D array</code> <p>The new latitude grid.</p> <code>grid_lon</code> <code>2D array</code> <p>The new longitude grid.</p> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def proj_grid(omega, data, lat_min=-90, lat_max=90, lon_min=0, lon_max=360,\n              pas_lat=0.1, pas_lon=0.1, negative_values=False):\n    \"\"\"Sample the data from the input OMEGA/MEx observation on a given lat/lon grid.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    data : 2D array\n        The initial array of values associated to the OMEGAdata observation.&lt;/br&gt;\n        *e.g.: Refelectance at selected wvl, spectra, or derived data such as IBD map.*\n    lat_min : float, default -90\n        The minimal latitude of the grid.\n    lat_max : float, default 90\n        The maximum latitude of the grid.\n    lon_min : float, default 0\n        The minimal longitude of the grid.\n    lon_max : float, default 360\n        The maximal longitude of the grid.\n    pas_lat : float, default 0.1\n        The latitude intervals of the grid.\n    pas_lon : float, default 0.1\n        The longitude intervals of the grid.\n    negative_values : bool, default False\n        Set if the negative values are considered as relevant data or not.\n\n    Returns\n    -------\n    grid_data : 2D array\n        The data values, sampled on the new lat/lon grid.&lt;/br&gt;\n        `dim = (Nlon x Nlat)`\n    mask : 2D array\n        The array indicating where the new grid has been filled by the OMEGA data.\n    grid_lat : 2D array\n        The new latitude grid.\n    grid_lon : 2D array\n        The new longitude grid.\n    \"\"\"\n    # Initialisation\n    lat_array = np.arange(lat_min, lat_max+pas_lat, pas_lat)\n    lon_array = np.arange(lon_min, lon_max+pas_lon, pas_lon)\n    Nlon, Nlat = len(lon_array)-1, len(lat_array)-1\n    grid_lat, grid_lon = np.meshgrid(lat_array, lon_array)\n    grid_data = np.zeros((Nlon, Nlat))\n    mask = np.zeros((Nlon, Nlat))\n    lat2 = np.floor(np.clip(omega.lat, lat_min, lat_max-0.1*pas_lat) /pas_lat) * pas_lat\n    lon2 = np.floor(np.clip(omega.lon, lon_min, lon_max-0.1*pas_lon) /pas_lon) * pas_lon\n    nx, ny = lat2.shape\n    # Sampling on the new grid\n    for j in range(ny):\n        for i in range(nx):\n            longi, lati = lon2[i,j], lat2[i,j]\n            i_lon = int(longi/pas_lon - lon_min/pas_lon)\n            j_lat = int(lati/pas_lat - lat_min/pas_lat)\n            data_tmp = data[i,j]\n            # if (not np.isnan(data_tmp)) &amp; (data_tmp &gt; 0):   # Filtrage r\u00e9gions sans donn\u00e9es\n            if negative_values:\n                if (not np.isnan(data_tmp)) &amp; (not np.isinf(data_tmp)):   # Filtrage r\u00e9gions sans donn\u00e9es\n                    grid_data[i_lon,j_lat] += data_tmp\n                    mask[i_lon,j_lat] += 1\n            else:   # negative values = No data\n                if (not np.isnan(data_tmp)) &amp; (data_tmp &gt; 0) &amp; (not np.isinf(data_tmp)):   # Filtrage r\u00e9gions sans donn\u00e9es\n                    grid_data[i_lon,j_lat] += data_tmp\n                    mask[i_lon,j_lat] += 1\n    grid_data[grid_data==0] = np.nan\n    grid_data2 = grid_data / mask       # Normalisation\n    mask2 = np.clip(mask, 0, 1)\n    return grid_data2, mask2, grid_lat, grid_lon\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.proj_grid2","title":"<code>omega_plots.proj_grid2(omega, data, lat_min=-90, lat_max=90, lon_min=0, lon_max=360, pas_lat=0.1, pas_lon=0.1, negative_values=False)</code>","text":"<p>Sample the data from the input OMEGA/MEx observation on a given lat/lon grid.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>data</code> <code>2D array</code> <p>The initial array of values associated to the OMEGAdata observation. e.g.: Refelectance at selected wvl, spectra, or derived data such as IBD map.</p> required <code>lat_min</code> <code>float</code> <p>The minimal latitude of the grid.</p> <code>-90</code> <code>lat_max</code> <code>float</code> <p>The maximum latitude of the grid.</p> <code>90</code> <code>lon_min</code> <code>float</code> <p>The minimal longitude of the grid.</p> <code>0</code> <code>lon_max</code> <code>float</code> <p>The maximal longitude of the grid.</p> <code>360</code> <code>pas_lat</code> <code>float</code> <p>The latitude intervals of the grid.</p> <code>0.1</code> <code>pas_lon</code> <code>float</code> <p>The longitude intervals of the grid.</p> <code>0.1</code> <code>negative_values</code> <code>bool</code> <p>Set if the negative values are considered as relevant data or not.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>grid_data</code> <code>2D array</code> <p>The data values, sampled on the new lat/lon grid. <code>dim = (Nlon x Nlat)</code></p> <code>mask</code> <code>2D array</code> <p>The array indicating where the new grid has been filled by the OMEGA data.</p> <code>grid_lat</code> <code>2D array</code> <p>The new latitude grid.</p> <code>grid_lon</code> <code>2D array</code> <p>The new longitude grid.</p> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def proj_grid2(omega, data, lat_min=-90, lat_max=90, lon_min=0, lon_max=360,\n              pas_lat=0.1, pas_lon=0.1, negative_values=False):\n    \"\"\"Sample the data from the input OMEGA/MEx observation on a given lat/lon grid.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    data : 2D array\n        The initial array of values associated to the OMEGAdata observation.&lt;/br&gt;\n        *e.g.: Refelectance at selected wvl, spectra, or derived data such as IBD map.*\n    lat_min : float, default -90\n        The minimal latitude of the grid.\n    lat_max : float, default 90\n        The maximum latitude of the grid.\n    lon_min : float, default 0\n        The minimal longitude of the grid.\n    lon_max : float, default 360\n        The maximal longitude of the grid.\n    pas_lat : float, default 0.1\n        The latitude intervals of the grid.\n    pas_lon : float, default 0.1\n        The longitude intervals of the grid.\n    negative_values : bool, default False\n        Set if the negative values are considered as relevant data or not.\n\n    Returns\n    -------\n    grid_data : 2D array\n        The data values, sampled on the new lat/lon grid.&lt;/br&gt;\n        `dim = (Nlon x Nlat)`\n    mask : 2D array\n        The array indicating where the new grid has been filled by the OMEGA data.\n    grid_lat : 2D array\n        The new latitude grid.\n    grid_lon : 2D array\n        The new longitude grid.\n    \"\"\"\n    # Initialisation\n    #-- OMEGA grids\n    \u03a9lat = deepcopy(omega.lat)\n    \u03a9lon = deepcopy(omega.lon)\n    \u03a9grid_lat = deepcopy(omega.lat_grid)\n    \u03a9grid_lon = deepcopy(omega.lon_grid)\n    #-- Test negative longitudes if close to 0\u00b0/360\u00b0\n    mask_lat = (np.abs(omega.lat) &lt; 85)\n    if (omega.lon[mask_lat] &lt; 10).any() and (omega.lon[mask_lat] &gt; 350).any() and (lon_min &gt;= 0) and (lon_max &gt; 180):\n        negatives_longitudes = True\n    else:\n        negatives_longitudes = False\n    #-- Test polar case\n    if (omega.lat &gt; 85).any():\n        polarN = True\n        polarS = False\n    elif (omega.lat &lt; -85).any():\n        polarN = False\n        polarS = True\n    else:\n        polarN = False\n        polarS = False\n    #-- Lon/Lat grids\n    lat_array = np.arange(lat_min, lat_max+pas_lat, pas_lat)\n    lon_array = np.arange(lon_min, lon_max+pas_lon, pas_lon)\n    if negatives_longitudes:\n        n_neg_lon = np.sum(lon_array &gt; 180) # nb of negative longitudes (&gt;180\u00b0)\n        i_lon180 = np.where(lon_array &gt; 180)[0][0] # 1st index of lon &gt; 180\u00b0\n        lon_array_nl = deepcopy(lon_array)        # new longitude grid [-180\u00b0, 180\u00b0]\n        lon_array_nl[:n_neg_lon] = lon_array[i_lon180-1:-1] - 360\n        lon_array_nl[n_neg_lon:] = lon_array[:i_lon180]\n        lon_array = deepcopy(lon_array_nl)\n        \u03a9grid_lon[\u03a9grid_lon &gt; 180] -= 360\n        \u03a9lon[\u03a9lon &gt; 180] -= 360\n    Nlon, Nlat = len(lon_array)-1, len(lat_array)-1\n    grid_lat, grid_lon = np.meshgrid(lat_array, lon_array)\n    grid_data = np.zeros((Nlon, Nlat))\n    mask = np.zeros((Nlon, Nlat))\n    #-- Center grids for projection\n    if np.min(lat_array) &lt; np.min(\u03a9grid_lat):\n        i_lat_min = np.where(lat_array &lt; np.min(\u03a9grid_lat))[0][-1]\n    else:\n        i_lat_min = 0\n    if np.max(lat_array) &gt; np.max(\u03a9grid_lat):\n        i_lat_max = np.where(lat_array &gt; np.max(\u03a9grid_lat))[0][0]\n    else:\n        i_lat_max = Nlat\n    if np.min(lon_array) &lt; np.min(\u03a9grid_lon):\n        i_lon_min = np.where(lon_array &lt; np.min(\u03a9grid_lon))[0][-1]\n    else:\n        i_lon_min = 0\n    if np.max(lon_array) &gt; np.max(\u03a9grid_lon):\n        i_lon_max = np.where(lon_array &gt; np.max(\u03a9grid_lon))[0][0]\n    else:\n        i_lon_max = Nlon\n    if polarN or polarS:\n        i_lon_min, i_lon_max = 0, Nlon\n    grid_latC = deepcopy(grid_lat)[i_lon_min:i_lon_max, i_lat_min:i_lat_max] + pas_lat/2\n    grid_lonC = deepcopy(grid_lon)[i_lon_min:i_lon_max, i_lat_min:i_lat_max] + pas_lon/2\n    # Sampling on the new grid\n    nx, ny = data.shape\n    for j in tqdm(range(ny)):\n        for i in tqdm(range(nx), leave=False):\n            data_tmp = data[i,j]\n            lat4 = \u03a9grid_lat[i:i+2, j:j+2].reshape(-1)\n            lon4 = \u03a9grid_lon[i:i+2, j:j+2].reshape(-1)\n            # Filtrage r\u00e9gions sans donn\u00e9es\n            if negative_values:\n                data_ok = (not np.isnan(data_tmp)) &amp; (not np.isinf(data_tmp))\n            else:   # negative values = No data\n                data_ok = (not np.isnan(data_tmp)) &amp; (data_tmp &gt; 0) &amp; (not np.isinf(data_tmp))\n            # Filling grids with data\n            if data_ok:\n                testin = point_in_poly4(grid_lonC, grid_latC, lon4, lat4)   # Test if in \u03a9 pixel\n                grid_data[i_lon_min:i_lon_max, i_lat_min:i_lat_max] += (data_tmp * testin)\n                mask[i_lon_min:i_lon_max, i_lat_min:i_lat_max] += testin\n                # if testin.any():\n                    # print(i,j, np.sum(testin))\n    grid_data[grid_data==0] = np.nan\n    grid_data2 = grid_data / mask       # Normalisation\n    mask2 = np.clip(mask, 0, 1)\n    # Re-ordering if negatives longitudes\n    if negatives_longitudes:\n        n_pos_lon = np.sum(grid_lon[:,0] &gt;= 0) # nb of positives longitudes (&gt;= 0\u00b0)\n        i_lon0 = np.where(grid_lon[:,0] &gt;= 0)[0][0] # 1st index of lon &gt;= 0\u00b0\n        # lon\n        grid_lon_pl = deepcopy(grid_lon)        # new longitude grid [0\u00b0, 360\u00b0]\n        grid_lon_pl[:n_pos_lon] = grid_lon[i_lon0:]\n        grid_lon_pl[n_pos_lon:] = grid_lon[1:i_lon0+1] + 360\n        grid_lon = deepcopy(grid_lon_pl)\n        # data\n        grid_data2_pl = deepcopy(grid_data2)      # new data array\n        grid_data2_pl[:n_pos_lon-1] = grid_data2[i_lon0:]\n        grid_data2_pl[n_pos_lon-1:] = grid_data2[:i_lon0]\n        grid_data2 = deepcopy(grid_data2_pl)\n        # mask\n        mask2_pl = deepcopy(mask2)      # new mask array\n        mask2_pl[:n_pos_lon-1] = mask2[i_lon0:]\n        mask2_pl[n_pos_lon-1:] = mask2[:i_lon0]\n        mask2 = deepcopy(mask2_pl)\n    # Output\n    return grid_data2, mask2, grid_lat, grid_lon\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.save_map_omega_list","title":"<code>omega_plots.save_map_omega_list(omega_list, lat_min=-90, lat_max=90, lon_min=0, lon_max=360, pas_lat=0.1, pas_lon=0.1, lam=1.085, data_list=None, data_desc='', mask_list=None, negative_values=False, proj_method=1, use_V_geom=False, use_L_geom=False, sav_filename='auto', ext='', base_folder='../data/OMEGA/sav_map_list_v2/', sub_folder='')</code>","text":"<p>Save the output of the <code>omega_plots.show_omega_list_v2()</code> function with the requested parameters as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>The list of OMEGA/MEx observations.</p> required <code>lat_min</code> <code>float</code> <p>The minimal latitude of the grid.</p> <code>-90</code> <code>lat_max</code> <code>float</code> <p>The maximum latitude of the grid.</p> <code>90</code> <code>lon_min</code> <code>float</code> <p>The minimal longitude of the grid.</p> <code>0</code> <code>lon_max</code> <code>float</code> <p>The maximal longitude of the grid.</p> <code>360</code> <code>pas_lat</code> <code>float</code> <p>The latitude intervals of the grid.</p> <code>0.1</code> <code>pas_lon</code> <code>float</code> <p>The longitude intervals of the grid.</p> <code>0.1</code> <code>lam</code> <code>float</code> <p>The selected wavelength (in \u00b5m).</p> <code>1.085</code> <code>data_list</code> <code>3D array or None</code> <p>1D array of the same dimension of <code>omega_list</code> containing alternative maps (2D arrays), in the same order than the observations of <code>omega_list</code>.</p> <code>None</code> <code>data_desc</code> <code>str</code> <p>Description of the data contained in data_list (if used).</p> <code>''</code> <code>mask_list</code> <code>3D array or None</code> <p>1D array of the same dimension of <code>omega_list</code> containing the masks to remove the corrupted pixels of each observaiton, in the same order than the observations of  <code>omega_list</code>. Each mask is a 2D array, filled with 1 for good pixels and NaN for bad ones.</p> <code>None</code> <code>negative_values</code> <code>bool</code> <p>Set if the negative values are considered as relevant data or not.</p> <code>False</code> <code>proj_method</code> <code>int</code> <p>Select the projection method used (1 or 2). | <code>1</code> \u2192 Consider only the center point of each pixel.        Faster but not adapted if the grid resolution is lower than the OMEGA pixels size. | <code>2</code> \u2192 Consider the entire spatial extent of each pixel.        More accurate, but take more time.</p> <code>1</code> <code>use_V_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the V-channel instead of the C-channel.</p> <code>False</code> <code>use_L_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the L-channel instead of the C-channel.</p> <code>False</code> <code>sav_filename</code> <code>str</code> <p>The saving file name. | If <code>'auto'</code> \u2192 Automatically generated.</p> <code>'auto'</code> <code>ext</code> <code>str</code> <p>Extension to add at the end of the filename (useful in case of automatic generation).</p> <code>''</code> <code>base_folder</code> <code>str</code> <p>The base folder to save the data.</p> <code>'../data/OMEGA/sav_map_list_v2/'</code> <code>sub_folder</code> <code>str</code> <p>The subfolder to save the data. Final path = \"<code>base_folder</code> / <code>sub_folder</code> / <code>sav_filename</code>\"</p> <code>''</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def save_map_omega_list(omega_list, lat_min=-90, lat_max=90, lon_min=0, lon_max=360,\n                        pas_lat=0.1, pas_lon=0.1, lam=1.085, data_list=None, data_desc='', \n                        mask_list=None, negative_values=False, proj_method=1, \n                        use_V_geom=False, use_L_geom=False, sav_filename='auto', ext='',\n                        base_folder='../data/OMEGA/sav_map_list_v2/', sub_folder=''):\n    \"\"\"Save the output of the `omega_plots.show_omega_list_v2()` function with the requested\n    parameters as a dictionary.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        The list of OMEGA/MEx observations.\n    lat_min : float, default -90\n        The minimal latitude of the grid.\n    lat_max : float, default 90\n        The maximum latitude of the grid.\n    lon_min : float, default 0\n        The minimal longitude of the grid.\n    lon_max : float, default 360\n        The maximal longitude of the grid.\n    pas_lat : float, default 0.1\n        The latitude intervals of the grid.\n    pas_lon : float, default 0.1\n        The longitude intervals of the grid.\n    lam : float, default 1.085\n        The selected wavelength (in \u00b5m).\n    data_list : 3D array or None, default None\n        1D array of the same dimension of `omega_list` containing alternative maps (2D arrays),\n        in the **same order** than the observations of `omega_list`.\n    data_desc : str, default ''\n        Description of the data contained in data_list (if used).\n    mask_list : 3D array or None, default None\n        1D array of the same dimension of `omega_list` containing the masks to remove the\n        corrupted pixels of each observaiton, in the **same order** than the observations of \n        `omega_list`.&lt;/br&gt;\n        Each mask is a 2D array, filled with 1 for good pixels and NaN for bad ones.\n    negative_values : bool, default False\n        Set if the negative values are considered as relevant data or not.\n    proj_method : int, default 1\n        Select the projection method used (1 or 2).&lt;/br&gt;\n        | `1` --&gt; Consider only the center point of each pixel.&lt;/br&gt;\n               Faster but not adapted if the grid resolution is lower than the OMEGA pixels size.&lt;/br&gt;\n        | `2` --&gt; Consider the entire spatial extent of each pixel.&lt;/br&gt;\n               More accurate, but take more time.\n    use_V_geom : bool, default False\n        If `True`, use the geometry of the V-channel instead of the C-channel.\n    use_L_geom : bool, default False\n        If `True`, use the geometry of the L-channel instead of the C-channel.\n    sav_filename : str, default 'auto'\n        The saving file name.&lt;/br&gt;\n        | If `'auto'` --&gt; Automatically generated.\n    ext : str, default ''\n        Extension to add at the end of the filename (useful in case of automatic generation).\n    base_folder : str, default '../data/OMEGA/sav_map_list_v2/'\n        The base folder to save the data.\n    sub_folder : str, default ''\n        The subfolder to save the data.&lt;/br&gt;\n        *Final path = \"`base_folder` / `sub_folder` / `sav_filename`\"*\n    \"\"\"\n    # Initialization filename\n    if sav_filename == 'auto':\n        sav_filename = ('res_show_omega_list_v2__lat{0:0&gt;2d}-{1:0&gt;2d}_pas{2:0}_'\n                        + 'lon{3:0&gt;3d}-{4:0&gt;3d}_pas{5:0}__{6:s}.pkl').format(\n                            lat_min, lat_max, pas_lat, lon_min, lon_max, pas_lon, ext)\n    sav_filename2 = os.path.join(base_folder, sub_folder, sav_filename)\n    if data_list is None:\n        data_desc = 'Reflectance @ \u03bb = {0:0} \u00b5m'.format(lam)\n    elif data_desc == '':\n        data_desc = 'unknown input data'\n    # Compute the data sampling\n    data, mask, grid_lat, grid_lon, mask_obs = show_omega_list_v2(omega_list,\n                lam, lat_min, lat_max, lon_min, lon_max, pas_lat, pas_lon,\n                data_list=data_list, mask_list=mask_list, negative_values=negative_values,\n                proj_method=proj_method, use_V_geom=use_V_geom, use_L_geom=use_L_geom, plot=False, out=True)\n    # Sav file\n    input_params = {\n        'omega_list' : od.get_names(omega_list),\n        'lat_min' : lat_min,\n        'lat_max' : lat_max,\n        'lon_min' : lon_min,\n        'lon_max' : lon_max,\n        'pas_lat' : pas_lat,\n        'pas_lon' : pas_lon,\n        'data'    : data_desc,\n        'filename': sav_filename,\n        'datetime': datetime.datetime.now().strftime('%d/%m/%Y %H:%M'),\n        'proj_method' : proj_method,\n            }\n    save_file = {\n        'data' : data,\n        'mask' : mask,\n        'grid_lat' : grid_lat,\n        'grid_lon' : grid_lon,\n        'mask_obs' : mask_obs,\n        'infos' : input_params\n                }\n    uf.save_pickle(save_file, sav_filename2, True)\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_cube","title":"<code>omega_plots.show_cube(cube, i_lam, cmap='Greys_r', vmin=None, vmax=None, cb_title='', Nfig=None)</code>","text":"<p>Display the cube from an OMEGA/MEx observation.</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>3D array</code> <p>The data cube (X, Y, wvl).</p> required <code>i_lam</code> <code>int</code> <p>The index of the selected wavelength.</p> required <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>cb_title</code> <code>str</code> <p>The title of the colorbar.</p> <code>''</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_cube(cube, i_lam, cmap='Greys_r', vmin=None, vmax=None, cb_title='', Nfig=None):\n    \"\"\"Display the cube from an OMEGA/MEx observation.\n\n    Parameters\n    ----------\n    cube : 3D array\n        The data cube (X, Y, wvl).\n    i_lam : int\n        The index of the selected wavelength.\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    cb_title : str, default ''\n        The title of the colorbar.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    \"\"\"\n    fig = plt.figure(Nfig)\n    plt.imshow(cube[:,:,i_lam], cmap=cmap, vmin=vmin, vmax=vmax,\n               aspect='equal', origin='lower', interpolation=None)\n    cb = plt.colorbar()\n    cb.set_label(cb_title)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_data_v2","title":"<code>omega_plots.show_data_v2(omega, data, cmap='viridis', vmin=None, vmax=None, alpha=None, title='auto', cb_title='data', lonlim=(None, None), latlim=(None, None), Nfig=None, polar=False, cbar=True, grid=True, mask=None, negatives_longitudes='auto', use_V_geom=False, use_L_geom=False, **kwargs)</code>","text":"<p>Display high-level data derived from an OMEGA/MEx observation with respect of the  lat/lon coordinates of the pixels, and allows to use a polar projection if desired.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>data</code> <code>2D array</code> <p>The array of the computed data values from the OMEGA observation</p> required <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>alpha</code> <code>float or None</code> <p>Opacity of the plot, from 0 (transparent) to 1 (opaque).</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>cb_title</code> <code>str</code> <p>The title of the colorbar.</p> <code>'data'</code> <code>lonlim</code> <code>tuple of int or None</code> <p>The longitude bounds of the figure.</p> <code>(None, None)</code> <code>latlim</code> <code>tuple of int or None</code> <p>The latitude bounds of the y-axis of the figure.</p> <code>(None, None)</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If <code>True</code> \u2192 Use a polar projection for the plot.</p> <code>False</code> <code>cbar</code> <code>bool</code> <p>If <code>True</code> \u2192 Display the colorbar.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Enable the display of the lat/lon grid.</p> <code>True</code> <code>mask</code> <code>2D array or None</code> <p>The array that identify the bad/corrupted pixels to remove. If <code>None</code>, all the pixels are conserved. | <code>1</code> \u2192 Good pixel | <code>NaN</code> \u2192 Bad pixel</p> <code>None</code> <code>negatives_longitudes</code> <code>str or bool</code> <p>Argument for non-polar plots. | <code>True</code> \u2192 longitudes between 0\u00b0 and 360\u00b0. | <code>False</code> \u2192 longitudes between -180\u00b0 and 180\u00b0. | <code>'auto'</code> \u2192 automatic detection of the best case.</p> <code>'auto'</code> <code>use_V_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the V-channel instead of the C-channel.</p> <code>False</code> <code>use_L_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the L-channel instead of the C-channel.</p> <code>False</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.pcolormesh()</code> function.</p> <code>{}</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_data_v2(omega, data, cmap='viridis', vmin=None, vmax=None, alpha=None, title='auto', \n                cb_title = 'data', lonlim=(None, None), latlim=(None, None), Nfig=None, \n                polar=False, cbar=True, grid=True, mask=None, negatives_longitudes='auto',\n                use_V_geom=False, use_L_geom=False, **kwargs):\n    \"\"\"Display high-level data derived from an OMEGA/MEx observation with respect of the \n    lat/lon coordinates of the pixels, and allows to use a polar projection if desired.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    data : 2D array\n        The array of the computed data values from the OMEGA observation\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    alpha : float or None, default None\n        Opacity of the plot, from 0 (transparent) to 1 (opaque).\n    title : str, default 'auto'\n        The title of the figure.\n    cb_title : str, default 'data'\n        The title of the colorbar.\n    lonlim : tuple of int or None, default (None, None)\n        The longitude bounds of the figure.\n    latlim : tuple of int or None, default (None, None)\n        The latitude bounds of the y-axis of the figure.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    polar : bool, default False\n        If `True` --&gt; Use a polar projection for the plot.\n    cbar : bool, default True\n        If `True` --&gt; Display the colorbar.\n    grid : bool, default True\n        Enable the display of the lat/lon grid.\n    mask : 2D array or None, default None\n        The array that identify the bad/corrupted pixels to remove.&lt;/br&gt;\n        If `None`, all the pixels are conserved.&lt;/br&gt;\n        | `1` --&gt; Good pixel&lt;/br&gt;\n        | `NaN` --&gt; Bad pixel\n    negatives_longitudes : str or bool, default 'auto'\n        Argument for non-polar plots.&lt;/br&gt;\n        | `True` --&gt; longitudes between 0\u00b0 and 360\u00b0.&lt;/br&gt;\n        | `False` --&gt; longitudes between -180\u00b0 and 180\u00b0.&lt;/br&gt;\n        | `'auto'` --&gt; automatic detection of the best case.\n    use_V_geom : bool, default False\n        If `True`, use the geometry of the V-channel instead of the C-channel.\n    use_L_geom : bool, default False\n        If `True`, use the geometry of the L-channel instead of the C-channel.\n    **kwargs:\n        Optional arguments for the `plt.pcolormesh()` function.\n    \"\"\"\n    if use_V_geom and use_L_geom:\n        raise ValueError(\"Cannot use both V and L geometries at the same time.\")\n    if use_V_geom:\n        omega = _switch_default_geom_to_V(omega)\n    if use_L_geom:\n        omega = _switch_default_geom_to_L(omega)\n    if isinstance(negatives_longitudes, str):\n        mask_lat = (np.abs(omega.lat) &lt; 85)\n        if (omega.lon[mask_lat] &lt; 10).any() and (omega.lon[mask_lat] &gt; 350).any():\n            negatives_longitudes = True\n    if title == 'auto':\n        title = ('OMEGA/MEx observation {0}'.format(omega.name))\n    fig = plt.figure(Nfig)\n    Nfig = fig.number   # get the actual figure number if Nfig=None\n    if not (mask is None):\n        data = deepcopy(data) * mask     # apply mask to remove bad pixels (turned to NaN)\n    if len(fig.get_axes()) != 0:    # If presence of axes\n        ax0 = fig.get_axes()[0]\n        is_ax0_polar = hasattr(ax0, 'set_theta_offset') # Test if ax has polar projection\n        if not polar == is_ax0_polar:\n            raise ValueError(\"Can not mix polar and non-polar projections in the same plot\")\n    if polar:\n        if len(fig.get_axes()) == 0:    # Test presence of axes in the figure\n            ax = plt.axes(polar=True)\n        else:\n            ax = fig.get_axes()[0]  # Do not create new axes instance\n        plt.pcolormesh(omega.lon_grid*np.pi/180, omega.lat_grid, data, cmap=cmap, \n                       alpha=alpha, vmin=vmin, vmax=vmax, **kwargs)\n        ax.set_yticklabels([])  # remove the latitude values in the plot\n        if latlim[0] is None:\n            if np.max(omega.lat) &gt; 0:\n                latlim = (90, np.min(omega.lat_grid)-1)\n            else:\n                latlim = (-90, np.max(omega.lat_grid)+1)\n        if latlim[0] &gt; 0:   # Northern hemisphere\n            ax.set_theta_offset(-np.pi/2)   # longitude origin at the bottom\n        else:               # Southern hemisphere\n            ax.set_theta_offset(np.pi/2)    # longitude origin at the top\n            ax.set_theta_direction(-1)      # clockwise theta\n        plt.xlim(lonlim)\n        plt.ylim(latlim)\n    else:\n        lon_grid2 = deepcopy(omega.lon_grid)\n        if negatives_longitudes:\n            lon_grid2[lon_grid2 &gt; 180] -= 360\n        plt.pcolormesh(lon_grid2, omega.lat_grid, data, cmap=cmap, alpha=alpha,\n                       vmin=vmin, vmax=vmax, **kwargs)\n        plt.gca().axis('equal')\n        plt.xlim(lonlim)\n        plt.ylim(latlim)\n        plt.gca().set_adjustable('box')\n        plt.xlabel('Longitude [\u00b0]')\n        plt.ylabel('Latitude [\u00b0]')\n    if cbar:\n        cb = plt.colorbar()\n        cb.set_label(cb_title)\n    plt.grid(visible=False)\n    if grid:\n        ax = plt.figure(Nfig).get_axes()[0]\n        lonlim = ax.get_xlim()\n        latlim = ax.get_ylim()\n        lon_sgn = np.sign(lonlim[1] - lonlim[0])\n        lat_sgn = np.sign(latlim[1] - latlim[0])\n        lon_grid = np.arange(np.round(lonlim[0]/10)*10, np.round(lonlim[1]/10)*10+lon_sgn, \n                    10 * lon_sgn)   # 10\u00b0 grid in longitude\n        lat_grid = np.arange(np.round(latlim[0]/10)*10, np.round(latlim[1]/10)*10+lat_sgn, \n                    10 * lat_sgn)   # 10\u00b0 grid in latitude\n        plt.grid(visible=True)\n        if polar:\n            ax.set_rticks(lat_grid)\n        else:\n            ax.set_xticks(lon_grid)\n            ax.set_yticks(lat_grid)\n    plt.title(title)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega","title":"<code>omega_plots.show_omega(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None, title='auto', xlim=(None, None), ylim=(None, None), Nfig=None, mask=None)</code>","text":"<p>Display an OMEGA/MEx observation in a rectangular pixel grid.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>lam</code> <code>float</code> <p>The selected wavelength.</p> required <code>refl</code> <code>bool</code> <p>| <code>True</code> \u2192 The reflectance is displayed. | <code>False</code> \u2192 The radiance is displayed.</p> <code>True</code> <code>lam_unit</code> <code>str</code> <p>The unit of the <code>lam</code> parameter: | <code>'m'</code> \u2192 <code>lam</code> is the wavelength value (in \u00b5m). | else \u2192 <code>lam</code> is the index of the wavelength in the <code>omega.lam</code> array (must be <code>int</code>).</p> <code>'m'</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>xlim</code> <code>tuple of int or None</code> <p>The bounds of the x-axis of the figure.</p> <code>(None, None)</code> <code>ylim</code> <code>tuple of int or None</code> <p>The bounds of the y-axis of the figure.</p> <code>(None, None)</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>mask</code> <code>2D array or None</code> <p>The array that identify the bad/corrupted pixels to remove. If <code>None</code>, all the pixels are conserved. | <code>1</code> \u2192 Good pixel | <code>NaN</code> \u2192 Bad pixel</p> <code>None</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None,\n               title='auto', xlim=(None, None), ylim=(None, None), Nfig=None, mask=None):\n    \"\"\"Display an OMEGA/MEx observation in a rectangular pixel grid.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    lam : float\n        The selected wavelength.\n    refl : bool, default True\n        | `True` --&gt; The reflectance is displayed.&lt;/br&gt;\n        | `False` --&gt; The radiance is displayed.\n    lam_unit : str, default 'm'\n        The unit of the `lam` parameter:&lt;/br&gt;\n        | `'m'` --&gt; `lam` is the wavelength value (in \u00b5m).&lt;/br&gt;\n        | else --&gt; `lam` is the index of the wavelength in the `omega.lam` array (must be `int`).\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    title : str, default 'auto'\n        The title of the figure.\n    xlim : tuple of int or None, default (None, None)\n        The bounds of the x-axis of the figure.\n    ylim : tuple of int or None, default (None, None)\n        The bounds of the y-axis of the figure.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    mask : 2D array or None, default None\n        The array that identify the bad/corrupted pixels to remove.&lt;/br&gt;\n        If `None`, all the pixels are conserved.&lt;/br&gt;\n        | `1` --&gt; Good pixel&lt;/br&gt;\n        | `NaN` --&gt; Bad pixel\n    \"\"\"\n    if ((lam_unit == 'm') or isinstance(lam, float)) and (lam &lt; 10):\n        i_lam = uf.where_closer(lam, omega.lam)\n    else:\n        i_lam = deepcopy(lam)\n    lam = omega.lam[i_lam]\n    if refl:\n        cube = deepcopy(omega.cube_rf)\n        cb_title = r'Reflectance @ $\\lambda$' + ' = {0:.2f} \u00b5m'.format(lam)\n    else:\n        cube = deepcopy(omega.cube_i)\n        cb_title = (r'Radiance [W.m$^{-2}$.sr$^{-1}$.\u00b5m$^{-1}$] at $\\lambda$' + \n                    ' = {0:.2f} \u00b5m'.format(lam))\n    if not (mask is None):\n        cube = (cube.T * mask.T).T      # apply mask to remove bad pixels (turned to NaN)\n    if title == 'auto':\n        title = 'OMEGA/MEx observation {0}\\n'.format(omega.name) \n    show_cube(cube, i_lam, cmap, vmin, vmax, cb_title, Nfig)\n    plt.xlim(xlim)\n    plt.ylim(ylim)\n    plt.title(title)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_interactif","title":"<code>omega_plots.show_omega_interactif(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None, title='auto', autoyscale=True, xlim=(None, None), ylim=(None, None))</code>","text":"<p>Interactive display of an OMEGA/MEx data cube.</p> <p>Possibility to display the spectrum associated with a pixel of the cube by clicking on it on the map (hold Ctrl to superpose multiple spectra), or by using the keyboard arrows.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>lam</code> <code>float</code> <p>The selected wavelength.</p> required <code>refl</code> <code>bool</code> <p>| <code>True</code> \u2192 The reflectance is displayed. | <code>False</code> \u2192 The radiance is displayed.</p> <code>True</code> <code>lam_unit</code> <code>str</code> <p>The unit of the <code>lam</code> parameter: | <code>'m'</code> \u2192 <code>lam</code> is the wavelength value (in \u00b5m). | else \u2192 <code>lam</code> is the index of the wavelength in the <code>omega.lam</code> array (must be <code>int</code>).</p> <code>'m'</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>xlim</code> <code>tuple of int or None</code> <p>The bounds of the x-axis of the figure.</p> <code>(None, None)</code> <code>ylim</code> <code>tuple of int or None</code> <p>The bounds of the y-axis of the figure.</p> <code>(None, None)</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_interactif(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', \n                          vmin=None, vmax=None, title='auto', autoyscale=True,\n                          xlim=(None, None), ylim=(None, None)):\n    \"\"\"Interactive display of an OMEGA/MEx data cube.\n\n    Possibility to display the spectrum associated with a pixel of the cube by\n    clicking on it on the map (hold ++ctrl++ to superpose multiple spectra),\n    or by using the keyboard arrows.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    lam : float\n        The selected wavelength.\n    refl : bool, default True\n        | `True` --&gt; The reflectance is displayed.&lt;/br&gt;\n        | `False` --&gt; The radiance is displayed.\n    lam_unit : str, default 'm'\n        The unit of the `lam` parameter:&lt;/br&gt;\n        | `'m'` --&gt; `lam` is the wavelength value (in \u00b5m).&lt;/br&gt;\n        | else --&gt; `lam` is the index of the wavelength in the `omega.lam` array (must be `int`).\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    title : str, default 'auto'\n        The title of the figure.\n    xlim : tuple of int or None, default (None, None)\n        The bounds of the x-axis of the figure.\n    ylim : tuple of int or None, default (None, None)\n        The bounds of the y-axis of the figure.\n    \"\"\"\n    # Initialisation\n    if refl:\n        yaxis = 'Reflectance'\n        cube = omega.cube_rf\n    else:\n        yaxis = r'Radiance [W.m$^{-2}$.sr$^{-1}$.\u00b5m$^{-1}$]'\n        cube = omega.cube_i\n    ny, nx, nlam = cube.shape\n    xx, yy = np.meshgrid(np.arange(nx), np.arange(ny))\n    fig1, ax1 = plt.subplots(1,1)\n    nfig = fig1.number\n    ax1.scatter(xx, yy, marker='s', s=1, picker=True, alpha=0)\n    show_omega(omega, lam, refl, lam_unit, cmap, vmin, vmax, title, \n               xlim, ylim, nfig)\n    sc_pos = []\n    if xlim[0] is None:\n        xcoord = 0\n    else:\n        xcoord = deepcopy(xlim[0])\n    if ylim[0] is None:\n        ycoord = 0\n    else:\n        ycoord = deepcopy(ylim[0])\n\n    #---------------------------------\n    # Plot spectra fig2 function\n    def plot_sp(xcoord, ycoord, clear=True):\n        nonlocal sc_pos\n        fig2 = plt.figure(-nfig)\n        if clear:\n            fig2.clf()\n            for sc in sc_pos:\n                sc.remove()\n            sc_pos = []\n        line = plt.plot(omega.lam, cube[ycoord, xcoord], \n                        label='lat = {0:.2f}\u00b0 | lon= {1:.2f}\u00b0'.format(omega.lat[ycoord, xcoord], \n                                                                      omega.lon[ycoord, xcoord]))\n        plt.xlabel(r'$\\lambda$ [\u00b5m]')\n        plt.ylabel(yaxis)\n        plt.title('OMEGA/MEx observation {0}'.format(omega.name))\n        plt.legend(loc='best')\n        ymin, ymax = fig2.get_axes()[0].get_ylim()\n        # Rescale ordonn\u00e9es\n        if autoyscale:\n            if (vmin!=None) and (ymin &gt; vmin):\n                ymin = vmin\n            if (vmax!=None) and (ymax &lt; vmax):\n                ymax = vmax\n        else:\n            ymin, ymax = vmin, vmax\n        plt.ylim(ymin, ymax)\n        fig2.canvas.draw()\n        fig2.canvas.flush_events()\n        fig2.tight_layout()\n        last_plot_color = line[0].get_color()\n        sc_pos.append(ax1.scatter(xcoord, ycoord, marker='s', s=20, color=last_plot_color))\n        fig1.canvas.draw()\n        fig1.canvas.flush_events()\n\n    #---------------------------------\n    # Picking function clic souris\n    def pick_pos(event):\n        nonlocal xcoord, ycoord\n        ctrl = event.mouseevent.key == 'control'    # test si la touche ctrl est enfonc\u00e9e\n        artist = event.artist\n        ind = event.ind[0]\n        xcoord, ycoord = artist.get_offsets()[ind]\n        xcoord, ycoord = int(xcoord), int(ycoord)\n        # if not ctrl:        # Si Ctrl enfonc\u00e9e, pas le plot pr\u00e9c\u00e9dent est conserv\u00e9\n            # plt.clf()\n        plot_sp(xcoord, ycoord, not ctrl)\n\n    #---------------------------------\n    # Picking function keyboard\n    def change_pos(event):\n        nonlocal xcoord, ycoord\n        key = event.key\n        if (0 &lt; xcoord) and (key=='left'):\n            xcoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (xcoord &lt; nx-1) and (key=='right'):\n            xcoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n        if (0 &lt; ycoord) and (key=='down'):\n            ycoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (ycoord &lt; ny-1) and (key=='up'):\n            ycoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n\n    #---------------------------------\n    # Lien avec la figure\n    cid = fig1.canvas.mpl_connect('pick_event', pick_pos)\n    cid2 = fig1.canvas.mpl_connect('key_press_event', change_pos)\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_interactif2","title":"<code>omega_plots.show_omega_interactif2(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None, title='auto', xlim=(None, None), ylim=(None, None))</code>","text":"<p>Interactive display of an OMEGA/MEx data cube.</p> <p>Possibility to display the spectrum associated with a pixel of the cube by clicking on it on the map (hold Ctrl to superpose multiple spectra), or by using the keyboard arrows.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>lam</code> <code>float</code> <p>The selected wavelength.</p> required <code>refl</code> <code>bool</code> <p>| <code>True</code> \u2192 The reflectance is displayed. | <code>False</code> \u2192 The radiance is displayed.</p> <code>True</code> <code>lam_unit</code> <code>str</code> <p>The unit of the <code>lam</code> parameter: | <code>'m'</code> \u2192 <code>lam</code> is the wavelength value (in \u00b5m). | else \u2192 <code>lam</code> is the index of the wavelength in the <code>omega.lam</code> array (must be <code>int</code>).</p> <code>'m'</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>xlim</code> <code>tuple of int or None</code> <p>The bounds of the x-axis of the figure.</p> <code>(None, None)</code> <code>ylim</code> <code>tuple of int or None</code> <p>The bounds of the y-axis of the figure.</p> <code>(None, None)</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_interactif2(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', \n                          vmin=None, vmax=None, title='auto', \n                          xlim=(None, None), ylim=(None, None)):\n    \"\"\"Interactive display of an OMEGA/MEx data cube.\n\n    Possibility to display the spectrum associated with a pixel of the cube by\n    clicking on it on the map (hold ++ctrl++ to superpose multiple spectra),\n    or by using the keyboard arrows.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    lam : float\n        The selected wavelength.\n    refl : bool, default True\n        | `True` --&gt; The reflectance is displayed.&lt;/br&gt;\n        | `False` --&gt; The radiance is displayed.\n    lam_unit : str, default 'm'\n        The unit of the `lam` parameter:&lt;/br&gt;\n        | `'m'` --&gt; `lam` is the wavelength value (in \u00b5m).&lt;/br&gt;\n        | else --&gt; `lam` is the index of the wavelength in the `omega.lam` array (must be `int`).\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    title : str, default 'auto'\n        The title of the figure.\n    xlim : tuple of int or None, default (None, None)\n        The bounds of the x-axis of the figure.\n    ylim : tuple of int or None, default (None, None)\n        The bounds of the y-axis of the figure.\n    \"\"\"\n    # Initialisation\n    if refl:\n        yaxis = 'Reflectance'\n        cube = omega.cube_rf\n    else:\n        yaxis = r'Radiance [W.m$^{-2}$.sr$^{-1}$.\u00b5m$^{-1}$]'\n        cube = omega.cube_i\n    Lam = omega.lam\n    ny, nx, nlam = cube.shape\n    xx, yy = np.meshgrid(np.arange(nx), np.arange(ny))\n    fig1, ax1 = plt.subplots(1,1)\n    nfig = fig1.number\n    ax1.scatter(xx, yy, marker='s', s=1, picker=True, alpha=0)\n    show_omega(omega, lam, refl, lam_unit, cmap, vmin, vmax, title, \n               xlim, ylim, nfig)\n    sc_pos = []\n    if xlim[0] is None:\n        xcoord = 0\n    else:\n        xcoord = deepcopy(xlim[0])\n    if ylim[0] is None:\n        ycoord = 0\n    else:\n        ycoord = deepcopy(ylim[0])\n    # Sliders\n    axcolor = 'lightgoldenrodyellow'\n    axlam = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor)\n    slam = Slider(axlam, r'$\\lambda$ [\u00b5m]', Lam[0], Lam[-1], valinit=lam, valfmt='%1.2f')\n\n    def update_img(lam):\n        # ax1.collections[0].remove()\n        # print(lam)\n        lam = slam.val\n        if ((lam_unit == 'm') or isinstance(lam, float)) and (lam &lt; 10):\n            i_lam = uf.where_closer(lam, omega.lam)\n        else:\n            i_lam = deepcopy(lam)\n        lam = omega.lam[i_lam]\n        ax1.images[0].set_array(cube[:,:,i_lam])\n        title = r'$\\lambda$' + ' = {0:.2f} \u00b5m'.format(Lam[i_lam])\n        ax1.set_title(title)\n        fig1.canvas.draw_idle()\n    slam.on_changed(update_img)\n\n    #---------------------------------\n    # Plot spectra fig2 function\n    def plot_sp(xcoord, ycoord, clear=True):\n        nonlocal sc_pos\n        fig2 = plt.figure(-nfig)\n        if clear:\n            fig2.clf()\n            for sc in sc_pos:\n                sc.remove()\n            sc_pos = []\n        line = plt.plot(omega.lam, cube[ycoord, xcoord], \n                        label='lat = {0:.2f}\u00b0 | lon= {1:.2f}\u00b0'.format(omega.lat[ycoord, xcoord], \n                                                                      omega.lon[ycoord, xcoord]))\n        plt.xlabel(r'$\\lambda$ [\u00b5m]')\n        plt.ylabel(yaxis)\n        plt.title('OMEGA/MEx observation {0}'.format(omega.name))\n        plt.legend(loc='best')\n        ymin, ymax = fig2.get_axes()[0].get_ylim()\n        # Rescale ordonn\u00e9es\n        if (vmin!=None) and (ymin &gt; vmin):\n            ymin = vmin\n        if (vmax!=None) and (ymax &lt; vmax):\n            ymax = vmax\n        plt.ylim(ymin, ymax)\n        fig2.canvas.draw()\n        fig2.canvas.flush_events()\n        fig2.tight_layout()\n        last_plot_color = line[0].get_color()\n        sc_pos.append(ax1.scatter(xcoord, ycoord, marker='s', s=20, color=last_plot_color))\n        fig1.canvas.draw()\n        fig1.canvas.flush_events()\n\n    #---------------------------------\n    # Picking function clic souris\n    def pick_pos(event):\n        nonlocal xcoord, ycoord\n        ctrl = event.mouseevent.key == 'control'    # test si la touche ctrl est enfonc\u00e9e\n        artist = event.artist\n        ind = event.ind[0]\n        xcoord, ycoord = artist.get_offsets()[ind]\n        xcoord, ycoord = int(xcoord), int(ycoord)\n        # if not ctrl:        # Si Ctrl enfonc\u00e9e, pas le plot pr\u00e9c\u00e9dent est conserv\u00e9\n            # plt.clf()\n        plot_sp(xcoord, ycoord, not ctrl)\n\n    #---------------------------------\n    # Picking function keyboard\n    def change_pos(event):\n        nonlocal xcoord, ycoord\n        key = event.key\n        if (0 &lt; xcoord) and (key=='left'):\n            xcoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (xcoord &lt; nx-1) and (key=='right'):\n            xcoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n        if (0 &lt; ycoord) and (key=='down'):\n            ycoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (ycoord &lt; ny-1) and (key=='up'):\n            ycoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n\n    #---------------------------------\n    # Lien avec la figure\n    cid = fig1.canvas.mpl_connect('pick_event', pick_pos)\n    cid2 = fig1.canvas.mpl_connect('key_press_event', change_pos)\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_interactif_v2","title":"<code>omega_plots.show_omega_interactif_v2(omega, lam=1.085, refl=True, lam_unit='m', data=None, cmap='Greys_r', cb_title='data', title='auto', vmin=None, vmax=None, autoyscale=True, ylim_sp=(None, None), alpha=None, lonlim=(None, None), latlim=(None, None), polar=False, cbar=True, grid=True, mask=None, lam_mask=None, negatives_longitudes='auto', use_V_geom=False, use_L_geom=False, **kwargs)</code>","text":"<p>Interactive display of an OMEGA/MEx data cube with respect of the lat/lon  coordinates of the pixels, and allows to use a polar projection if desired.</p> <p>Possibility to display the spectrum associated with a pixel of the cube by clicking on it on the map (hold Ctrl to superpose multiple spectra), or by using the keyboard arrows. The displayed spectra are stored in the <code>picked_spectra[nfig]</code> dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>lam</code> <code>float</code> <p>The selected wavelength.</p> <code>1.085</code> <code>refl</code> <code>bool</code> <p>| <code>True</code> \u2192 The reflectance is displayed. | <code>False</code> \u2192 The radiance is displayed.</p> <code>True</code> <code>lam_unit</code> <code>str</code> <p>The unit of the <code>lam</code> parameter: | <code>'m'</code> \u2192 <code>lam</code> is the wavelength value (in \u00b5m). | else \u2192 <code>lam</code> is the index of the wavelength in the <code>omega.lam</code> array (must be <code>int</code>).</p> <code>'m'</code> <code>data</code> <code>2D array or None</code> <p>Array of high-level data (e.g. IBD map) computed from the omega observation.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>cb_title</code> <code>str</code> <p>The title of the colorbar. Note : Only for the <code>data</code> plots.</p> <code>'data'</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>autoyscale</code> <code>bool</code> <p>| <code>True</code> \u2192 Enable the auto-scaling of the spectra y-axis. | <code>False</code> \u2192 Force use of the (vmin, vmax) bounds for the spectra plots.</p> <code>True</code> <code>ylim_sp</code> <code>tuple of float or None</code> <p>If autoyscale is False, can specify the bound values for the spectrum y-axis, other that <code>(vmin, vmax)</code>.</p> <code>(None, None)</code> <code>alpha</code> <code>float or None</code> <p>Opacity of the plot, from 0 (transparent) to 1 (opaque).</p> <code>None</code> <code>lonlim</code> <code>tuple of int or None</code> <p>The longitude bounds of the figure.</p> <code>(None, None)</code> <code>latlim</code> <code>tuple of int or None</code> <p>The latitude bounds of the y-axis of the figure.</p> <code>(None, None)</code> <code>polar</code> <code>bool</code> <p>If <code>True</code> \u2192 Use a polar projection for the plot.</p> <code>False</code> <code>cbar</code> <code>bool</code> <p>If <code>True</code> \u2192 Diplay the colorbar.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Enable the display of the lat/lon grid.</p> <code>True</code> <code>mask</code> <code>2D array or None</code> <p>The array that identify the bad/corrupted pixels to remove. If <code>None</code>, all the pixels are conserved. | <code>1</code> \u2192 Good pixel | <code>NaN</code> \u2192 Bad pixel</p> <code>None</code> <code>lam_mask</code> <code>1D array or None</code> <p>The array that identify the bad/corrupted spectels to remove. If <code>None</code>, all the spectels are conserved. | <code>True</code> \u2192 Good spectel | <code>False</code> \u2192 Bad spectel</p> <code>None</code> <code>negatives_longitudes</code> <code>str or bool</code> <p>Argument for non-polar plots. | <code>True</code> \u2192 longitudes between 0\u00b0 and 360\u00b0. | <code>False</code> \u2192 longitudes between -180\u00b0 and 180\u00b0. | <code>'auto'</code> \u2192 automatic detection of the best case.</p> <code>'auto'</code> <code>use_V_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the V-channel instead of the C-channel.</p> <code>False</code> <code>use_L_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the L-channel instead of the C-channel.</p> <code>False</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.pcolormesh()</code> function.</p> <code>{}</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_interactif_v2(omega, lam=1.085, refl=True, lam_unit='m', data=None, \n                             cmap='Greys_r', cb_title='data', title='auto',\n                             vmin=None, vmax=None, autoyscale=True, ylim_sp=(None, None),\n                             alpha=None, lonlim=(None, None), latlim=(None, None),\n                             polar=False, cbar=True, grid=True, mask=None, lam_mask=None,\n                             negatives_longitudes='auto', use_V_geom=False, use_L_geom=False, **kwargs):\n    \"\"\"Interactive display of an OMEGA/MEx data cube with respect of the lat/lon \n    coordinates of the pixels, and allows to use a polar projection if desired.\n\n    Possibility to display the spectrum associated with a pixel of the cube by\n    clicking on it on the map (hold ++ctrl++ to superpose multiple spectra),\n    or by using the keyboard arrows.&lt;/br&gt;\n    *The displayed spectra are stored in the `picked_spectra[nfig]` dictionary.*\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    lam : float, default 1.085\n        The selected wavelength.\n    refl : bool, default True\n        | `True` --&gt; The reflectance is displayed.&lt;/br&gt;\n        | `False` --&gt; The radiance is displayed.\n    lam_unit : str, default 'm'\n        The unit of the `lam` parameter:&lt;/br&gt;\n        | `'m'` --&gt; `lam` is the wavelength value (in \u00b5m).&lt;/br&gt;\n        | else --&gt; `lam` is the index of the wavelength in the `omega.lam` array (must be `int`).\n    data : 2D array or None, default None\n        Array of high-level data (e.g. IBD map) computed from the omega observation.\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    cb_title : str, default 'data'\n        The title of the colorbar.&lt;/br&gt;\n        Note : Only for the `data` plots.\n    title : str, default 'auto'\n        The title of the figure.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    autoyscale : bool, default True\n        | `True` --&gt; Enable the auto-scaling of the spectra y-axis.&lt;/br&gt;\n        | `False` --&gt; Force use of the (vmin, vmax) bounds for the spectra plots.\n    ylim_sp : tuple of float or None, default (None, None)\n        If autoyscale is False, can specify the bound values for the spectrum y-axis,\n        other that `(vmin, vmax)`.\n    alpha : float or None, default None\n        Opacity of the plot, from 0 (transparent) to 1 (opaque).\n    lonlim : tuple of int or None, default (None, None)\n        The longitude bounds of the figure.\n    latlim : tuple of int or None, default (None, None)\n        The latitude bounds of the y-axis of the figure.\n    polar : bool, default False\n        If `True` --&gt; Use a polar projection for the plot.\n    cbar : bool, default True\n        If `True` --&gt; Diplay the colorbar.\n    grid : bool, default True\n        Enable the display of the lat/lon grid.\n    mask : 2D array or None, default None\n        The array that identify the bad/corrupted pixels to remove.&lt;/br&gt;\n        If `None`, all the pixels are conserved.&lt;/br&gt;\n        | `1` --&gt; Good pixel&lt;/br&gt;\n        | `NaN` --&gt; Bad pixel\n    lam_mask : 1D array or None, default None\n        The array that identify the bad/corrupted spectels to remove.&lt;/br&gt;\n        If `None`, all the spectels are conserved.&lt;/br&gt;\n        | `True` --&gt; Good spectel&lt;/br&gt;\n        | `False` --&gt; Bad spectel\n    negatives_longitudes : str or bool, default 'auto'\n        Argument for non-polar plots.&lt;/br&gt;\n        | `True` --&gt; longitudes between 0\u00b0 and 360\u00b0.&lt;/br&gt;\n        | `False` --&gt; longitudes between -180\u00b0 and 180\u00b0.&lt;/br&gt;\n        | `'auto'` --&gt; automatic detection of the best case.\n    use_V_geom : bool, default False\n        If `True`, use the geometry of the V-channel instead of the C-channel.\n    use_L_geom : bool, default False\n        If `True`, use the geometry of the L-channel instead of the C-channel.\n    **kwargs:\n        Optional arguments for the `plt.pcolormesh()` function.\n    \"\"\"\n    if omega.point_mode != 'NADIR':\n        print(\"\\033[1m\\nWarning: The pointing mode of this cube is not NADIR, \"\n         + \"thus it may be a better idea to use a non-projected display \"\n         + \"(e.g., show_omega_interactif()).\\033[0m\")\n    if use_V_geom and use_L_geom:\n        raise ValueError(\"Cannot use both V and L geometries at the same time.\")\n    if use_V_geom:\n        omega = _switch_default_geom_to_V(omega)\n    if use_L_geom:\n        omega = _switch_default_geom_to_L(omega)\n    # Initialisation\n    if refl:\n        yaxis = 'Reflectance'\n        cube = omega.cube_rf\n    else:\n        yaxis = r'Radiance [W.m$^{-2}$.sr$^{-1}$.\u00b5m$^{-1}$]'\n        cube = omega.cube_i\n    ny, nx, nlam = cube.shape\n    if isinstance(negatives_longitudes, str):\n        mask_lat = (np.abs(omega.lat) &lt; 85)\n        if (omega.lon[mask_lat] &lt; 10).any() and (omega.lon[mask_lat] &gt; 350).any():\n            negatives_longitudes = True\n    if polar:\n        lon, lat = omega.lon*np.pi/180, omega.lat\n    else:\n        lon = deepcopy(omega.lon)\n        if negatives_longitudes:\n            lon[lon &gt; 180] -= 360\n        # lon, lat = omega.lon, omega.lat\n        lat = omega.lat\n    bij = np.zeros((ny, nx), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            bij[j,i] = 10000*j + i\n    if lam_mask is None:\n        lam_mask = np.ones(len(omega.lam), dtype=bool)\n    elif len(lam_mask) != len(omega.lam):\n        raise ValueError('omega.lam and lam_mask must have the same dimension')\n    lam2 = deepcopy(omega.lam)[lam_mask]\n    #---------------------------------\n    # Display map\n    fig1 = plt.figure()\n    nfig = fig1.number\n    if data is None:\n        show_omega_v2(omega, lam, refl, lam_unit, cmap, vmin, vmax, alpha, title, \n                      lonlim, latlim, nfig, polar, cbar, grid, mask, negatives_longitudes, \n                      use_V_geom, use_L_geom, **kwargs)\n    else:\n        show_data_v2(omega, data, cmap, vmin, vmax, alpha, title, cb_title, \n                     lonlim, latlim, nfig, polar, cbar, grid, mask, negatives_longitudes,\n                     use_V_geom, use_L_geom, **kwargs)\n    ax1 = fig1.gca()\n    ax1.scatter(lon, lat, c=bij, marker='s', s=1, picker=True, alpha=0)\n    sc_pos = []\n    if lonlim[0] is None:\n        xcoord = 0\n    else:\n        xcoord = deepcopy(lonlim[0])\n    if latlim[0] is None:\n        ycoord = 0\n    else:\n        ycoord = deepcopy(latlim[0])\n    ylim_sp = np.array(ylim_sp)\n    if ylim_sp[0] is None:\n        ylim_sp[0] = vmin\n    if ylim_sp[1] is None:\n        ylim_sp[1] = vmax\n\n    picked_spectra[nfig] = [lam2]\n\n    #---------------------------------\n    # Plot spectra fig2 function\n    def plot_sp(xcoord, ycoord, clear=True):\n        nonlocal sc_pos\n        global picked_spectra\n        fig2 = plt.figure(-nfig)\n        if clear:\n            fig2.clf()\n            picked_spectra[nfig] = [lam2]\n            for sc in sc_pos:\n                sc.remove()\n            sc_pos = []\n        sp_i = cube[ycoord, xcoord, lam_mask]\n        lati = omega.lat[ycoord, xcoord]\n        longi = omega.lon[ycoord, xcoord]\n        picked_spectra[nfig].append(sp_i)   # Stockage spectres dans variable globale\n        line = plt.plot(lam2, sp_i, \n                label='lat = {0:.2f}\u00b0N | lon = {1:.2f}\u00b0E | pixel coord = ({2:d}, {3:d})'.format(\n                                                lati, longi, ycoord, xcoord))\n        plt.xlabel(r'$\\lambda$ [\u00b5m]')\n        plt.ylabel(yaxis)\n        plt.title('OMEGA/MEx observation {0}'.format(omega.name))\n        plt.legend(loc='best')\n        ymin, ymax = fig2.get_axes()[0].get_ylim()\n        # Rescale ordonn\u00e9es\n        if autoyscale:\n            if (vmin!=None) and (ymin &gt; vmin):\n                ymin = vmin\n            if (vmax!=None) and (ymax &lt; vmax):\n                ymax = vmax\n        else:\n            ymin, ymax = ylim_sp[0], ylim_sp[1]\n        plt.ylim(ymin, ymax)\n        fig2.canvas.draw()\n        fig2.canvas.flush_events()\n        fig2.tight_layout()\n        longi2 = lon[ycoord, xcoord]    # longitude adapt\u00e9e si projection polaire\n        last_plot_color = line[0].get_color()\n        sc_pos.append(ax1.scatter(longi2, lati, marker='s', s=20, color=last_plot_color))\n        fig1.canvas.draw()\n        fig1.canvas.flush_events()\n\n    #---------------------------------\n    # Picking function clic souris\n    def pick_pos(event):\n        nonlocal xcoord, ycoord\n        ctrl = event.mouseevent.key == 'control'    # test si la touche ctrl est enfonc\u00e9e\n        artist = event.artist\n        ind = event.ind[0]\n        bij_value = artist.get_array()[ind]\n        xcoord = int(bij_value % 10000)\n        ycoord = int(bij_value // 10000)\n        plot_sp(xcoord, ycoord, not ctrl)\n\n    #---------------------------------\n    # Picking function keyboard\n    def change_pos(event):\n        nonlocal xcoord, ycoord\n        key = event.key\n        if (0 &lt; xcoord) and (key=='left'):\n            xcoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (xcoord &lt; nx-1) and (key=='right'):\n            xcoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n        if (0 &lt; ycoord) and (key=='down'):\n            ycoord -= 1\n            plot_sp(xcoord, ycoord, clear=True)\n        elif (ycoord &lt; ny-1) and (key=='up'):\n            ycoord += 1\n            plot_sp(xcoord, ycoord, clear=True)\n\n    #---------------------------------\n    # Lien avec la figure\n    cid = fig1.canvas.mpl_connect('pick_event', pick_pos)\n    cid2 = fig1.canvas.mpl_connect('key_press_event', change_pos)\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_list_v2","title":"<code>omega_plots.show_omega_list_v2(omega_list, lam=1.085, lat_min=-90, lat_max=90, lon_min=0, lon_max=360, pas_lat=0.1, pas_lon=0.1, cmap='Greys_r', vmin=None, vmax=None, title='auto', Nfig=None, polar=False, cbar=True, cb_title='auto', data_list=None, mask_list=None, negative_values=False, plot=True, grid=True, out=False, negatives_longitudes=False, proj_method=1, use_V_geom=False, use_L_geom=False, edgecolor='face', lw=0.1, **kwargs)</code>","text":"<p>Display an composite map from a list OMEGA/MEx observations, sampled on a new lat/lon grid.</p> <p>Parameters:</p> Name Type Description Default <code>omega_list</code> <code>array of OMEGAdata</code> <p>The list of OMEGA/MEx observations.</p> required <code>lam</code> <code>float</code> <p>The selected wavelength (in \u00b5m).</p> <code>1.085</code> <code>lat_min</code> <code>float</code> <p>The minimal latitude of the grid.</p> <code>-90</code> <code>lat_max</code> <code>float</code> <p>The maximum latitude of the grid.</p> <code>90</code> <code>lon_min</code> <code>float</code> <p>The minimal longitude of the grid.</p> <code>0</code> <code>lon_max</code> <code>float</code> <p>The maximal longitude of the grid.</p> <code>360</code> <code>pas_lat</code> <code>float</code> <p>The latitude intervals of the grid.</p> <code>0.1</code> <code>pas_lon</code> <code>float</code> <p>The longitude intervals of the grid.</p> <code>0.1</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If <code>True</code> \u2192 Use a polar projection for the plot.</p> <code>False</code> <code>cbar</code> <code>bool</code> <p>If <code>True</code> \u2192 Diplay the colorbar.</p> <code>True</code> <code>cb_title</code> <code>str</code> <p>The title of the colorbar.</p> <code>'auto'</code> <code>data_list</code> <code>3D array or None</code> <p>1D array of the same dimension of <code>omega_list</code> containing alternative maps (2D arrays), in the same order than the observations of <code>omega_list</code>.</p> <code>None</code> <code>mask_list</code> <code>3D array or None</code> <p>1D array of the same dimension of <code>omega_list</code> containing the masks to remove the corrupted pixels of each observaiton, in the same order than the observations of  <code>omega_list</code>. Each mask is a 2D array, filled with 1 for good pixels and NaN for bad ones.</p> <code>None</code> <code>negative_values</code> <code>bool</code> <p>Set if the negative values are considered as relevant data or not.</p> <code>False</code> <code>plot</code> <code>bool</code> <p>If <code>True</code> \u2192 Diplay the final figure.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Enable the display of the lat/lon grid.</p> <code>True</code> <code>out</code> <code>bool</code> <p>If <code>True</code> \u2192 Return output.</p> <code>False</code> <code>negatives_longitudes</code> <code>bool</code> <p>Argument for non-polar plots. | <code>True</code> \u2192 longitudes between 0\u00b0 and 360\u00b0. | <code>False</code> \u2192 longitudes between -180\u00b0 and 180\u00b0.</p> <code>False</code> <code>proj_method</code> <code>int</code> <p>Select the projection method used (1 or 2). | <code>1</code> \u2192 Consider only the center point of each pixel.        Faster but not adapted if the grid resolution is lower than the OMEGA pixels size. | <code>2</code> \u2192 Consider the entire spatial extent of each pixel.        More accurate, but take more time.</p> <code>1</code> <code>use_V_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the V-channel instead of the C-channel.</p> <code>False</code> <code>use_L_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the L-channel instead of the C-channel.</p> <code>False</code> <code>edgecolor</code> <code>'none', None, 'face', color', color sequence</code> <p>The color of the edges, see documentation of <code>plt.pcolormesh</code> for more details. Added in version 2.2.8 to fix display due for new version of matplotlib.</p> <p>Should be set to <code>face</code> if using projection method <code>1</code>,  or <code>none</code> for projection method <code>2</code>.</p> <code>'none'</code> <code>lw</code> <code>float</code> <p>The line width of the edges (if displayed).</p> <code>0.1</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.pcolormesh()</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>data</code> <code>2D array (dim : Nlon x Nlat)</code> <p>The omega reflectance at lam, sampled on the new lat/lon grid.</p> <code>mask</code> <code>2D array</code> <p>The array indicating where the new grid has been filled by the OMEGA data.</p> <code>grid_lat</code> <code>2D array</code> <p>The new latitude grid.</p> <code>grid_lon</code> <code>2D array</code> <p>The new longitude grid.</p> <code>mask_obs</code> <code>2D array of str</code> <p>The array indicating which observations have been used to fill each grid position.</p> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_list_v2(omega_list, lam=1.085, lat_min=-90, lat_max=90, lon_min=0, lon_max=360,\n                       pas_lat=0.1, pas_lon=0.1, cmap='Greys_r', vmin=None, vmax=None, \n                       title='auto', Nfig=None, polar=False, cbar=True, cb_title='auto',\n                       data_list=None, mask_list=None, negative_values=False, plot=True, \n                       grid=True, out=False, negatives_longitudes=False, proj_method=1,\n                       use_V_geom=False, use_L_geom=False, edgecolor='face', lw=0.1, **kwargs):\n    \"\"\"Display an composite map from a list OMEGA/MEx observations, sampled on a new lat/lon grid.\n\n    Parameters\n    ----------\n    omega_list : array of OMEGAdata\n        The list of OMEGA/MEx observations.\n    lam : float, default 1.085\n        The selected wavelength (in \u00b5m).\n    lat_min : float, default -90\n        The minimal latitude of the grid.\n    lat_max : float, default 90\n        The maximum latitude of the grid.\n    lon_min : float, default 0\n        The minimal longitude of the grid.\n    lon_max : float, default 360\n        The maximal longitude of the grid.\n    pas_lat : float, default 0.1\n        The latitude intervals of the grid.\n    pas_lon : float, default 0.1\n        The longitude intervals of the grid.\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    title : str, default 'auto'\n        The title of the figure.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    polar : bool, default False\n        If `True` --&gt; Use a polar projection for the plot.\n    cbar : bool, default True\n        If `True` --&gt; Diplay the colorbar.\n    cb_title : str, default 'auto'\n        The title of the colorbar.\n    data_list : 3D array or None, default None\n        1D array of the same dimension of `omega_list` containing alternative maps (2D arrays),\n        in the **same order** than the observations of `omega_list`.\n    mask_list : 3D array or None, default None\n        1D array of the same dimension of `omega_list` containing the masks to remove the\n        corrupted pixels of each observaiton, in the **same order** than the observations of \n        `omega_list`.&lt;/br&gt;\n        Each mask is a 2D array, filled with 1 for good pixels and NaN for bad ones.\n    negative_values : bool, default False\n        Set if the negative values are considered as relevant data or not.\n    plot : bool, default True\n        If `True` --&gt; Diplay the final figure.\n    grid : bool, default True\n        Enable the display of the lat/lon grid.\n    out : bool, default False\n        If `True` --&gt; Return output.\n    negatives_longitudes : bool, default False\n        Argument for non-polar plots.&lt;/br&gt;\n        | `True` --&gt; longitudes between 0\u00b0 and 360\u00b0.&lt;/br&gt;\n        | `False` --&gt; longitudes between -180\u00b0 and 180\u00b0.\n    proj_method : int, default 1\n        Select the projection method used (1 or 2).&lt;/br&gt;\n        | `1` --&gt; Consider only the center point of each pixel.&lt;br&gt;\n               Faster but not adapted if the grid resolution is lower than the OMEGA pixels size.&lt;/br&gt;\n        | `2` --&gt; Consider the entire spatial extent of each pixel.&lt;/br&gt;\n               More accurate, but take more time.\n    use_V_geom : bool, default False\n        If `True`, use the geometry of the V-channel instead of the C-channel.\n    use_L_geom : bool, default False\n        If `True`, use the geometry of the L-channel instead of the C-channel.\n    edgecolor : {'none', None, 'face', color', color sequence}, default 'face'\n        The color of the edges, see documentation of `plt.pcolormesh` for more details.&lt;/br&gt;\n        *Added in version 2.2.8 to fix display due for new version of matplotlib.*&lt;/br&gt;\n        &gt; Should be set to `face` if using projection method `1`, \n        or `none` for projection method `2`.\n    lw : float, default 0.1\n        The line width of the edges (if displayed).\n    **kwargs:\n        Optional arguments for the `plt.pcolormesh()` function.\n\n    Returns\n    -------\n    data : 2D array (dim : Nlon x Nlat)\n        The omega reflectance at lam, sampled on the new lat/lon grid.\n    mask : 2D array\n        The array indicating where the new grid has been filled by the OMEGA data.\n    grid_lat : 2D array\n        The new latitude grid.\n    grid_lon : 2D array\n        The new longitude grid.\n    mask_obs : 2D array of str\n        The array indicating which observations have been used to fill each grid position.\n    \"\"\"\n    if proj_method not in [1, 2]:\n        raise ValueError(\"`proj_method` must be 1 (pixel centers) or 2 (polygons).\")\n    if use_V_geom and use_L_geom:\n        raise ValueError(\"Cannot use both V and L geometries at the same time.\")\n    # Sampling on same grid\n    lat_array = np.arange(lat_min, lat_max+pas_lat, pas_lat)\n    lon_array = np.arange(lon_min, lon_max+pas_lon, pas_lon)\n    Nlon, Nlat = len(lon_array)-1, len(lat_array)-1\n    grid_lat, grid_lon = np.meshgrid(lat_array, lon_array)\n    data, mask = np.zeros((Nlon, Nlat)), np.zeros((Nlon, Nlat))\n    mask_obs = np.ndarray((Nlon, Nlat), dtype=object)\n    mask_obs.fill('')\n    if not (mask_list is None):\n        check_list_mask_omega(omega_list, mask_list, disp=True)\n    if data_list is None:\n        for i, omega in enumerate(tqdm(omega_list)):\n            if use_V_geom:\n                omega = _switch_default_geom_to_V(omega)\n            if use_L_geom:\n                omega = _switch_default_geom_to_L(omega)\n            i_lam = uf.where_closer(lam, omega.lam)\n            if mask_list is None:\n                data_tmp = omega.cube_rf[:,:,i_lam]     # Reflectance without mask\n            else:\n                data_tmp = omega.cube_rf[:,:,i_lam] * mask_list[i]  # Reflectance with mask\n            if proj_method == 1:\n                data0, mask0 = proj_grid(omega, data_tmp, lat_min, lat_max,\n                                        lon_min, lon_max, pas_lat, pas_lon, negative_values)[:2]\n            else:\n                data0, mask0 = proj_grid2(omega, data_tmp, lat_min, lat_max,\n                                         lon_min, lon_max, pas_lat, pas_lon, negative_values)[:2]\n            data += np.nan_to_num(data0)    # Conversion NaN -&gt; 0 pour somme des images\n            mask += mask0\n            mask_obs[mask0 == 1] += (omega.name + ',')\n    else:\n        check_list_data_omega(omega_list, data_list, disp=True)\n        for i, omega in enumerate(tqdm(omega_list)):\n            if use_V_geom:\n                omega = _switch_default_geom_to_V(omega)\n            if use_L_geom:\n                omega = _switch_default_geom_to_L(omega)\n            if mask_list is None:\n                data_tmp = data_list[i]     # Data without mask\n            else:\n                data_tmp = data_list[i] * mask_list[i]  # Data with mask\n            if proj_method == 1:\n                data0, mask0 = proj_grid(omega, data_tmp, lat_min, lat_max,\n                                        lon_min, lon_max, pas_lat, pas_lon, negative_values)[:2]\n            else:\n                data0, mask0 = proj_grid2(omega, data_tmp, lat_min, lat_max,\n                                         lon_min, lon_max, pas_lat, pas_lon, negative_values)[:2]\n            data += np.nan_to_num(data0)    # Conversion NaN -&gt; 0 pour somme des images\n            mask += mask0\n            mask_obs[mask0 == 1] += (omega.name + ',')\n    data[mask == 0] = np.nan\n    data2 = data/mask   # Normalisation\n    # Affichage figure\n    if plot:\n        if title == 'auto':\n            title = 'Composite map from OMEGA/MEx observations' \n        fig = plt.figure(Nfig)\n        Nfig = fig.number   # get the actual figure number if Nfig=None\n        if polar:\n            ax = plt.axes(polar=True)\n            plt.pcolormesh(grid_lon*np.pi/180, grid_lat, data2, cmap=cmap, \n                        vmin=vmin, vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n            ax.set_yticklabels([])  # remove the latitude values in the plot\n            plt.xlim(0, 2*np.pi)\n            if np.abs(lat_max) &gt;= np.abs(lat_min):\n                latlim = (lat_max, lat_min)\n            else:\n                latlim = (lat_min, lat_max)\n            if latlim[0] &gt; 0:   # Northern hemisphere\n                ax.set_theta_offset(-np.pi/2)   # longitude origin at the bottom\n            else:               # Southern hemisphere\n                ax.set_theta_offset(np.pi/2)    # longitude origin at the top\n                ax.set_theta_direction(-1)      # clockwise theta\n            plt.ylim(latlim)\n        else:\n            if negatives_longitudes and (lon_max &gt; 180):\n                n_neg_lon = np.sum(grid_lon[:,0] &gt; 180) # nb of negative longitudes (&gt;180\u00b0)\n                i_lon180 = np.where(grid_lon[:,0] &gt; 180)[0][0] # 1st index of lon &gt; 180\u00b0\n                grid_lon_nl = deepcopy(grid_lon)        # new longitude grid [-180\u00b0, 180\u00b0]\n                grid_lon_nl[:n_neg_lon] = grid_lon[i_lon180-1:-1] - 360\n                grid_lon_nl[n_neg_lon:] = grid_lon[:i_lon180]\n                data2_nl = deepcopy(data2)      # new data array\n                data2_nl[:n_neg_lon] = data2[i_lon180-1:]\n                data2_nl[n_neg_lon:] = data2[:i_lon180-1]\n                plt.pcolormesh(grid_lon_nl, grid_lat, data2_nl, cmap=cmap, vmin=vmin, \n                               vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n                lon_min, lon_max = grid_lon_nl[[0,-1], 0]   # new longitude bounds\n            else:\n                plt.pcolormesh(grid_lon, grid_lat, data2, cmap=cmap, vmin=vmin, \n                               vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n            plt.gca().axis('equal')\n            plt.gca().set_adjustable('box')\n            plt.xlabel('Longitude [\u00b0]')\n            plt.ylabel('Latitude [\u00b0]')\n            plt.xlim(lon_min, lon_max)\n            plt.ylim(lat_min, lat_max)\n        if cbar:\n            if cb_title == 'auto':\n                cb_title = r'Reflectance @ $\\lambda$' + ' = {0:.2f} \u00b5m'.format(lam)\n            cb = plt.colorbar()\n            cb.set_label(cb_title)\n        plt.grid(visible=False)\n        if grid:\n            ax = plt.figure(Nfig).get_axes()[0]\n            lonlim = ax.get_xlim()\n            latlim = ax.get_ylim()\n            lon_sgn = np.sign(lonlim[1] - lonlim[0])\n            lat_sgn = np.sign(latlim[1] - latlim[0])\n            lon_grid = np.arange(np.round(lonlim[0]/10)*10, np.round(lonlim[1]/10)*10+lon_sgn, \n                        10 * lon_sgn)   # 10\u00b0 grid in longitude\n            lat_grid = np.arange(np.round(latlim[0]/10)*10, np.round(latlim[1]/10)*10+lat_sgn, \n                        10 * lat_sgn)   # 10\u00b0 grid in latitude\n            plt.grid(visible=True)\n            if polar:\n                ax.set_rticks(lat_grid)\n            else:\n                ax.set_xticks(lon_grid)\n                ax.set_yticks(lat_grid)\n        plt.title(title)\n        plt.tight_layout()\n    # Output\n    if out:\n        mask2 = np.clip(mask, 0, 1)\n        return data2, mask2, grid_lat, grid_lon, mask_obs\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_list_v2_man","title":"<code>omega_plots.show_omega_list_v2_man(data, grid_lat, grid_lon, infos, cmap='Greys_r', vmin=None, vmax=None, title='auto', Nfig=None, polar=False, cbar=True, cb_title='auto', grid=True, negatives_longitudes=False, edgecolor='face', lw=0.1, **kwargs)</code>","text":"<p>Display an composite map from a list OMEGA/MEx observations, previously sampled on  a new lat/lon grid with <code>show_omega_list_v2()</code> and saved with <code>save_map_omega_list()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>2D array</code> <p>The omega reflectance at lam, sampled on the new lat/lon grid.</p> required <code>grid_lat</code> <code>2D array</code> <p>The new latitude grid.</p> required <code>grid_lon</code> <code>2D array</code> <p>The new longitude grid.</p> required <code>infos</code> <code>dict</code> <p>The informations about the computation of the data.</p> required <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If <code>True</code> \u2192 Use a polar projection for the plot.</p> <code>False</code> <code>cbar</code> <code>bool</code> <p>If <code>True</code> \u2192 Diplay the colorbar.</p> <code>True</code> <code>cb_title</code> <code>str</code> <p>The title of the colorbar.</p> <code>'auto'</code> <code>grid</code> <code>bool</code> <p>Enable the display of the lat/lon grid.</p> <code>True</code> <code>negatives_longitudes</code> <code>bool</code> <p>Argument for non-polar plots. | <code>True</code> \u2192 longitudes between 0\u00b0 and 360\u00b0. | <code>False</code> \u2192 longitudes between -180\u00b0 and 180\u00b0.</p> <code>False</code> <code>edgecolor</code> <code>'none', None, 'face', color', color sequence</code> <p>The color of the edges, see documentation of plt.pcolormesh for more details. Added in version 2.2.8 to fix display due for new version of matplotlib.</p> <p>Should be set to <code>face</code> if using projection method <code>1</code>,  or <code>none</code> for projection method <code>2</code>.</p> <code>'none'</code> <code>lw</code> <code>float</code> <p>The line width of the edges (if displayed).</p> <code>0.1</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.pcolormesh()</code> function.</p> <code>{}</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_list_v2_man(data, grid_lat, grid_lon, infos, cmap='Greys_r', vmin=None, vmax=None, \n                           title='auto', Nfig=None, polar=False, cbar=True, cb_title='auto',\n                           grid=True, negatives_longitudes=False,\n                           edgecolor='face', lw=0.1, **kwargs):\n    \"\"\"Display an composite map from a list OMEGA/MEx observations, previously sampled on \n    a new lat/lon grid with `show_omega_list_v2()` and saved with `save_map_omega_list()`.\n\n    Parameters\n    ----------\n    data : 2D array\n        The omega reflectance at lam, sampled on the new lat/lon grid.\n    grid_lat : 2D array\n        The new latitude grid.\n    grid_lon : 2D array\n        The new longitude grid.\n    infos : dict\n        The informations about the computation of the data.\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    title : str, default 'auto'\n        The title of the figure.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    polar : bool, default False\n        If `True` --&gt; Use a polar projection for the plot.\n    cbar : bool, default True\n        If `True` --&gt; Diplay the colorbar.\n    cb_title : str, default 'auto'\n        The title of the colorbar.\n    grid : bool, default True\n        Enable the display of the lat/lon grid.\n    negatives_longitudes : bool, default False\n        Argument for non-polar plots.&lt;/br&gt;\n        | `True` --&gt; longitudes between 0\u00b0 and 360\u00b0.&lt;/br&gt;\n        | `False` --&gt; longitudes between -180\u00b0 and 180\u00b0.\n    edgecolor : {'none', None, 'face', color', color sequence}, default 'face'\n        The color of the edges, see documentation of plt.pcolormesh for more details.&lt;/br&gt;\n        *Added in version 2.2.8 to fix display due for new version of matplotlib.*&lt;/br&gt;\n        &gt; Should be set to `face` if using projection method `1`, \n        or `none` for projection method `2`.\n    lw : float, default 0.1\n        The line width of the edges (if displayed).\n    **kwargs:\n        Optional arguments for the `plt.pcolormesh()` function.\n    \"\"\"\n    lat_min, lat_max = infos['lat_min'], infos['lat_max']\n    lon_min, lon_max = infos['lon_min'], infos['lon_max']\n    if title == 'auto':\n        title = 'Composite map from OMEGA/MEx observations' \n    fig = plt.figure(Nfig)\n    Nfig = fig.number   # get the actual figure number if Nfig=None\n    if polar:\n        ax = plt.axes(polar=True)\n        plt.pcolormesh(grid_lon*np.pi/180, grid_lat, data, cmap=cmap, \n                    vmin=vmin, vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n        ax.set_yticklabels([])  # remove the latitude values in the plot\n        plt.xlim(0, 2*np.pi)\n        if np.abs(lat_max) &gt;= np.abs(lat_min):\n            latlim = (lat_max, lat_min)\n        else:\n            latlim = (lat_min, lat_max)\n        if latlim[0] &gt; 0:   # Northern hemisphere\n            ax.set_theta_offset(-np.pi/2)   # longitude origin at the bottom\n        else:               # Southern hemisphere\n            ax.set_theta_offset(np.pi/2)    # longitude origin at the top\n            ax.set_theta_direction(-1)      # clockwise theta\n        plt.ylim(latlim)\n    else:\n        if negatives_longitudes and (lon_max &gt; 180):\n            n_neg_lon = np.sum(grid_lon[:,0] &gt; 180) # nb of negative longitudes (&gt;180\u00b0)\n            i_lon180 = np.where(grid_lon[:,0] &gt; 180)[0][0] # 1st index of lon &gt; 180\u00b0\n            grid_lon_nl = deepcopy(grid_lon)        # new longitude grid [-180\u00b0, 180\u00b0]\n            grid_lon_nl[:n_neg_lon] = grid_lon[i_lon180-1:-1] - 360\n            grid_lon_nl[n_neg_lon:] = grid_lon[:i_lon180]\n            data_nl = deepcopy(data)      # new data array\n            data_nl[:n_neg_lon] = data[i_lon180-1:]\n            data_nl[n_neg_lon:] = data[:i_lon180-1]\n            plt.pcolormesh(grid_lon_nl, grid_lat, data_nl, cmap=cmap, vmin=vmin, \n                           vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n            lon_min, lon_max = grid_lon_nl[[0,-1], 0]   # new longitude bounds\n        else:\n            plt.pcolormesh(grid_lon, grid_lat, data, cmap=cmap, vmin=vmin, \n                           vmax=vmax, edgecolor=edgecolor, lw=lw, **kwargs)\n        plt.gca().axis('equal')\n        plt.gca().set_adjustable('box')\n        plt.xlabel('Longitude [\u00b0]')\n        plt.ylabel('Latitude [\u00b0]')\n        plt.xlim(lon_min, lon_max)\n        plt.ylim(lat_min, lat_max)\n    if cbar:\n        if cb_title == 'auto':\n            cb_title = infos['data']\n        cb = plt.colorbar()\n        cb.set_label(cb_title)\n    plt.grid(visible=False)\n    if grid:\n        ax = plt.figure(Nfig).get_axes()[0]\n        lonlim = ax.get_xlim()\n        latlim = ax.get_ylim()\n        lon_sgn = np.sign(lonlim[1] - lonlim[0])\n        lat_sgn = np.sign(latlim[1] - latlim[0])\n        lon_grid = np.arange(np.round(lonlim[0]/10)*10, np.round(lonlim[1]/10)*10+lon_sgn, \n                    10 * lon_sgn)   # 10\u00b0 grid in longitude\n        lat_grid = np.arange(np.round(latlim[0]/10)*10, np.round(latlim[1]/10)*10+lat_sgn, \n                    10 * lat_sgn)   # 10\u00b0 grid in latitude\n        plt.grid(visible=True)\n        if polar:\n            ax.set_rticks(lat_grid)\n        else:\n            ax.set_xticks(lon_grid)\n            ax.set_yticks(lat_grid)\n    plt.title(title)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/omega_plots/#omega_plots.show_omega_v2","title":"<code>omega_plots.show_omega_v2(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None, alpha=None, title='auto', lonlim=(None, None), latlim=(None, None), Nfig=None, polar=False, cbar=True, grid=True, mask=None, negatives_longitudes='auto', use_V_geom=False, use_L_geom=False, **kwargs)</code>","text":"<p>Display an OMEGA/MEx observation with respect of the lat/lon coordinates of the pixels, and allows to use a polar projection if desired.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>OMEGAdata</code> <p>The OMEGA/MEx observation</p> required <code>lam</code> <code>float</code> <p>The selected wavelength.</p> required <code>refl</code> <code>bool</code> <p>| <code>True</code> \u2192 The reflectance is displayed. | <code>False</code> \u2192 The radiance is displayed.</p> <code>True</code> <code>lam_unit</code> <code>str</code> <p>The unit of the <code>lam</code> parameter: | <code>'m'</code> \u2192 <code>lam</code> is the wavelength value (in \u00b5m). | else \u2192 <code>lam</code> is the index of the wavelength in the <code>omega.lam</code> array (must be <code>int</code>).</p> <code>'m'</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap.</p> <code>'Greys_r'</code> <code>vmin</code> <code>float or None</code> <p>The lower bound of the colorscale.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>The upper bound of the colorscale.</p> <code>None</code> <code>alpha</code> <code>float or None</code> <p>Opacity of the plot, from 0 (transparent) to 1 (opaque).</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the figure.</p> <code>'auto'</code> <code>lonlim</code> <code>tuple of int or None</code> <p>The longitude bounds of the figure.</p> <code>(None, None)</code> <code>latlim</code> <code>tuple of int or None</code> <p>The latitude bounds of the y-axis of the figure.</p> <code>(None, None)</code> <code>Nfig</code> <code>int or str or None</code> <p>The target figure ID.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If <code>True</code> \u2192 Use a polar projection for the plot.</p> <code>False</code> <code>cbar</code> <code>bool</code> <p>If <code>True</code> \u2192 Diplay the colorbar.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Enable the display of the lat/lon grid.</p> <code>True</code> <code>mask</code> <code>2D array or None</code> <p>The array that identify the bad/corrupted pixels to remove. If None, all the pixels are conserved. | <code>1</code> \u2192 Good pixel | <code>NaN</code> \u2192 Bad pixel</p> <code>None</code> <code>negatives_longitudes</code> <code>str or bool</code> <p>Argument for non-polar plots. | <code>True</code> \u2192 longitudes between 0\u00b0 and 360\u00b0. | <code>False</code> \u2192 longitudes between -180\u00b0 and 180\u00b0. | <code>'auto'</code> \u2192 automatic detection of the best case.</p> <code>'auto'</code> <code>use_V_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the V-channel instead of the C-channel.</p> <code>False</code> <code>use_L_geom</code> <code>bool</code> <p>If <code>True</code>, use the geometry of the L-channel instead of the C-channel.</p> <code>False</code> <code>**kwargs</code> <p>Optional arguments for the <code>plt.pcolormesh()</code> function.</p> <code>{}</code> Source code in <code>omegapy/omega_plots.py</code> <pre><code>def show_omega_v2(omega, lam, refl=True, lam_unit='m', cmap='Greys_r', vmin=None, vmax=None,\n                  alpha=None, title='auto', lonlim=(None, None), latlim=(None, None), Nfig=None,\n                  polar=False, cbar=True, grid=True, mask=None, negatives_longitudes='auto',\n                  use_V_geom=False, use_L_geom=False, **kwargs):\n    \"\"\"Display an OMEGA/MEx observation with respect of the lat/lon coordinates of the pixels,\n    and allows to use a polar projection if desired.\n\n    Parameters\n    ----------\n    omega : OMEGAdata\n        The OMEGA/MEx observation\n    lam : float\n        The selected wavelength.\n    refl : bool, default True\n        | `True` --&gt; The reflectance is displayed.&lt;/br&gt;\n        | `False` --&gt; The radiance is displayed.\n    lam_unit : str, default 'm'\n        The unit of the `lam` parameter:&lt;/br&gt;\n        | `'m'` --&gt; `lam` is the wavelength value (in \u00b5m).&lt;/br&gt;\n        | else --&gt; `lam` is the index of the wavelength in the `omega.lam` array (must be `int`).\n    cmap : str, default 'Greys_r'\n        The matplotlib colormap.\n    vmin : float or None, default None\n        The lower bound of the colorscale.\n    vmax : float or None, default None\n        The upper bound of the colorscale.\n    alpha : float or None, default None\n        Opacity of the plot, from 0 (transparent) to 1 (opaque).\n    title : str, default 'auto'\n        The title of the figure.\n    lonlim : tuple of int or None, default (None, None)\n        The longitude bounds of the figure.\n    latlim : tuple of int or None, default (None, None)\n        The latitude bounds of the y-axis of the figure.\n    Nfig : int or str or None, default None\n        The target figure ID.\n    polar : bool, default False\n        If `True` --&gt; Use a polar projection for the plot.\n    cbar : bool, default True\n        If `True` --&gt; Diplay the colorbar.\n    grid : bool, default True\n        Enable the display of the lat/lon grid.\n    mask : 2D array or None, default None\n        The array that identify the bad/corrupted pixels to remove.&lt;/br&gt;\n        If None, all the pixels are conserved.&lt;/br&gt;\n        | `1` --&gt; Good pixel&lt;/br&gt;\n        | `NaN` --&gt; Bad pixel\n    negatives_longitudes : str or bool, default 'auto'\n        Argument for non-polar plots.&lt;/br&gt;\n        | `True` --&gt; longitudes between 0\u00b0 and 360\u00b0.&lt;/br&gt;\n        | `False` --&gt; longitudes between -180\u00b0 and 180\u00b0.&lt;/br&gt;\n        | `'auto'` --&gt; automatic detection of the best case.\n    use_V_geom : bool, default False\n        If `True`, use the geometry of the V-channel instead of the C-channel.\n    use_L_geom : bool, default False\n        If `True`, use the geometry of the L-channel instead of the C-channel.\n    **kwargs:\n        Optional arguments for the `plt.pcolormesh()` function.\n    \"\"\"\n    if use_V_geom and use_L_geom:\n        raise ValueError(\"Cannot use both V and L geometries at the same time.\")\n    if use_V_geom:\n        omega = _switch_default_geom_to_V(omega)\n    if use_L_geom:\n        omega = _switch_default_geom_to_L(omega)\n    if ((lam_unit == 'm') or isinstance(lam, float)) and (lam &lt; 10):\n        i_lam = uf.where_closer(lam, omega.lam)\n    else:\n        i_lam = deepcopy(lam)\n    lam = omega.lam[i_lam]\n    if refl:\n        cube = deepcopy(omega.cube_rf)\n        cb_title = r'Reflectance @ $\\lambda$' + ' = {0:.2f} \u00b5m'.format(lam)\n    else:\n        cube = deepcopy(omega.cube_i)\n        cb_title = (r'Radiance [W.m$^{-2}$.sr$^{-1}$.\u00b5m$^{-1}$] at $\\lambda$' + \n                    ' = {0:.2f} \u00b5m'.format(lam))\n    cube_map = cube[:, :, i_lam]    # extracted map to display\n    if not (mask is None):\n        cube_map *= mask    # apply mask to remove bad pixels (turned to NaN)\n    if title == 'auto':\n        title = 'OMEGA/MEx observation {0}'.format(omega.name) \n    if isinstance(negatives_longitudes, str):\n        mask_lat = (np.abs(omega.lat) &lt; 85)\n        if (omega.lon[mask_lat] &lt; 10).any() and (omega.lon[mask_lat] &gt; 350).any():\n            negatives_longitudes = True\n    fig = plt.figure(Nfig)\n    Nfig = fig.number   # get the actual figure number if Nfig=None\n    if len(fig.get_axes()) != 0:    # If presence of axes\n        ax0 = fig.get_axes()[0]\n        is_ax0_polar = hasattr(ax0, 'set_theta_offset') # Test if ax has polar projection\n        if not polar == is_ax0_polar:\n            raise ValueError(\"Can not mix polar and non-polar projections in the same plot\")\n    if polar:\n        if len(fig.get_axes()) == 0:    # Test presence of axes in the figure\n            ax = plt.axes(polar=True)\n        else:\n            ax = fig.get_axes()[0]  # Do not create new axes instance\n        plt.pcolormesh(omega.lon_grid*np.pi/180, omega.lat_grid, cube_map, cmap=cmap, \n                       alpha=alpha, vmin=vmin, vmax=vmax, **kwargs)\n        ax.set_yticklabels([])  # remove the latitude values in the plot\n        if latlim[0] is None:\n            if np.max(omega.lat) &gt; 0:\n                latlim = (90, np.min(omega.lat_grid)-1)\n            else:\n                latlim = (-90, np.max(omega.lat_grid)+1)\n        if latlim[0] &gt; 0:   # Northern hemisphere\n            ax.set_theta_offset(-np.pi/2)   # longitude origin at the bottom\n        else:               # Southern hemisphere\n            ax.set_theta_offset(np.pi/2)    # longitude origin at the top\n            ax.set_theta_direction(-1)      # clockwise theta\n        plt.xlim(lonlim)\n        plt.ylim(latlim)\n    else:\n        lon_grid2 = deepcopy(omega.lon_grid)\n        if negatives_longitudes:\n            lon_grid2[lon_grid2 &gt; 180] -= 360\n        plt.pcolormesh(lon_grid2, omega.lat_grid, cube_map, cmap=cmap, alpha=alpha,\n                       vmin=vmin, vmax=vmax, **kwargs)\n        plt.gca().axis('equal')\n        plt.xlim(lonlim)\n        plt.ylim(latlim)\n        plt.gca().set_adjustable('box')\n        plt.xlabel('Longitude [\u00b0]')\n        plt.ylabel('Latitude [\u00b0]')\n    if cbar:\n        cb = plt.colorbar()\n        cb.set_label(cb_title)\n    plt.grid(visible=False)\n    if grid:\n        ax = plt.figure(Nfig).get_axes()[0]\n        lonlim = ax.get_xlim()\n        latlim = ax.get_ylim()\n        lon_sgn = np.sign(lonlim[1] - lonlim[0])\n        lat_sgn = np.sign(latlim[1] - latlim[0])\n        lon_grid = np.arange(np.round(lonlim[0]/10)*10, np.round(lonlim[1]/10)*10+lon_sgn, \n                    10 * lon_sgn)   # 10\u00b0 grid in longitude\n        lat_grid = np.arange(np.round(latlim[0]/10)*10, np.round(latlim[1]/10)*10+lat_sgn, \n                    10 * lat_sgn)   # 10\u00b0 grid in latitude\n        plt.grid(visible=True)\n        if polar:\n            ax.set_rticks(lat_grid)\n        else:\n            ax.set_xticks(lon_grid)\n            ax.set_yticks(lat_grid)\n    plt.title(title)\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/useful_functions/","title":"useful_functions","text":"<p>Useful generics functions.</p>"},{"location":"reference/useful_functions/#useful_functions.degre2","title":"<code>useful_functions.degre2(x, a, b, c)</code>","text":"<p>2<sup>nd</sup> degree polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like or float</code> required <code>a</code> <code>float</code> required <code>b</code> <code>float</code> required <code>c</code> <code>float</code> required <p>Returns:</p> Name Type Description <code>y</code> <code>float</code> <p><code>y = a*x**2 + b*x + c</code></p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def degre2(x, a, b, c):\n    \"\"\"2nd degree polynomial.\n\n    Parameters\n    ----------\n    x : array-like or float\n    a : float\n    b : float\n    c : float\n\n    Returns\n    -------\n    y : float\n        `y = a*x**2 + b*x + c`\n    \"\"\"\n    return a*x*x + b*x + c\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.degre3","title":"<code>useful_functions.degre3(x, a, b, c, d)</code>","text":"<p>3<sup>rd</sup> degree polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array - like or float</code> required <code>a</code> <code>float</code> required <code>b</code> <code>float</code> required <code>c</code> <code>float</code> required <code>d</code> <code>float</code> required <p>Returns:</p> Name Type Description <code>y</code> <code>float</code> <p><code>y = a*x**3 + b*x**2 + c*x + d</code></p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def degre3(x, a, b, c, d):\n    \"\"\"3rd degree polynomial.\n\n    Parameters\n    ----------\n    x : array-like or float\n    a : float\n    b : float\n    c : float\n    d : float\n\n    Returns\n    -------\n    y : float\n        `y = a*x**3 + b*x**2 + c*x + d`\n    \"\"\"\n    return a*x*x*x + b*x*x + c*x + d\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.f_lin","title":"<code>useful_functions.f_lin(x, a, b)</code>","text":"<p>Linear function: returns f(x) = a*x + b</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float or ndarray</code> required <code>a</code> <code>float</code> <p>The line slope.</p> required <code>b</code> <code>float</code> <p>The origin ordinate.</p> required <p>Returns:</p> Type Description <code>f(x) = a*x + b : float or ndarray</code> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def f_lin(x, a, b):\n    \"\"\"Linear function: returns f(x) = a*x + b\n\n    Parameters\n    ----------\n    x : float or ndarray\n    a : float\n        The line slope.\n    b : float\n        The origin ordinate.\n\n    Returns\n    -------\n    f(x) = a*x + b : float or ndarray\n    \"\"\"\n    return a*x + b\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.fit_black_body","title":"<code>useful_functions.fit_black_body(lam, sp, T_bounds=(0, 1000000.0))</code>","text":"<p>Return the temperature associated to the fitted black body thermical spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>array - like</code> <p>The wavelength array (in m).</p> required <code>sp</code> <code>array - like</code> <p>The spectral radiance (in W.m-2.sr-1.m-1) to be fitted.</p> required <code>T_bounds</code> <code>2 - tuple</code> <p>The bounds for the temperature fitting.</p> <code>(0, 1e6)</code> <p>Returns:</p> Name Type Description <code>T</code> <code>float</code> <p>The temperature of the fitted Planck's law radiance (in K).</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def fit_black_body(lam, sp, T_bounds=(0, 1e6)):\n    \"\"\"Return the temperature associated to the fitted black body thermical\n    spectrum.\n\n    Parameters\n    ----------\n    lam : array-like\n        The wavelength array (in m).\n    sp : array-like\n        The spectral radiance (in W.m-2.sr-1.m-1) to be fitted.\n    T_bounds : 2-tuple, default (0, 1e6)\n        The bounds for the temperature fitting.\n\n    Returns\n    -------\n    T : float\n        The temperature of the fitted Planck's law radiance (in K).\n    \"\"\"\n    T = curve_fit(planck, lam, sp, bounds=T_bounds)[0][0]\n    return T\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.idl_spline","title":"<code>useful_functions.idl_spline(X, Y, T, sigma=1.0)</code>","text":"<p>Performs a cubic spline interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The abcissa vector. Values MUST be monotonically increasing.</p> required <code>Y</code> <code>ndarray</code> <p>The vector of ordinate values corresponding to X.</p> required <code>T</code> <code>ndarray</code> <p>The vector of abcissae values for which the ordinate is desired. The values of T MUST be monotonically increasing.</p> required <code>Sigma</code> <code>float</code> <p>The amount of \"tension\" that is applied to the curve. The         default value is 1.0. If sigma is close to 0, (e.g., .01),         then effectively there is a cubic spline fit. If sigma         is large, (e.g., greater than 10), then the fit will be like         a polynomial interpolation.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>spl</code> <code>ndarray</code> <p>Vector of interpolated ordinates. Result(i) = value of the function at T(i).</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def idl_spline(X, Y, T, sigma = 1.0):\n    \"\"\"Performs a cubic spline interpolation.\n\n    Parameters\n    ----------\n    X : ndarray\n        The abcissa vector. Values MUST be monotonically increasing.\n    Y : ndarray\n        The vector of ordinate values corresponding to X.\n    T : ndarray\n        The vector of abcissae values for which the ordinate is\n        desired. The values of T MUST be monotonically increasing.\n    Sigma :\u00a0float, default 1.0\n        The amount of \"tension\" that is applied to the curve. The\n\t\tdefault value is 1.0. If sigma is close to 0, (e.g., .01),\n\t\tthen effectively there is a cubic spline fit. If sigma\n\t\tis large, (e.g., greater than 10), then the fit will be like\n\t\ta polynomial interpolation.\n\n    Returns\n    -------\n    spl :\u00a0ndarray\n\t    Vector of interpolated ordinates.&lt;/br&gt;\n\t    Result(i) = value of the function at T(i).\n    \"\"\"\n    n = min(len(X), len(Y))\n    if n &lt;= 2:\n        print('X and Y must be arrays of 3 or more elements.')\n    if sigma != 1.0:\n        sigma = min(sigma, 0.001)\n    yp = np.zeros(2*n)\n    delx1 = X[1]-X[0]\n    dx1 = (Y[1]-Y[0])/delx1\n    nm1 = n-1\n    nmp = n+1\n    delx2 = X[2]-X[1]\n    delx12 = X[2]-X[0]\n    c1 = -(delx12+delx1)/(delx12*delx1)\n    c2 = delx12/(delx1*delx2)\n    c3 = -delx1/(delx12*delx2)\n    slpp1 = c1*Y[0]+c2*Y[1]+c3*Y[2]\n    deln = X[nm1]-X[nm1-1]\n    delnm1 = X[nm1-1]-X[nm1-2]\n    delnn = X[nm1]-X[nm1-2]\n    c1 = (delnn+deln)/(delnn*deln)\n    c2 = -delnn/(deln*delnm1)\n    c3 = deln/(delnn*delnm1)\n    slppn = c3*Y[nm1-2]+c2*Y[nm1-1]+c1*Y[nm1]\n    sigmap = sigma*nm1/(X[nm1]-X[0])\n    dels = sigmap*delx1\n    exps = np.exp(dels)\n    sinhs = 0.5*(exps-1/exps)\n    sinhin = 1/(delx1*sinhs)\n    diag1 = sinhin*(dels*0.5*(exps+1/exps)-sinhs)\n    diagin = 1/diag1\n    yp[0] = diagin*(dx1-slpp1)\n    spdiag = sinhin*(sinhs-dels)\n    yp[n] = diagin*spdiag\n    delx2 = X[1:]-X[:-1]\n    dx2 = (Y[1:]-Y[:-1])/delx2\n    dels = sigmap*delx2\n    exps = np.exp(dels)\n    sinhs = 0.5*(exps-1/exps)\n    sinhin = 1/(delx2*sinhs)\n    diag2 = sinhin*(dels*(0.5*(exps+1/exps))-sinhs)\n    diag2 = np.concatenate([np.array([0]), diag2[:-1]+diag2[1:]])\n    dx2nm1 = dx2[nm1-1]\n    dx2 = np.concatenate([np.array([0]), dx2[1:]-dx2[:-1]])\n    spdiag = sinhin*(sinhs-dels)\n    for i in range(1, nm1):\n        diagin = 1/(diag2[i]-spdiag[i-1]*yp[i+n-1])\n        yp[i] = diagin*(dx2[i]-spdiag[i-1]*yp[i-1])\n        yp[i+n] = diagin*spdiag[i]\n    diagin = 1/(diag1-spdiag[nm1-1]*yp[n+nm1-1])\n    yp[nm1] = diagin*(slppn-dx2nm1-spdiag[nm1-1]*yp[nm1-1])\n    for i in range(n-2, -1, -1):\n        yp[i] = yp[i]-yp[i+n]*yp[i+1]\n    m = len(T)\n    subs = np.repeat(nm1, m)\n    s = X[nm1]-X[0]\n    sigmap = sigma*nm1/s\n    j = 0\n    for i in range(1, nm1+1):\n        while T[j] &lt; X[i]:\n            subs[j] = i\n            j += 1\n            if j == m:\n                break\n        if j == m:\n            break\n    subs1 = subs-1\n    del1 = T-X[subs1]\n    del2 = X[subs]-T\n    dels = X[subs]-X[subs1]\n    exps1 = np.exp(sigmap*del1)\n    sinhd1 = 0.5*(exps1-1/exps1)\n    exps = np.exp(sigmap*del2)\n    sinhd2 = 0.5*(exps-1/exps)\n    exps = exps1*exps\n    sinhs = 0.5*(exps-1/exps)\n    spl = (yp[subs]*sinhd1+yp[subs1]*sinhd2)/sinhs+((Y[subs]-yp[subs])*del1+(Y[subs1]-yp[subs1])*del2)/dels\n    if m == 1:\n        return spl[0]\n    else:\n        return spl\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.load_pickle","title":"<code>useful_functions.load_pickle(filename, disp=True)</code>","text":"<p>Load and return a previously saved object with pickle.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path.</p> required <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the loading filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>obj</code> <code>Object</code> <p>The loaded object.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def load_pickle(filename, disp=True):\n    \"\"\"Load and return a previously saved object with pickle.\n\n    Parameters\n    ----------\n    filename : str\n        The file path.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the loading filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n\n    Returns\n    -------\n    obj : Object\n        The loaded object.\n    \"\"\"\n    filename2 = myglob(filename)\n    with open(filename2, 'rb') as input_file:\n        obj = pickle.load(input_file)\n        if disp:\n            print('\\033[03m' + filename2 + '\\033[0;01;34m loaded\\033[0m')\n        return obj\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.median_filter","title":"<code>useful_functions.median_filter(sp, n)</code>","text":"<p>Apply a median filter on the values of the spectrum, by replacing each value by the median of the values in a 2n+1 wide window, centered on the considered value.</p> <p>Parameters:</p> Name Type Description Default <code>sp</code> <code>ndarray</code> <p>Array of transmittance values.</p> required <code>n</code> <code>int</code> <p>The len of the window the moving median is 2n+1.</p> required <p>Returns:</p> Name Type Description <code>sp_med</code> <code>ndarray</code> <p>Filtered transmittance array.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def median_filter(sp, n):\n    \"\"\"Apply a median filter on the values of the spectrum, by replacing each value\n    by the median of the values in a 2n+1 wide window, centered on the considered value.\n\n    Parameters\n    ----------\n    sp : ndarray\n        Array of transmittance values.\n    n : int\n        The len of the window the moving median is 2n+1.\n\n    Returns\n    -------\n    sp_med : ndarray\n        Filtered transmittance array.\n    \"\"\"\n    if n==0:\n        return sp\n    elif n &lt; 0:\n        raise ValueError('n must be &gt;= 0')\n    sp_med = deepcopy(sp)\n    for i in range(n):\n        if np.isnan(sp[i]):\n            sp_med[i] = np.nan\n        else:\n            sp_med[i] = np.nanmedian(sp_med[:2*i+1])\n    for i in range(n, len(sp)-n):\n        if np.isnan(sp[i]):\n            sp_med[i] = np.nan\n        else:\n            sp_med[i] = np.nanmedian(sp_med[i-n:i+n+1])\n    for i in range(len(sp)-n, len(sp)):\n        if np.isnan(sp[i]):\n            sp_med[i] = np.nan\n        else:\n            sp_med[i] = np.nanmedian(sp_med[-2*(len(sp)-i):])\n    return sp_med\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.moving_average","title":"<code>useful_functions.moving_average(sp, n)</code>","text":"<p>Apply a moving average filter on the values of the spectrum, by replacing each value by the average of the values in a 2n+1 wide window, centered on the considered value.</p> <p>Parameters:</p> Name Type Description Default <code>sp</code> <code>ndarray</code> <p>Array of the transmittance values.</p> required <code>n</code> <code>int</code> <p>The len of the window of the moving average is 2n+1.</p> required <p>Returns:</p> Name Type Description <code>sp_med</code> <code>ndarray</code> <p>Filtered transmittance array.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def moving_average(sp, n):\n    \"\"\"Apply a moving average filter on the values of the spectrum, by replacing each value\n    by the average of the values in a 2n+1 wide window, centered on the considered value.\n\n    Parameters\n    ----------\n    sp : ndarray\n        Array of the transmittance values.\n    n : int\n        The len of the window of the moving average is 2n+1.\n\n    Returns\n    -------\n    sp_med : ndarray\n        Filtered transmittance array.\n    \"\"\"\n    if n==0:\n        return sp\n    elif n &lt; 0:\n        raise ValueError('n must be &gt;= 0')\n    sp_moy = deepcopy(sp)\n    for i in range(n):\n        if np.isnan(sp[i]):\n            sp_moy[i] = np.nan\n        else:\n            sp_moy[i] = np.nanmean(sp_moy[:2*i+1])\n    for i in range(n, len(sp)-n):\n        if np.isnan(sp[i]):\n            sp_moy[i] = np.nan\n        else:\n            sp_moy[i] = np.nanmean(sp_moy[i-n:i+n+1])\n    for i in range(len(sp)-n, len(sp)):\n        if np.isnan(sp[i]):\n            sp_moy[i] = np.nan\n        else:\n            sp_moy[i] = np.nanmean(sp_moy[-2*(len(sp)-i):])\n    return sp_moy\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.myglob","title":"<code>useful_functions.myglob(basename, exclude=[], recursive=False)</code>","text":"<p>Return the absolute path according to the input <code>basename</code>. If multiple files corresponds to <code>basename</code>, the user will be asked to choose one.</p> <ul> <li><code>int</code> \u2192 Select the corresponding filename.</li> <li><code>q</code>/<code>quit</code>/<code>exit</code> \u2192 Return <code>None</code>.</li> <li><code>a</code>/<code>all</code> \u2192 Return the list of all filenames.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>basename</code> <code>str</code> <p>The basename of the target file.</p> required <code>exclude</code> <code>array-like of str</code> <p>List of sub-strings to exclude from the results.</p> <code>[]</code> <code>recursive</code> <code>bool</code> <p>If recursive is True, the pattern <code>**</code> will match any files and zero or more directories and subdirectories.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>fname</code> <code>str</code> <p>The absolute path of the selected file.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def myglob(basename, exclude=[], recursive=False):\n    \"\"\"Return the absolute path according to the input `basename`.\n    If multiple files corresponds to `basename`, the user will be asked\n    to choose one.\n\n    --------------------------------------------\n    * `int` --&gt; Select the corresponding filename.&lt;/br&gt;\n    * `q`/`quit`/`exit` --&gt; Return `None`.&lt;/br&gt;\n    * `a`/`all` --&gt; Return the list of all filenames.&lt;/br&gt;\n\n    --------------------------------------------\n\n    Parameters\n    ----------\n    basename : str\n        The basename of the target file.\n    exclude : array-like of str, default []\n        List of sub-strings to exclude from the results.\n    recursive : bool, default False\n        If recursive is True, the pattern `**` will match any files and\n        zero or more directories and subdirectories.\n\n    Returns\n    -------\n    fname : str\n        The absolute path of the selected file.\n    \"\"\"\n    fnames = glob.glob(basename, recursive=recursive)\n    if not isinstance(exclude, (list, np.ndarray)):\n        raise ValueError(\"exclude parameter must be a list or numpy.ndarray\")\n    if len(exclude) &gt; 0:\n        fnames2 = []\n        for name in fnames:\n            test = True\n            for excl in exclude:\n                if excl in name:\n                    test = False\n                    continue\n            if test:\n                fnames2.append(name)\n        fnames = fnames2\n    fnames.sort()\n    if fnames == []:\n        # raise ValueError(\"No such file found.\")\n        print(\"\\033[1;33mNo such file found.\\033[0m\")\n        return None\n    elif len(fnames) == 1:\n        return fnames[0]\n    else:\n        dico = {}\n        print('\\033[1m{0} files found :\\033[0m'.format(len(fnames)))\n        for i, fname in enumerate(fnames):\n            dico[str(i+1)] = fname\n            print('{0:&gt;2d} : \\033[3m{1}\\033[0m'.format(i+1, fname))\n        print('\\n\\033[1mEnter the corresponding number to select one filename :\\033[0m')\n        while True:\n            try:\n                # n = input('Selection : ')\n                n = input('&gt;&gt;&gt; ')\n                if n in dico.keys():\n                    return dico[n]\n                elif n=='q' or n=='quit' or n=='exit':\n                    return None\n                elif n=='a' or n=='all':\n                    return fnames\n                else:\n                    print('Error, please enter an integer between 1 and ' \n                        + '{0}'.format(len(fnames)))\n            except KeyboardInterrupt:\n                return None\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.planck","title":"<code>useful_functions.planck(lam, T)</code>","text":"<p>Return the Black body radiance, associated to the input wavelength and temperature. According to the Planck's law.</p> <p>Parameters:</p> Name Type Description Default <code>lam</code> <code>float or array - like</code> <p>The wavelength (in m).</p> required <code>T</code> <code>float</code> <p>The temperature (in K).</p> required <p>Returns:</p> Name Type Description <code>B_lam</code> <code>float or array - like</code> <p>The spectral radiance (in W.m-2.sr-1.m-1).</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def planck(lam, T):\n    \"\"\"Return the Black body radiance, associated to the input wavelength and\n    temperature. According to the Planck's law.\n\n    Parameters\n    ----------\n    lam : float or array-like\n        The wavelength (in m).\n    T : float\n        The temperature (in K).\n\n    Returns\n    -------\n    B_lam : float or array-like\n        The spectral radiance (in W.m-2.sr-1.m-1).\n    \"\"\"\n    h = const.h\n    c = const.c\n    kB = const.k\n    B_lam = (2*h*c*c) / (lam**5) / (np.exp(h*c / (lam*kB*T)) - 1)\n    return B_lam\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.reg_lin","title":"<code>useful_functions.reg_lin(X, Y, **kwargs)</code>","text":"<p>Return the result of the linear regression ( f(x) = a*x + b ) on the input values.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The X-values.</p> required <code>Y</code> <code>ndarray</code> <p>The Y-values.</p> required <code>**kwargs</code> <p>Optional keyword arguments to pass to the <code>scipy.optimize.curve_fit</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>a</code> <code>float</code> <p>Slope of the fitted line.</p> <code>b</code> <code>float</code> <p>Origin ordinate of the fitted line.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def reg_lin(X, Y, **kwargs):\n    \"\"\"Return the result of the linear regression ( f(x) = a*x + b )\n    on the input values.\n\n    Parameters\n    ----------\n    X : ndarray\n        The X-values.\n    Y : ndarray\n        The Y-values.\n    **kwargs\n        Optional keyword arguments to pass to the `scipy.optimize.curve_fit` function.\n\n    Returns\n    -------\n    a : float\n        Slope of the fitted line.\n    b : float\n        Origin ordinate of the fitted line.\n    \"\"\"\n    a, b = curve_fit(f_lin, X, Y, **kwargs)[0]\n    return a, b\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.save_pickle","title":"<code>useful_functions.save_pickle(obj, target_path, disp=True)</code>","text":"<p>Save an object at the selected path using the pickle module.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>The object to save.</p> required <code>target_path</code> <code>str</code> <p>The saving path name.</p> required <code>disp</code> <code>bool</code> <p>Control the display.     | <code>True</code> \u2192 Print the saving filename.     | <code>False</code> \u2192 Nothing printed.</p> <code>True</code> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def save_pickle(obj, target_path, disp=True):\n    \"\"\"Save an object at the selected path using the pickle module.\n\n    Parameters\n    ----------\n    obj : Object\n        The object to save.\n    target_path : str\n        The saving path name.\n    disp : bool, default True\n        Control the display.&lt;/br&gt;\n            | `True` --&gt; Print the saving filename.&lt;/br&gt;\n            | `False` --&gt; Nothing printed.\n    \"\"\"\n    with open(target_path, 'wb') as output:\n        pickle.dump(obj, output)\n    if disp:\n        print('\\033[01;34mSaved as \\033[0;03m' + target_path + '\\033[0m')\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.sort_dict","title":"<code>useful_functions.sort_dict(dico)</code>","text":"<p>Sort a dictionary by its keys values.</p> <p>Parameters:</p> Name Type Description Default <code>dico</code> <code>dict</code> <p>The input unsorted dictionary.</p> required <p>Returns:</p> Name Type Description <code>dico_sorted</code> <code>dict</code> <p>The sorted dictionary.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def sort_dict(dico):\n    \"\"\"Sort a dictionary by its keys values.\n\n    Parameters\n    ----------\n    dico : dict\n        The input unsorted dictionary.\n\n    Returns\n    -------\n    dico_sorted : dict\n        The sorted dictionary.\n    \"\"\"\n    # Conversion en np.arrays\n    values = np.array(list(dico.values()))\n    keys = np.array(list(dico.keys()))\n    # Tri par valeurs de cl\u00e9 croissantes\n    i_ord = np.argsort(keys)\n    keys2 = deepcopy(keys[i_ord])\n    values2 = deepcopy(values[i_ord])\n    # Sauvegarde dans un nouveau dictionnaire \n    dico_sorted = {}\n    for i in range(len(keys2)):\n        dico_sorted[keys2[i]] = values2[i]\n    return dico_sorted\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.test_security_overwrite","title":"<code>useful_functions.test_security_overwrite(path)</code>","text":"<p>Test if a file already exists, and if yes ask the user if he wants to ovewrite it or not.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The target file path.</p> required <p>Returns:</p> Name Type Description <code>overwrite</code> <code>bool</code> <p>| <code>True</code> \u2192 No existent file, or overwriting allowed. | <code>False</code> \u2192 Existent file, no overwriting.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def test_security_overwrite(path):\n    \"\"\"Test if a file already exists, and if yes ask the user if he wants to\n    ovewrite it or not.\n\n    Parameters\n    ----------\n    path : str\n        The target file path.\n\n    Returns\n    -------\n    overwrite : bool\n        | `True` --&gt; No existent file, or overwriting allowed.&lt;/br&gt;\n        | `False` --&gt; Existent file, no overwriting.\n    \"\"\"\n    erase = 'n'\n    if glob.glob(path) != []:\n        try:\n            erase = input('Do you really want to erase and replace \\033[3m' + path +\n                        '\\033[0m ? (y/N) ')\n        except KeyboardInterrupt:\n            erase = 'n'\n        if erase != 'y' :\n            print(\"\\033[1mFile preserved\\033[0m\")\n            return False\n        else:\n            return True\n    else:\n        return True\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.where_closer","title":"<code>useful_functions.where_closer(value, array)</code>","text":"<p>Return the index of the closest value to <code>value</code> in <code>array</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Searched value.</p> required <code>array</code> <code>ndarray</code> <p>The array.</p> required <p>Returns:</p> Name Type Description <code>i</code> <code>int</code> <p>The index of the closer value to <code>value</code> in <code>array</code>.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def where_closer(value, array):\n    \"\"\"Return the index of the closest value to `value` in `array`.\n\n    Parameters\n    ----------\n    value : float\n        Searched value.\n    array : ndarray\n        The array.\n\n    Returns\n    -------\n    i : int\n        The index of the closer value to `value` in `array`.\n    \"\"\"\n    array2 = np.abs(array - value)\n    i_closer = np.where(array2 == np.nanmin(array2))[0][0]\n    return i_closer\n</code></pre>"},{"location":"reference/useful_functions/#useful_functions.where_closer_array","title":"<code>useful_functions.where_closer_array(values, array)</code>","text":"<p>Return the list of the indexes of the closest values to <code>values</code> in <code>array</code>.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>Array of searched values.</p> required <code>array</code> <code>ndarray</code> <p>The array.</p> required <p>Returns:</p> Name Type Description <code>I</code> <code>ndarray</code> <p>Array of the index of the closest values in <code>array</code>.</p> Source code in <code>omegapy/useful_functions.py</code> <pre><code>def where_closer_array(values, array):\n    \"\"\"Return the list of the indexes of the closest values to `values` in `array`.\n\n    Parameters\n    ----------\n    values : ndarray\n        Array of searched values.\n    array : ndarray\n        The array.\n\n    Returns\n    -------\n    I : ndarray\n        Array of the index of the closest values in `array`.\n    \"\"\"\n    i_closer = []\n    for val in values:\n        i_closer.append(where_closer(val, array))\n    return np.array(i_closer)\n</code></pre>"}]}